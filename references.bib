pattern matching

Imported from Zotero at 9:47 am Tue, 14th Nov 23
 


@inproceedings{jenks_scratchpad_1974,
	address = {Santa Monica, California, United States},
	title = {The {SCRATCHPAD} language},
	url = {http://portal.acm.org/citation.cfm?doid=800233.807051},
	doi = {10.1145/800233.807051},
	language = {en},
	urldate = {2023-11-13},
	booktitle = {Proceedings of the {ACM} {SIGPLAN} symposium on {Very} high level languages  -},
	publisher = {ACM Press},
	author = {Jenks, R. D.},
	year = {1974},
	pages = {101--111},
}

@inproceedings{wadler_sigplan_2009,
	address = {Edinburgh Scotland},
	title = {{SIGPLAN} {Programming} {Languages} {Achievement} {Award} {Rod} {Burstall}},
	isbn = {9781605583327},
	url = {https://dl.acm.org/doi/10.1145/1596550.1667731},
	doi = {10.1145/1596550.1667731},
	language = {en},
	urldate = {2023-11-10},
	booktitle = {Proceedings of the 14th {ACM} {SIGPLAN} international conference on {Functional} programming},
	publisher = {ACM},
	author = {Wadler, Phil},
	month = aug,
	year = {2009},
}

@inproceedings{krishnaswami_focusing_2009,
	address = {Savannah GA USA},
	title = {Focusing on pattern matching},
	isbn = {9781605583792},
	url = {https://dl.acm.org/doi/10.1145/1480881.1480927},
	doi = {10.1145/1480881.1480927},
	language = {en},
	urldate = {2023-11-10},
	booktitle = {Proceedings of the 36th annual {ACM} {SIGPLAN}-{SIGACT} symposium on {Principles} of programming languages},
	publisher = {ACM},
	author = {Krishnaswami, Neelakantan R.},
	month = jan,
	year = {2009},
	pages = {366--378},
}

@article{milner_theory_1978,
	title = {A theory of type polymorphism in programming},
	volume = {17},
	issn = {00220000},
	url = {https://linkinghub.elsevier.com/retrieve/pii/0022000078900144},
	doi = {10.1016/0022-0000(78)90014-4},
	language = {en},
	number = {3},
	urldate = {2023-11-09},
	journal = {Journal of Computer and System Sciences},
	author = {Milner, Robin},
	month = dec,
	year = {1978},
	pages = {348--375},
}

@book{mcbride_computer_1970,
	title = {Computer {Aided} {Manipulation} of {Symbols}},
	publisher = {Queen's University Belfast},
	author = {McBride, Frederick},
	year = {1970},
}

@article{yuan_live_2023,
	title = {Live {Pattern} {Matching} with {Typed} {Holes}},
	volume = {7},
	issn = {2475-1421},
	url = {https://dl.acm.org/doi/10.1145/3586048},
	doi = {10.1145/3586048},
	abstract = {Several modern programming systems, including GHC Haskell, Agda, Idris, and Hazel, support 
              typed holes 
              . Assigning static and, to varying degree, dynamic meaning to programs with holes allows program editors and other tools to offer meaningful feedback and assistance throughout editing, i.e. in a 
              live 
              manner. Prior work, however, has considered only holes appearing in expressions and types. This paper considers, from type theoretic and logical first principles, the problem of typed pattern holes. We confront two main difficulties, (1) statically reasoning about exhaustiveness and irredundancy when patterns are not fully known, and (2) live evaluation of expressions containing both pattern and expression holes. In both cases, this requires reasoning conservatively about all possible hole fillings. We develop a typed lambda calculus, Peanut, where reasoning about exhaustiveness and redundancy is mapped to the problem of deriving first order entailments. We equip Peanut with an operational semantics in the style of Hazelnut Live that allows us to evaluate around holes in both expressions and patterns. We mechanize the metatheory of Peanut in Agda and formalize a procedure capable of deciding the necessary entailments. Finally, we scale up and implement these mechanisms within Hazel, a programming environment for a dialect of Elm that automatically inserts holes during editing to provide static and dynamic feedback to the programmer in a maximally live manner, i.e. for every possible editor state. Hazel is the first maximally live environment for a general-purpose functional language.},
	language = {en},
	number = {OOPSLA1},
	urldate = {2023-11-09},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Yuan, Yongwei and Guest, Scott and Griffis, Eric and Potter, Hannah and Moon, David and Omar, Cyrus},
	month = apr,
	year = {2023},
	pages = {609--635},
}

@article{burstall_proving_1969,
	title = {Proving {Properties} of {Programs} by {Structural} {Induction}},
	volume = {12},
	issn = {0010-4620, 1460-2067},
	url = {https://academic.oup.com/comjnl/article-lookup/doi/10.1093/comjnl/12.1.41},
	doi = {10.1093/comjnl/12.1.41},
	language = {en},
	number = {1},
	urldate = {2023-11-09},
	journal = {The Computer Journal},
	author = {Burstall, R. M.},
	month = feb,
	year = {1969},
	pages = {41--48},
}

@inproceedings{hertz_what_2010,
	address = {Milwaukee Wisconsin USA},
	title = {What do "{CS1}" and "{CS2}" mean?: investigating differences in the early courses},
	isbn = {978-1-4503-0006-3},
	shorttitle = {What do "{CS1}" and "{CS2}" mean?},
	url = {https://dl.acm.org/doi/10.1145/1734263.1734335},
	doi = {10.1145/1734263.1734335},
	language = {en},
	urldate = {2023-08-25},
	booktitle = {Proceedings of the 41st {ACM} technical symposium on {Computer} science education},
	publisher = {ACM},
	author = {Hertz, Matthew},
	month = mar,
	year = {2010},
	pages = {199--203},
}

@inproceedings{luu_what_2023,
	address = {Toronto ON Canada},
	title = {What is an {Algorithms} {Course}?: {Survey} {Results} of {Introductory} {Undergraduate} {Algorithms} {Courses} in the {U}.{S}.},
	isbn = {978-1-4503-9431-4},
	shorttitle = {What is an {Algorithms} {Course}?},
	url = {https://dl.acm.org/doi/10.1145/3545945.3569820},
	doi = {10.1145/3545945.3569820},
	language = {en},
	urldate = {2023-08-25},
	booktitle = {Proceedings of the 54th {ACM} {Technical} {Symposium} on {Computer} {Science} {Education} {V}. 1},
	publisher = {ACM},
	author = {Luu, Michael and Ferland, Matthew and Nagaraj Rao, Varun and Arora, Arushi and Huynh, Randy and Reiber, Frederick and Wong-Ma, Jennifer and Shindler, Michael},
	month = mar,
	year = {2023},
	pages = {284--290},
}

@article{sentance_computing_2017,
	title = {Computing in the curriculum: {Challenges} and strategies from a teacher’s perspective},
	volume = {22},
	issn = {1573-7608},
	url = {https://doi.org/10.1007/s10639-016-9482-0},
	doi = {10.1007/s10639-016-9482-0},
	abstract = {Computing is being introduced into the curriculum in many countries. Teachers’ perspectives enable us to discover what challenges this presents, and also the strategies teachers claim to be using successfully in teaching the subject across primary and secondary education. The study described in this paper was carried out in the UK in 2014 where teachers were preparing for the mandatory inclusion of Computing into the curriculum. A survey was conducted of over 300 teachers who were currently teaching Computing to elicit their perspectives on challenges and strategies. From the analysis of the data, extrinsic and intrinsic challenges were identified for both teachers and students. In addition, a variety of pedagogical strategies were recommended by teachers from their own practice. In categorising approaches taken by teaching to support students five key themes emerged: unplugged type activities, contextualisation of tasks, collaborative learning, developing computational thinking, and scaffolding programming tasks. Further investigation could support whether these strategies can alleviate the challenges of teaching and learning of Computing for students and teachers. In particular developing student resilience in Computing is seen as a challenge while not many strategies are suggested. The results of this study will be useful for teachers who are new to the teaching of Computing.},
	number = {2},
	journal = {Education and Information Technologies},
	author = {Sentance, Sue and Csizmadia, Andrew},
	month = mar,
	year = {2017},
	pages = {469--495},
}

@article{balreira_survey_2018,
	title = {A survey of the contents in introductory {Computer} {Graphics} courses},
	volume = {77},
	issn = {00978493},
	url = {https://linkinghub.elsevier.com/retrieve/pii/S0097849318301560},
	doi = {10.1016/j.cag.2018.10.001},
	language = {en},
	urldate = {2023-08-01},
	journal = {Computers \& Graphics},
	author = {Balreira, Dennis G. and Walter, Marcelo and Fellner, Dieter W.},
	month = dec,
	year = {2018},
	pages = {88--96},
}

@incollection{ter_beek_2020_2020,
	address = {Cham},
	title = {The 2020 {Expert} {Survey} on {Formal} {Methods}},
	volume = {12327},
	isbn = {978-3-030-58297-5 978-3-030-58298-2},
	url = {https://link.springer.com/10.1007/978-3-030-58298-2_1},
	language = {en},
	urldate = {2023-08-01},
	booktitle = {Formal {Methods} for {Industrial} {Critical} {Systems}},
	publisher = {Springer International Publishing},
	author = {Garavel, Hubert and Beek, Maurice H. ter and Pol, Jaco van de},
	editor = {ter Beek, Maurice H. and Ničković, Dejan},
	year = {2020},
	doi = {10.1007/978-3-030-58298-2_1},
	note = {Series Title: Lecture Notes in Computer Science},
	pages = {3--69},
}

@article{bennedsen_failure_2007,
	title = {Failure rates in introductory programming},
	volume = {39},
	issn = {0097-8418},
	url = {https://dl.acm.org/doi/10.1145/1272848.1272879},
	doi = {10.1145/1272848.1272879},
	abstract = {It is a common conception that CS1 is a very difficult course and that failure rates are high. However, until now there has only been anecdotal evidence for this claim. This article reports on a survey among institutions around the world regarding failure rates in introductory programming courses. The article describes the design of the survey and the results. The number of institutions answering the call for data was unfortunately rather low, so it is difficult to make firm conclusions. It is our hope that this article can be the starting point for a systematic collection of data in order to find solid proof of the actual failure and pass rates of CS1.},
	language = {en},
	number = {2},
	urldate = {2023-08-01},
	journal = {ACM SIGCSE Bulletin},
	author = {Bennedsen, Jens and Caspersen, Michael E.},
	month = jun,
	year = {2007},
	pages = {32--36},
}

@article{bennedsen_failure_2019,
	title = {Failure rates in introductory programming: 12 years later},
	volume = {10},
	issn = {2153-2184, 2153-2192},
	shorttitle = {Failure rates in introductory programming},
	url = {https://dl.acm.org/doi/10.1145/3324888},
	doi = {10.1145/3324888},
	language = {en},
	number = {2},
	urldate = {2023-08-01},
	journal = {ACM Inroads},
	author = {Bennedsen, Jens and Caspersen, Michael E.},
	month = apr,
	year = {2019},
	pages = {30--36},
}

@article{abel_copatterns_2013,
	title = {Copatterns: programming infinite structures by observations},
	volume = {48},
	issn = {0362-1340, 1558-1160},
	shorttitle = {Copatterns},
	url = {https://dl.acm.org/doi/10.1145/2480359.2429075},
	doi = {10.1145/2480359.2429075},
	abstract = {Inductive datatypes provide mechanisms to define finite data such as finite lists and trees via constructors and allow programmers to analyze and manipulate finite data via pattern matching. In this paper, we develop a dual approach for working with infinite data structures such as streams. Infinite data inhabits coinductive datatypes which denote greatest fixpoints. Unlike finite data which is defined by constructors we define infinite data by observations. Dual to pattern matching, a tool for analyzing finite data, we develop the concept of copattern matching, which allows us to synthesize infinite data. This leads to a symmetric language design where pattern matching on finite and infinite data can be mixed.
            We present a core language for programming with infinite structures by observations together with its operational semantics based on (co)pattern matching and describe coverage of copatterns. Our language naturally supports both call-by-name and call-by-value interpretations and can be seamlessly integrated into existing languages like Haskell and ML. We prove type soundness for our language and sketch how copatterns open new directions for solving problems in the interaction of coinductive and dependent types.},
	language = {en},
	number = {1},
	urldate = {2023-01-09},
	journal = {ACM SIGPLAN Notices},
	author = {Abel, Andreas and Pientka, Brigitte and Thibodeau, David and Setzer, Anton},
	month = jan,
	year = {2013},
	pages = {27--38},
}

@article{cockx_elaborating_2020,
	title = {Elaborating dependent (co)pattern matching: {No} pattern left behind},
	volume = {30},
	issn = {0956-7968, 1469-7653},
	shorttitle = {Elaborating dependent (co)pattern matching},
	url = {https://www.cambridge.org/core/product/identifier/S0956796819000182/type/journal_article},
	doi = {10.1017/S0956796819000182},
	abstract = {Abstract
            
              In a dependently typed language, we can guarantee correctness of our programmes by providing formal proofs. To check them, the typechecker elaborates these programs and proofs into a low-level core language. However, this core language is by nature hard to understand by mere humans, so how can we know we proved the right thing? This question occurs in particular for dependent copattern matching, a powerful language construct for writing programmes and proofs by dependent case analysis and mixed induction/coinduction. A definition by copattern matching consists of a list of
              clauses
              that are elaborated to a
              case tree
              , which can be further translated to primitive
              eliminators
              . In previous work this second step has received a lot of attention, but the first step has been mostly ignored so far. We present an algorithm elaborating definitions by dependent copattern matching to a core language with inductive data types, coinductive record types, an identity type, and constants defined by well-typed case trees. To ensure correctness, we prove that elaboration preserves the first-match semantics of the user clauses. Based on this theoretical work, we reimplement the algorithm used by Agda to check left-hand sides of definitions by pattern matching. The new implementation is at the same time more general and less complex, and fixes a number of bugs and usability issues with the old version. Thus, we take another step towards the formally verified implementation of a practical dependently typed language.},
	language = {en},
	urldate = {2023-01-08},
	journal = {Journal of Functional Programming},
	author = {Cockx, Jesper and Abel, Andreas},
	year = {2020},
	pages = {e2},
}

@article{noauthor_control_2010,
	title = {From {Control} {Systems} to {Control} {Software}},
	volume = {30},
	issn = {1066-033X, 1941-000X},
	url = {https://ieeexplore.ieee.org/document/5643477/},
	doi = {10.1109/MCS.2010.938196},
	number = {6},
	urldate = {2022-12-13},
	journal = {IEEE Control Systems},
	month = dec,
	year = {2010},
	pages = {50--71},
}

@article{hoare_emperors_1981,
	title = {The emperor's old clothes},
	volume = {24},
	issn = {0001-0782, 1557-7317},
	url = {https://dl.acm.org/doi/10.1145/358549.358561},
	doi = {10.1145/358549.358561},
	language = {en},
	number = {2},
	urldate = {2022-12-07},
	journal = {Communications of the ACM},
	author = {Hoare, Charles Antony Richard},
	month = feb,
	year = {1981},
	pages = {75--83},
}

@incollection{goos_stratego_2001,
	address = {Berlin, Heidelberg},
	title = {Stratego: {A} {Language} for {Program} {Transformation} {Based} on {Rewriting} {Strategies} {System} {Description} of {Stratego} 0.5},
	volume = {2051},
	isbn = {978-3-540-42117-7 978-3-540-45127-3},
	shorttitle = {Stratego},
	url = {http://link.springer.com/10.1007/3-540-45127-7_27},
	urldate = {2022-12-07},
	booktitle = {Rewriting {Techniques} and {Applications}},
	publisher = {Springer Berlin Heidelberg},
	author = {Visser, Eelco},
	editor = {Goos, Gerhard and Hartmanis, Juris and van Leeuwen, Jan and Middeldorp, Aart},
	year = {2001},
	doi = {10.1007/3-540-45127-7_27},
	note = {Series Title: Lecture Notes in Computer Science},
	pages = {357--361},
}

@misc{ruby_ruby_2019,
	title = {Ruby 2.7.0 {Released}},
	url = {https://www.ruby-lang.org/en/news/2019/12/25/ruby-2-7-0-released/},
	author = {Ruby},
	month = dec,
	year = {2019},
}

@inproceedings{karp_rapid_1972,
	address = {Denver, Colorado, United States},
	title = {Rapid identification of repeated patterns in strings, trees and arrays},
	url = {http://portal.acm.org/citation.cfm?doid=800152.804905},
	doi = {10.1145/800152.804905},
	language = {en},
	urldate = {2022-12-07},
	booktitle = {Proceedings of the fourth annual {ACM} symposium on {Theory} of computing  - {STOC} '72},
	publisher = {ACM Press},
	author = {Karp, Richard M. and Miller, Raymond E. and Rosenberg, Arnold L.},
	year = {1972},
	pages = {125--136},
}

@misc{smits_jeff_optimising_2022,
	title = {Optimising {First}-{Class} {Pattern} {Matching} - {Artefact}},
	copyright = {Creative Commons Attribution 4.0 International, Open Access},
	url = {https://zenodo.org/record/7189905},
	abstract = {This is the artefact for the paper Optimising First-Class Pattern Matching, accepted at the International Conference on Software Language Engineering. It contains a Docker image with the setup to rerun the benchmarks we used in the evaluation of the paper. {\textless}strong{\textgreater}Table of Contents{\textless}/strong{\textgreater} Preliminary PDF version of the accepted paper. Docker image archive, containing: A Linux installation. A development version of Spoofax pre-installed (based on release 2.5.17) (libraries only, no GUI). The benchmark setup as used in the paper, with a check-out of the Tiny Imperative Language Spoofax project. Benchmark results from one previous run.},
	urldate = {2022-12-06},
	publisher = {Zenodo},
	author = {{Smits, Jeff} and {Hartman, Toine}},
	month = oct,
	year = {2022},
	doi = {10.5281/ZENODO.7189905},
}

@book{acm_computing_curricula_task_force_computer_2013,
	title = {Computer {Science} {Curricula} 2013: {Curriculum} {Guidelines} for {Undergraduate} {Degree} {Programs} in {Computer} {Science}},
	isbn = {9781450323093},
	shorttitle = {Computer {Science} {Curricula} 2013},
	url = {http://dl.acm.org/citation.cfm?id=2534860},
	urldate = {2022-12-06},
	publisher = {ACM, Inc},
	editor = {{ACM Computing Curricula Task Force}},
	month = jan,
	year = {2013},
	doi = {10.1145/2534860},
}

@article{bloom_robust_2013,
	title = {Robust scripting via patterns},
	volume = {48},
	issn = {0362-1340, 1558-1160},
	url = {https://dl.acm.org/doi/10.1145/2480360.2384582},
	doi = {10.1145/2480360.2384582},
	abstract = {Dynamic typing in scripting languages is a two-edged sword. On the one hand, it can be more flexible and more concise than static typing. On the other hand, it can lead to less robust code. We argue that patterns can give scripts much of the robustness of static typing, without losing the flexibility and concision of dynamic typing. To make this case, we describe a rich pattern system in the dynamic language Thorn. Thorn patterns interact with its control constructs and scoping rules to support concise and robust test-and-extract idioms. Thorn patterns encompass an extensive set of features from ML-style patterns to regular expressions and beyond. And Thorn patterns can be first-class and support pattern-punning (mirror constructor syntax). Overall, this paper describes a powerful pattern system that makes scripting more robust.},
	language = {en},
	number = {2},
	urldate = {2022-12-04},
	journal = {ACM SIGPLAN Notices},
	author = {Bloom, Bard and Hirzel, Martin J.},
	month = jan,
	year = {2013},
	pages = {29--40},
}

@inproceedings{krebber_efficient_2017,
	address = {Denver CO USA},
	title = {Efficient {Pattern} {Matching} in {Python}},
	isbn = {9781450351249},
	url = {https://dl.acm.org/doi/10.1145/3149869.3149871},
	doi = {10.1145/3149869.3149871},
	language = {en},
	urldate = {2022-12-04},
	booktitle = {Proceedings of the 7th {Workshop} on {Python} for {High}-{Performance} and {Scientific} {Computing}},
	publisher = {ACM},
	author = {Krebber, Manuel and Barthels, Henrik and Bientinesi, Paolo},
	month = nov,
	year = {2017},
	pages = {1--9},
}

@article{krebber_matchpy_2018,
	title = {{MatchPy}: {Pattern} {Matching} in {Python}},
	volume = {3},
	issn = {2475-9066},
	shorttitle = {{MatchPy}},
	url = {http://joss.theoj.org/papers/10.21105/joss.00670},
	doi = {10.21105/joss.00670},
	number = {26},
	urldate = {2022-12-04},
	journal = {Journal of Open Source Software},
	author = {Krebber, Manuel and Barthels, Henrik},
	month = jun,
	year = {2018},
	pages = {670},
}

@inproceedings{kohn_dynamic_2020,
	address = {Virtual USA},
	title = {Dynamic pattern matching with {Python}},
	isbn = {9781450381758},
	url = {https://dl.acm.org/doi/10.1145/3426422.3426983},
	doi = {10.1145/3426422.3426983},
	language = {en},
	urldate = {2022-12-04},
	booktitle = {Proceedings of the 16th {ACM} {SIGPLAN} {International} {Symposium} on {Dynamic} {Languages}},
	publisher = {ACM},
	author = {Kohn, Tobias and van Rossum, Guido and Bucher II, Gary Brandt and {Talin} and Levkivskyi, Ivan},
	month = nov,
	year = {2020},
	pages = {85--98},
}

@article{smith_high-fidelity_2019,
	title = {High-{Fidelity} {Autonomous} {Surface} {Vehicle} {Simulator} for the {Maritime} {RobotX} {Challenge}},
	volume = {44},
	issn = {0364-9059, 1558-1691, 2373-7786},
	url = {https://ieeexplore.ieee.org/document/8548594/},
	doi = {10.1109/JOE.2018.2875571},
	number = {2},
	urldate = {2022-09-30},
	journal = {IEEE Journal of Oceanic Engineering},
	author = {Smith, Peter and Dunbabin, Matthew},
	month = apr,
	year = {2019},
	pages = {310--319},
}

@inproceedings{noori_3d_2017,
	address = {Shanghai, China},
	title = {On {3D} simulators for multi-robot systems in {ROS}: {MORSE} or {Gazebo}?},
	isbn = {9781538639238},
	shorttitle = {On {3D} simulators for multi-robot systems in {ROS}},
	url = {http://ieeexplore.ieee.org/document/8088134/},
	doi = {10.1109/SSRR.2017.8088134},
	urldate = {2022-09-30},
	booktitle = {2017 {IEEE} {International} {Symposium} on {Safety}, {Security} and {Rescue} {Robotics} ({SSRR})},
	publisher = {IEEE},
	author = {Noori, Farzan M. and Portugal, David and Rocha, Rui P. and Couceiro, Micael S.},
	month = oct,
	year = {2017},
	pages = {19--24},
}

@article{noauthor_modular_nodate,
	title = {Modular open robots simulation engine: {MORSE}},
}

@article{paravisi_unmanned_2019,
	title = {Unmanned {Surface} {Vehicle} {Simulator} with {Realistic} {Environmental} {Disturbances}},
	volume = {19},
	issn = {1424-8220},
	url = {https://www.mdpi.com/1424-8220/19/5/1068},
	doi = {10.3390/s19051068},
	abstract = {The use of robotics in disaster scenarios has become a reality. However, an Unmanned Surface Vehicle (USV) needs a robust navigation strategy to face unpredictable environmental forces such as waves, wind, and water current. A starting step toward this goal is to have a programming environment with realistic USV models where designers can assess their control strategies under different degrees of environmental disturbances. This paper presents a simulation environment integrated with robotic middleware which models the forces that act on a USV in a disaster scenario. Results show that these environmental forces affect the USV’s trajectories negatively, indicating the need for more research on USV control strategies considering harsh environmental conditions. Evaluation scenarios were presented to highlight specific features of the simulator, including a bridge inspection scenario with fast water current and winds.},
	language = {en},
	number = {5},
	urldate = {2022-09-30},
	journal = {Sensors},
	author = {Paravisi, Marcelo and H. Santos, Davi and Jorge, Vitor and Heck, Guilherme and Gonçalves, Luiz and Amory, Alexandre},
	month = mar,
	year = {2019},
	pages = {1068},
}

@inproceedings{tosik_mars_2014,
	address = {St. John's, NL},
	title = {{MARS}: {A} simulation environment for marine robotics},
	isbn = {9781479949182 9781479949205 9781479949199},
	shorttitle = {{MARS}},
	url = {http://ieeexplore.ieee.org/document/7003008/},
	doi = {10.1109/OCEANS.2014.7003008},
	urldate = {2022-09-30},
	booktitle = {2014 {Oceans} - {St}. {John}'s},
	publisher = {IEEE},
	author = {Tosik, Thomas and Maehle, Erik},
	month = sep,
	year = {2014},
	pages = {1--7},
}

@article{mario_prats_javier_perez_j_javier_fernandez_pedro_j_sanz_open_2012,
	title = {An open source tool for simulation and supervision of underwater intervention missions},
	author = {Mario Prats; Javier Pérez; J. Javier Fernández; Pedro J. Sanz},
	year = {2012},
}

@article{razzanelli_development_2020,
	title = {Development of a {Hybrid} {Simulator} for {Underwater} {Vehicles} {With} {Manipulators}},
	volume = {45},
	issn = {0364-9059, 1558-1691, 2373-7786},
	url = {https://ieeexplore.ieee.org/document/8862914/},
	doi = {10.1109/JOE.2019.2935801},
	number = {4},
	urldate = {2022-09-30},
	journal = {IEEE Journal of Oceanic Engineering},
	author = {Razzanelli, Matteo and Casini, Simona and Innocenti, Mario and Pollini, Lorenzo},
	month = oct,
	year = {2020},
	pages = {1235--1251},
}

@inproceedings{craighead_survey_2007,
	title = {A {Survey} of {Commercial} \& {Open} {Source} {Unmanned} {Vehicle} {Simulators}},
	doi = {10.1109/ROBOT.2007.363092},
	abstract = {This report presents a survey of computer based simulators for unmanned vehicles. The simulators examined cover a wide spectrum of vehicles including unmanned aerial vehicles, both full scale and micro size; unmanned surface and subsurface vehicles; and unmanned ground vehicles. The majority of simulators use simple numerical simulation and simplistic visualization using custom OpenGL code. An emerging trend is to used modified commercial game engines for physical simulation and visualization. The game engines that are commercially available today are capable of physical simulations providing basic physical properties and interactions between objects. Newer and/or specialized engines such as the flight simulator X-Plane or Ageia PhysX and Havok physics engines, are capable of simulating more complex physical interactions between objects. Researchers in need of a simulator have a choice of using game engines or available open source and commercially available simulators, allowing resources to be focused on research instead of building a new simulator. We conclude that it is no longer necessary to build a new simulator from scratch.},
	booktitle = {Proceedings 2007 {IEEE} {International} {Conference} on {Robotics} and {Automation}},
	author = {Craighead, Jeff and Murphy, Robin and Burke, Jenny and Goldiez, Brian},
	month = apr,
	year = {2007},
	note = {ISSN: 1050-4729},
	keywords = {Aerospace simulation, Computational modeling, Computer simulation, Engines, Land vehicles, Numerical simulation, Physics, Road vehicles, Unmanned aerial vehicles, Visualization},
	pages = {852--857},
}

@book{christiansen_perl_1998,
	address = {Sebastopol, CA},
	edition = {1st ed},
	title = {Perl cookbook},
	isbn = {9781565922433},
	publisher = {O'Reilly},
	author = {Christiansen, Tom and Torkington, Nathan},
	year = {1998},
	keywords = {Perl (Computer program language)},
}

@inproceedings{jasim_formal_2018,
	address = {Copenhagen},
	title = {Formal {Verification} of {Quadcopter} {Flight} {Envelop} {Using} {Theorem} {Prover}},
	isbn = {978-1-5386-7698-1},
	url = {https://ieeexplore.ieee.org/document/8511595/},
	doi = {10.1109/CCTA.2018.8511595},
	urldate = {2022-08-18},
	booktitle = {2018 {IEEE} {Conference} on {Control} {Technology} and {Applications} ({CCTA})},
	publisher = {IEEE},
	author = {Jasim, Omar A. and Veres, Sandor M.},
	month = aug,
	year = {2018},
	pages = {1502--1507},
}

@inproceedings{jasim_towards_2017,
	address = {Sinaia},
	title = {Towards formal proofs of feedback control theory},
	isbn = {978-1-5386-3842-2},
	url = {http://ieeexplore.ieee.org/document/8107009/},
	doi = {10.1109/ICSTCC.2017.8107009},
	urldate = {2022-08-18},
	booktitle = {2017 21st {International} {Conference} on {System} {Theory}, {Control} and {Computing} ({ICSTCC})},
	publisher = {IEEE},
	author = {Jasim, Omar A. and Veres, Sandor M.},
	month = oct,
	year = {2017},
	pages = {43--48},
}

@inproceedings{anta_automatic_2010,
	address = {New York, NY, USA},
	series = {{EMSOFT} '10},
	title = {Automatic verification of control system implementations},
	isbn = {978-1-60558-904-6},
	url = {http://doi.org/10.1145/1879021.1879024},
	doi = {10.1145/1879021.1879024},
	abstract = {Software implementations of controllers for physical subsystems form the core of many modern safety-critical systems such as aircraft flight control and automotive engine control. A fundamental property of such implementations is stability, the guarantee that the physical plant converges to a desired behavior under the actions of the controller. We present a methodology and a tool to perform automated static analysis of embedded controller code for stability of the controlled physical system. The design of controllers for physical systems provides not only the controllers but also mathematical proofs of their stability under idealized mathematical models. Unfortunately, since these models do not capture most of the implementation details, it is not always clear if the stability properties are retained by the software implementation, either because of software bugs, or because of imprecisions arising from fixed-precision arithmetic or timing. Our methodology is based on the following separation of concerns. First, we analyze the controller mathematical models to derive bounds on the implementation errors that can be tolerated while still guaranteeing stability. Second, we automatically analyze the controller software to check if the maximal implementation error is within the tolerance bound computed in the first step. We have implemented this methodology in Costan, a tool to check stability for controller implementations. Using Costan, we analyzed a set of control examples whose mathematical models are given in Matlab/Simulink and whose C implementation is generated using Real-Time Workshop. Unlike previous static analysis research, which has focused on proving low-level runtime properties such as absence of buffer overruns or arithmetic overflows, our technique combines analysis of the mathematical controller models and automated analysis of source code to guarantee application-level stability properties.},
	urldate = {2022-08-08},
	booktitle = {Proceedings of the tenth {ACM} international conference on {Embedded} software},
	publisher = {Association for Computing Machinery},
	author = {Anta, Adolfo and Majumdar, Rupak and Saha, Indranil and Tabuada, Paulo},
	month = oct,
	year = {2010},
	keywords = {partly\_read},
	pages = {9--18},
}

@inproceedings{chan_formal_nodate,
	title = {Formal {Veriﬁcation} of {Stability} {Properties} of {Cyber}-physical {Systems}},
	language = {en},
	author = {Chan, Matthew and Ricketts, Daniel and Lerner, Sorin and Malecha, Gregory},
	keywords = {Coq, partly\_read},
	pages = {2},
}

@inproceedings{martel_overview_2005,
	address = {Berlin, Heidelberg},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {An {Overview} of {Semantics} for the {Validation} of {Numerical} {Programs}},
	isbn = {978-3-540-30579-8},
	doi = {10.1007/978-3-540-30579-8_4},
	abstract = {In this article, we introduce a simple formal semantics for floating-point numbers with errors which is expressive enough to be formally compared to the other methods. Next, we define formal semantics for interval, stochastic, automatic differentiation and error series methods. This enables us to formally compare the properties calculated in each semantics to our reference, simple semantics. Most of these methods having been developed to verify numerical intensive codes, we also discuss their adequacy to the formal validation of softwares and to static analysis. Finally, this study is completed by experimental results.},
	language = {en},
	booktitle = {Verification, {Model} {Checking}, and {Abstract} {Interpretation}},
	publisher = {Springer},
	author = {Martel, Matthieu},
	editor = {Cousot, Radhia},
	year = {2005},
	pages = {59--77},
}

@inproceedings{rues_modular_1996,
	address = {Berlin, Heidelberg},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Modular verification of {SRT} division},
	isbn = {978-3-540-68599-9},
	doi = {10.1007/3-540-61474-5_63},
	abstract = {We describe a formal specification and verification in PVS for the general theory of SRT division, and for the hardware design of a specific implementation. The specification demonstrates how attributes of the PVS language (in particular, predicate subtypes) allow the general theory to be developed in a readable manner that is similar to textbook presentations, while the PVS table construct allows direct specification of the implementation's quotient look-up table. Verification of the derivations in the SRT theory and for the data path and look-up table of the implementation are highly automated and performed for arbitrary, but finite precision; in addition, the theory is verified for general radix, while the implementation is specialized to radix 4. The effectiveness of the automation derives from PVS's tight integration of rewriting with decision procedures for equality, linear arithmetic over integers and rationals, and propositional logic. This example demonstrates that the resources of an expressive specification language and of a general-purpose theorem prover are not inimical to highly automated verification in this domain, and can contribute to clarity, generality, and reuse.},
	language = {en},
	booktitle = {Computer {Aided} {Verification}},
	publisher = {Springer},
	author = {Rueß, H. and Shankar, N. and Srivas, M. K.},
	editor = {Alur, Rajeev and Henzinger, Thomas A.},
	year = {1996},
	pages = {123--134},
}

@article{clarke_verifying_1999,
	title = {Verifying the {SRT} {Division} {Algorithm} {Using} {Theorem} {Proving} {Techniques}},
	volume = {14},
	issn = {1572-8102},
	url = {https://doi.org/10.1023/A:1008665528003},
	doi = {10.1023/A:1008665528003},
	abstract = {We verify the correctness of an SRT division circuit similar to the one in the Intel Pentium processor. The circuit and its correctness conditions are formalized as a set of algebraic relations on the real numbers. The main obstacle to applying theorem proving techniques for hardware verification is the need for detailed user guidance of proofs. We overcome the need for detailed proof guidance in this example by using a powerful theorem prover called Analytica. Analytica uses symbolic algebra techniques to carry out the proofs in this paper with much less guidance than existing general purpose theorem provers require for algebraic reasoning.},
	language = {en},
	number = {1},
	urldate = {2022-08-08},
	journal = {Formal Methods in System Design},
	author = {Clarke, Edmund M. and German, Steven M. and Zhao, Xudong},
	month = jan,
	year = {1999},
	note = {Number: 1},
	pages = {7--44},
}

@article{dellsie_formal_1990,
	title = {A formal specification of an oscilloscope},
	volume = {7},
	issn = {1937-4194},
	doi = {10.1109/52.57890},
	abstract = {This case study presents the development of an abstract oscilloscope specification, using Z notation. A description is given of the problem and its context. An abstract model of an oscilloscope that clarifies its user-accessible functions is described. Issues that must be addressed to scale up this specification to deal with more complicated, realistic oscilloscopes are discussed. The use of formal models and formal reasoning in this specification is examined.},
	number = {5},
	journal = {IEEE Software},
	author = {Dellsie, N. and Gartan, D.},
	month = sep,
	year = {1990},
	note = {Number: 5
Conference Name: IEEE Software},
	keywords = {partly\_read},
	pages = {29--36},
}

@article{elseaidy_modeling_1997,
	series = {{COST} 247, {Verification} and validation methods for formal descriptions},
	title = {Modeling and verifying active structural control systems},
	volume = {29},
	issn = {0167-6423},
	url = {https://www.sciencedirect.com/science/article/pii/S0167642396000317},
	doi = {10.1016/S0167-6423(96)00031-7},
	abstract = {This paper presents the results of a case study involving the use of a formal graphical notation, Modechart, and an automatic verification tool, the Concurrency Workbench, in the analysis of the design of a fault-tolerant active structural control system. Such control systems must satisfy strict requirements on their timing behavior; we show how to use various equivalence-based features supported by the Workbench to examine the timing behavior of different design alternatives, one of which has in excess of 1019 states. The central insight arising from the study involves the importance of compositionality for reasoning about large and complex systems; in particular, the success of the case study depends integrally on our notation's and tool's support of componentwise minimization.},
	language = {en},
	number = {1},
	urldate = {2022-08-08},
	journal = {Science of Computer Programming},
	author = {Elseaidy, Wael M. and Cleaveland, Rance and Baugh, John W.},
	month = jul,
	year = {1997},
	note = {Number: 1},
	keywords = {Concurrency Workbench, partly\_read},
	pages = {99--122},
}

@article{barrett_formal_1989,
	title = {Formal methods applied to a floating-point number system},
	volume = {15},
	issn = {1939-3520},
	doi = {10.1109/32.24710},
	abstract = {A formalization of the IEEE standard for binary floating-point arithmetic (ANSI/IEEE Std. 754-1985) is presented in the set-theoretic specification language Z. The formal specification is refined into four sequential components, which unpack the operands, perform the arithmetic, and pack and round the result. This refinement follows proven rules and so demonstrates a mathematically rigorous method of program development. In the course of the proofs, useful internal representations of floating-point numbers are specified. The procedures presented form the basis for the floating-point unit of the Inmos IMS T800 transputer.{\textless}{\textgreater}},
	number = {5},
	journal = {IEEE Transactions on Software Engineering},
	author = {Barrett, G.},
	month = may,
	year = {1989},
	note = {Number: 5
Conference Name: IEEE Transactions on Software Engineering},
	pages = {611--621},
}

@article{daversin-catty_abstractions_2021,
	title = {Abstractions and {Automated} {Algorithms} for {Mixed} {Domain} {Finite} {Element} {Methods}},
	volume = {47},
	issn = {0098-3500},
	url = {http://doi.org/10.1145/3471138},
	doi = {10.1145/3471138},
	abstract = {Mixed dimensional partial differential equations (PDEs) are equations coupling unknown fields defined over domains of differing topological dimension. Such equations naturally arise in a wide range of scientific fields including geology, physiology, biology, and fracture mechanics. Mixed dimensional PDEs are also commonly encountered when imposing non-standard conditions over a subspace of lower dimension, e.g., through a Lagrange multiplier. In this article, we present general abstractions and algorithms for finite element discretizations of mixed domain and mixed dimensional PDEs of codimension up to one (i.e., nD-mD with {\textbar}n-m{\textbar} ≤ 1). We introduce high-level mathematical software abstractions together with lower-level algorithms for expressing and efficiently solving such coupled systems. The concepts introduced here have also been implemented in the context of the FEniCS finite element software. We illustrate the new features through a range of examples, including a constrained Poisson problem, a set of Stokes-type flow models, and a model for ionic electrodiffusion.},
	number = {4},
	urldate = {2022-08-07},
	journal = {ACM Transactions on Mathematical Software},
	author = {Daversin-Catty, Cécile and Richardson, Chris N. and Ellingsrud, Ada J. and Rognes, Marie E.},
	month = sep,
	year = {2021},
	note = {Number: 4},
	pages = {31:1--31:36},
}

@article{borges_algorithm_2020,
	title = {Algorithm 1014: {An} {Improved} {Algorithm} for hypot(x,y)},
	volume = {47},
	issn = {0098-3500},
	shorttitle = {Algorithm 1014},
	url = {http://doi.org/10.1145/3428446},
	doi = {10.1145/3428446},
	abstract = {We develop fast and accurate algorithms for evaluating √x2+y2 for two floating-point numbers x and y. Library functions that perform this computation are generally named hypot(x,y). We compare five approaches that we will develop in this article to the current resident library function that is delivered with Julia 1.1 and to the code that has been distributed with the C math library for decades. We will investigate the accuracy of our algorithms by simulation.},
	number = {1},
	urldate = {2022-08-07},
	journal = {ACM Transactions on Mathematical Software},
	author = {Borges, Carlos F.},
	month = dec,
	year = {2020},
	note = {Number: 1},
	keywords = {partly\_read},
	pages = {9:1--9:12},
}

@article{muller_formalization_2022,
	title = {Formalization of {Double}-{Word} {Arithmetic}, and {Comments} on “{Tight} and {Rigorous} {Error} {Bounds} for {Basic} {Building} {Blocks} of {Double}-{Word} {Arithmetic}”},
	volume = {48},
	issn = {0098-3500},
	url = {http://doi.org/10.1145/3484514},
	doi = {10.1145/3484514},
	abstract = {Recently, a complete set of algorithms for manipulating double-word numbers (some classical, some new) was analyzed [16]. We have formally proven all the theorems given in that article, using the Coq proof assistant. The formal proof work led us to: (i) locate mistakes in some of the original paper proofs (mistakes that, however, do not hinder the validity of the algorithms), (ii) significantly improve some error bounds, and (iii) generalize some results by showing that they are still valid if we slightly change the rounding mode. The consequence is that the algorithms presented in [16] can be used with high confidence, and that some of them are even more accurate than what was believed before. This illustrates what formal proof can bring to computer arithmetic: beyond mere (yet extremely useful) verification, correction, and consolidation of already known results, it can help to find new properties. All our formal proofs are freely available.},
	number = {1},
	urldate = {2022-08-07},
	journal = {ACM Transactions on Mathematical Software},
	author = {Muller, Jean-Michel and Rideau, Laurence},
	month = feb,
	year = {2022},
	note = {Number: 1},
	keywords = {Coq, partly\_read},
	pages = {9:1--9:24},
}

@article{drmac_algorithm_2022,
	title = {An {Algorithm} for the {Complete} {Solution} of the {Quartic} {Eigenvalue} {Problem}},
	volume = {48},
	issn = {0098-3500},
	url = {http://doi.org/10.1145/3494528},
	doi = {10.1145/3494528},
	abstract = {The quartic eigenvalue problem (λ4A+λ3B+λ2C+λD+E)x = 0 naturally arises in a plethora of applications, such as when solving the Orr–Sommerfeld equation in the stability analysis of the Poiseuille flow, in theoretical analysis and experimental design of locally resonant phononic plates, modeling a robot with electric motors in the joints, calibration of catadioptric vision system, or, for example, computation of the guided and leaky modes of a planar waveguide. This article proposes a new numerical method for the full solution (all eigenvalues and all left and right eigenvectors) that, starting with a suitable linearization, uses an initial, structure-preserving reduction designed to reveal and deflate a certain number of zero and infinite eigenvalues before the final linearization is forwarded to the QZ algorithm. The backward error in the reduction phase is bounded column wise in each coefficient matrix, which is advantageous if the coefficient matrices are graded. Numerical examples show that the proposed algorithm is capable of computing the eigenpairs with small residuals, and that it is competitive with the available state-of-the-art methods.},
	number = {1},
	urldate = {2022-08-07},
	journal = {ACM Transactions on Mathematical Software},
	author = {Drmač, Zlatko and Glibić, Ivana Šain},
	month = feb,
	year = {2022},
	note = {Number: 1},
	keywords = {partly\_read},
	pages = {4:1--4:34},
}

@article{beringer_abstraction_2021,
	title = {Abstraction and subsumption in modular verification of {C} programs},
	volume = {58},
	issn = {1572-8102},
	url = {https://doi.org/10.1007/s10703-020-00353-1},
	doi = {10.1007/s10703-020-00353-1},
	abstract = {The type-theoretic notions of existential abstraction, subtyping, subsumption, and intersection have useful analogues in separation-logic proofs of imperative programs. We have implemented these as an enhancement of the verified software toolchain (VST). VST is an impredicative concurrent separation logic for the C language, implemented in the Coq proof assistant, and proved sound in Coq. For machine-checked functional-correctness verification of software at scale, VST embeds its expressive program logic in dependently typed higher-order logic (CiC). Specifications and proofs in the program logic can leverage the expressiveness of CiC—so users can overcome the abstraction gaps that stand in the way of top-to-bottom verification: gaps between source code verification, compilation, and domain-specific reasoning, and between different analysis techniques or formalisms. Until now, VST has supported the specification of a program as a flat collection of function specifications (in higher-order separation logic)—one proves that each function correctly implements its specification, assuming the specifications of the functions it calls. But what if a function has more than one specification? In this work, we exploit type-theoretic concepts to structure specification interfaces for C code. This brings modularity principles of modern software engineering to concrete program verification. Previous work used representation predicates to enable data abstraction in separation logic. We go further, introducing function-specification subsumption and intersection specifications to organize the multiple specifications that a function is typically associated with. As in type theory, if \$\${\textbackslash}phi \$\$is a of \$\${\textbackslash}psi \$\$, that is \$\${\textbackslash}phi {\textless}:{\textbackslash}psi \$\$, then \$\$x:{\textbackslash}phi \$\$implies \$\$x:{\textbackslash}psi \$\$, meaning that any function satisfying specification \$\${\textbackslash}phi \$\$can be used wherever a function satisfying \$\${\textbackslash}psi \$\$is demanded. Subsumption incorporates separation-logic framing and parameter adaptation, as well as step-indexing and specifications constructed via mixed-variance functors (needed for C’s function pointers).},
	language = {en},
	number = {1},
	urldate = {2022-08-07},
	journal = {Formal Methods in System Design},
	author = {Beringer, Lennart and Appel, Andrew W.},
	month = oct,
	year = {2021},
	note = {Number: 1},
	pages = {322--345},
}

@article{mccoid_provably_2022,
	title = {A {Provably} {Robust} {Algorithm} for {Triangle}-triangle {Intersections} in {Floating}-point {Arithmetic}},
	volume = {48},
	issn = {0098-3500},
	url = {http://doi.org/10.1145/3513264},
	doi = {10.1145/3513264},
	abstract = {Motivated by the unexpected failure of the triangle intersection component of the Projection Algorithm for Nonmatching Grids (PANG), this article provides a robust version with proof of backward stability. The new triangle intersection algorithm ensures consistency and parsimony across three types of calculations. The set of intersections produced by the algorithm, called representations, is shown to match the set of geometric intersections, called models. The article concludes with a comparison between the old and new intersection algorithms for PANG using an example found to reliably generate failures in the former.},
	number = {2},
	urldate = {2022-08-07},
	journal = {ACM Transactions on Mathematical Software},
	author = {Mccoid, Conor and Gander, Martin J.},
	month = may,
	year = {2022},
	note = {Number: 2},
	pages = {17:1--17:30},
}

@article{romero_homotopy_2013,
	title = {Homotopy groups of suspended classifying spaces: {An} experimental approach},
	volume = {82},
	issn = {0025-5718, 1088-6842},
	shorttitle = {Homotopy groups of suspended classifying spaces},
	url = {http://www.ams.org/mcom/2013-82-284/S0025-5718-2013-02680-4/},
	doi = {10.1090/S0025-5718-2013-02680-4},
	abstract = {When the results of a computer program are compared to some theorems proved on a theoretical basis three situations can occur: there can be an agreement between both approaches, the computer program can obtain calculations not covered by the theorems, or a discrepancy can be found between both methods. In this paper we report on a work where the three above mentioned situations happen. We have enhanced the Computer Algebra called Kenzo to deal with the computation of homotopy groups of suspended classifying spaces, a problem tackled by Mikhailov and Wu in a paper published in the journal Algebraic and Geometric Topology. Our experimental approach, based on completely different methods from those by Mikhailov and Wu, has allowed us in particular to detect an error in one of their published theorems.},
	language = {en},
	number = {284},
	urldate = {2022-08-07},
	journal = {Mathematics of Computation},
	author = {Romero, Ana and Rubio, Julio},
	month = oct,
	year = {2013},
	note = {Number: 284},
	pages = {2237--2244},
}

@article{verma_debug-localize-repair_2021,
	title = {Debug-localize-repair: a symbiotic construction for heap manipulations},
	volume = {58},
	issn = {1572-8102},
	shorttitle = {Debug-localize-repair},
	url = {https://doi.org/10.1007/s10703-021-00387-z},
	doi = {10.1007/s10703-021-00387-z},
	abstract = {We present Wolverine2, an integrated Debug-Localize-Repair environment for heap manipulating programs. Wolverine2 provides an interactive debugging environment: while concretely executing a program via on an interactive shell supporting common debugging facilities, Wolverine2 displays the abstract program states (as box-and-arrow diagrams) as a visual aid to the programmer, packages a novel, proof-directed repair algorithm to quickly synthesize the repair patches and a new bug localization algorithm to reduce the search space of repairs. Wolverine2 supports “hot-patching” of the generated patches to provide a seamless debugging environment, and also facilitates new debug-localize-repair possibilities: specification refinement and checkpoint-based hopping. We evaluate Wolverine2 on 6400 buggy programs (generated using automated fault injection) on a variety of data-structures like singly, doubly, and circular linked lists, AVL trees, Red-Black trees, Splay Trees and Binary Search Trees; Wolverine2 could repair all the buggy instances within realistic programmer wait-time (less than 5 s in most cases). Wolverine2 could also repair more than 80\% of the 247 (buggy) student submissions where a reasonable attempt was made.},
	language = {en},
	number = {3},
	urldate = {2022-08-07},
	journal = {Formal Methods in System Design},
	author = {Verma, Sahil and Roy, Subhajit},
	month = nov,
	year = {2021},
	note = {Number: 3},
	pages = {399--439},
}

@article{duran_misfortunes_2014,
	title = {The {Misfortunes} of a {Trio} of {Mathematicians} {Using} {Computer} {Algebra} {Systems}. {Can} {We} {Trust} in {Them}?},
	volume = {61},
	issn = {0002-9920, 1088-9477},
	url = {http://www.ams.org/notices/201410/rnoti-p1249.pdf},
	doi = {10.1090/noti1173},
	language = {en},
	number = {10},
	urldate = {2022-08-07},
	journal = {Notices of the American Mathematical Society},
	author = {Durán, Antonio J. and Pérez, Mario and Varona, Juan L.},
	month = nov,
	year = {2014},
	note = {Number: 10},
	keywords = {read},
	pages = {1249},
}

@article{lamban_verifying_2014,
	title = {Verifying the bridge between simplicial topology and algebra: the {Eilenberg}–{Zilber} algorithm},
	volume = {22},
	issn = {1367-0751},
	shorttitle = {Verifying the bridge between simplicial topology and algebra},
	url = {https://doi.org/10.1093/jigpal/jzt034},
	doi = {10.1093/jigpal/jzt034},
	abstract = {The Eilenberg–Zilber algorithm is one of the central components of the computer algebra system called Kenzo, devoted to computing in Algebraic Topology. In this article we report on a complete formal proof of the underlying Eilenberg–Zilber theorem, using the ACL2 theorem prover. As our formalization is executable, we are able to compare the results of the certified programme with those of Kenzo on some universal examples. Since the results coincide, the reliability of Kenzo is reinforced. This is a new step in our long-term project towards certified programming for Algebraic Topology.},
	number = {1},
	urldate = {2022-08-07},
	journal = {Logic Journal of the IGPL},
	author = {Lambán, L. and Rubio, J. and Martín-Mateos, F. J. and Ruiz-Reina, J. L.},
	month = feb,
	year = {2014},
	note = {Number: 1},
	pages = {39--65},
}

@article{kaufmann_practical_2022,
	title = {Practical algebraic calculus and {Nullstellensatz} with the checkers {Pacheck} and {Pastèque} and {Nuss}-{Checker}},
	issn = {1572-8102},
	url = {https://doi.org/10.1007/s10703-022-00391-x},
	doi = {10.1007/s10703-022-00391-x},
	abstract = {Automated reasoning techniques based on computer algebra have seen renewed interest in recent years and are for example heavily used in formal verification of arithmetic circuits. However, the verification process might contain errors. Generating and checking proof certificates is important to increase the trust in automated reasoning tools. For algebraic reasoning, two proof systems, Nullstellensatz and polynomial calculus, are available and are well-known in proof complexity. A Nullstellensatz proof captures whether a polynomial can be represented as a linear combination of a given set of polynomials by providing the co-factors of the linear combination. Proofs in polynomial calculus dynamically capture that a polynomial can be derived from a given set of polynomials using algebraic ideal theory. In this article we present the practical algebraic calculus as an instantiation of the polynomial calculus that can be checked efficiently. We further modify the practical algebraic calculus and gain LPAC (practical algebraic calculus + linear combinations) that includes linear combinations. In this way we are not only able to represent both Nullstellensatz and polynomial calculus proofs, but we are also able to blend both proof formats. Furthermore, we introduce extension rules to simulate essential rewriting techniques required in practice. For efficiency we also make use of indices for existing polynomials and include deletion rules too. We demonstrate the different proof formats on the use case of arithmetic circuit verification and discuss how these proofs can be produced as a by-product in formal verification. We present the proof checkers Pacheck, Pastèque, and Nuss-Checker. Pacheck checks proofs in practical algebraic calculus more efficiently than Pastèque, but the latter is formally verified using the proof assistant Isabelle/HOL. The tool Nuss-Checker is used to check proofs in the Nullstellensatz format.},
	language = {en},
	urldate = {2022-08-07},
	journal = {Formal Methods in System Design},
	author = {Kaufmann, Daniela and Fleury, Mathias and Biere, Armin and Kauers, Manuel},
	month = apr,
	year = {2022},
}

@inproceedings{monat_static_2020,
	address = {Dagstuhl, Germany},
	series = {Leibniz {International} {Proceedings} in {Informatics} ({LIPIcs})},
	title = {Static {Type} {Analysis} by {Abstract} {Interpretation} of {Python} {Programs}},
	volume = {166},
	isbn = {978-3-95977-154-2},
	url = {https://drops.dagstuhl.de/opus/volltexte/2020/13174},
	doi = {10.4230/LIPIcs.ECOOP.2020.17},
	urldate = {2022-08-07},
	booktitle = {34th {European} {Conference} on {Object}-{Oriented} {Programming} ({ECOOP} 2020)},
	publisher = {Schloss Dagstuhl–Leibniz-Zentrum für Informatik},
	author = {Monat, Raphaël and Ouadjaout, Abdelraouf and Miné, Antoine},
	editor = {Hirschfeld, Robert and Pape, Tobias},
	year = {2020},
	note = {ISSN: 1868-8969},
	pages = {17:1--17:29},
}

@inproceedings{monat_multilanguage_2021,
	address = {Cham},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {A {Multilanguage} {Static} {Analysis} of {Python} {Programs} with {Native} {C} {Extensions}},
	isbn = {978-3-030-88806-0},
	doi = {10.1007/978-3-030-88806-0_16},
	abstract = {Modern programs are increasingly multilanguage, to benefit from each programming language’s advantages and to reuse libraries. For example, developers may want to combine high-level Python code with low-level, performance-oriented C code. In fact, one in five of the 200 most downloaded Python libraries available on GitHub contains C code. Static analyzers tend to focus on a single language and may use stubs to model the behavior of foreign function calls. However, stubs are costly to implement and undermine the soundness of analyzers. In this work, we design a static analyzer by abstract interpretation that can handle Python programs calling C extensions. It analyses directly and fully automatically both the Python and the C source codes. It reports runtime errors that may happen in Python, in C, and at the interface. We implemented our analysis in a modular fashion: it reuses off-the-shelf C and Python analyses written in the same analyzer. This approach allows sharing between abstract domains of different languages. Our analyzer can tackle tests of real-world libraries a few thousand lines of C and Python long in a few minutes.},
	language = {en},
	booktitle = {Static {Analysis}},
	publisher = {Springer International Publishing},
	author = {Monat, Raphaël and Ouadjaout, Abdelraouf and Miné, Antoine},
	editor = {Drăgoi, Cezara and Mukherjee, Suvam and Namjoshi, Kedar},
	year = {2021},
	keywords = {MOPSA, partly\_read},
	pages = {323--345},
}

@article{journault_inferring_2018,
	title = {Inferring functional properties of matrix manipulating programs by abstract interpretation},
	volume = {53},
	issn = {1572-8102},
	url = {https://doi.org/10.1007/s10703-017-0311-x},
	doi = {10.1007/s10703-017-0311-x},
	abstract = {We present a new static analysis by abstract interpretation to prove automatically the functional correctness of algorithms implementing matrix operations, such as matrix addition, multiplication, general matrix multiplication, inversion, or more generally Basic Linear Algebra Subprograms. In order to do so, we introduce a family of abstract domains parameterized by a set of matrix predicates as well as a numerical domain. We show that our analysis is robust enough to prove the functional correctness of several versions of the same matrix operations, resulting from loop reordering, loop tiling, inverting the iteration order, line swapping, and expression decomposition. We extend our method to enable modular analysis on code fragments manipulating matrices by reference, and show that it results in a significant analysis speedup.},
	language = {en},
	number = {2},
	urldate = {2022-08-07},
	journal = {Formal Methods in System Design},
	author = {Journault, Matthieu and Miné, Antoine},
	month = oct,
	year = {2018},
	note = {Number: 2},
	keywords = {custom analyser, partly\_read},
	pages = {221--258},
}

@inproceedings{boutin_using_1997,
	address = {Berlin, Heidelberg},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Using reflection to build efficient and certified decision procedures},
	isbn = {978-3-540-69530-1},
	doi = {10.1007/BFb0014565},
	abstract = {In this paper we explain how computational reflection can help build efficient certified decision procedure in reduction systems. We have developed a decision procedure on abelian rings in the Coq system but the approach we describe applies to all reduction systems that allow the definition of concrete types (or datatypes). We show that computational reflection is more efficient than an LCF-like approach to implement decision procedures in a reduction system. We discuss the concept of total reflection, which we have investigated in Coq using two facts: the extraction process available in Coq and the fact that the implementation language of the Coq system can be considered as a sublanguage of Coq. Total reflection is not yet implemented in Coq but we can test its performance as the extraction process is effective. Both reflection and total reflection are conservative extensions of the reduction system in which they are used. We also discuss performance and related approaches. In the paper,we assume basic knowledges of ML and proof-checkers.},
	language = {en},
	booktitle = {Theoretical {Aspects} of {Computer} {Software}},
	publisher = {Springer},
	author = {Boutin, Samuel},
	editor = {Abadi, Martín and Ito, Takayasu},
	year = {1997},
	pages = {515--529},
}

@article{foster_unifying_2020,
	title = {Unifying theories of reactive design contracts},
	volume = {802},
	issn = {0304-3975},
	url = {https://www.sciencedirect.com/science/article/pii/S0304397519305614},
	doi = {10.1016/j.tcs.2019.09.017},
	abstract = {Design-by-contract is an important technique for model-based design in which a composite system is specified by a collection of contracts that specify the behavioural assumptions and guarantees of each component. In this paper, we describe a unifying theory for reactive design contracts that provides the basis for modelling and verification of reactive systems. We provide a language for expression and composition of contracts that is supported by a rich calculational theory. In contrast with other semantic models in the literature, our theory of contracts allows us to specify both the evolution of state variables and the permissible interactions with the environment. Moreover, our model of interaction is abstract, and supports, for instance, discrete time, continuous time, and hybrid computational models. Being based in Unifying Theories of Programming (UTP), our theory can be composed with further computational theories to support semantics for multi-paradigm languages. Practical reasoning support is provided via our proof framework, Isabelle/UTP, including a proof tactic that reduces a conjecture about a reactive program to three predicates, symbolically characterising its assumptions and guarantees about intermediate and final observations. This allows us to verify programs with a large or infinite state space. Our work advances the state-of-the-art in semantics for reactive languages, description of their contractual specifications, and compositional verification.},
	language = {en},
	urldate = {2022-08-07},
	journal = {Theoretical Computer Science},
	author = {Foster, Simon and Cavalcanti, Ana and Canham, Samuel and Woodcock, Jim and Zeyda, Frank},
	month = jan,
	year = {2020},
	keywords = {Isabelle, partly\_read},
	pages = {105--140},
}

@inproceedings{foster_automating_2018,
	address = {Cham},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Automating {Verification} of {State} {Machines} with {Reactive} {Designs} and {Isabelle}/{UTP}},
	isbn = {978-3-030-02146-7},
	doi = {10.1007/978-3-030-02146-7_7},
	abstract = {State-machine based notations are ubiquitous in the description of component systems, particularly in the robotic domain. To ensure these systems are safe and predictable, formal verification techniques are important, and can be cost-effective if they are both automated and scalable. In this paper, we present a verification approach for a diagrammatic state machine language that utilises theorem proving and a denotational semantics based on Unifying Theories of Programming (UTP). We provide the necessary theory to underpin state machines (including induction theorems for iterative processes), mechanise an action language for states and transitions, and use these to formalise the semantics. We then describe the verification approach, which supports infinite state systems, and exemplify it with a fully automated deadlock-freedom check. The work has been mechanised in our proof tool, Isabelle/UTP, and so also illustrates the use of UTP to build practical verification tools.},
	language = {en},
	booktitle = {Formal {Aspects} of {Component} {Software}},
	publisher = {Springer International Publishing},
	author = {Foster, Simon and Baxter, James and Cavalcanti, Ana and Miyazawa, Alvaro and Woodcock, Jim},
	editor = {Bae, Kyungmin and Ölveczky, Peter Csaba},
	year = {2018},
	keywords = {Isabelle, partly\_read},
	pages = {137--155},
}

@inproceedings{daumas_generic_2001,
	address = {Berlin, Heidelberg},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {A {Generic} {Library} for {Floating}-{Point} {Numbers} and {Its} {Application} to {Exact} {Computing}},
	isbn = {978-3-540-44755-9},
	doi = {10.1007/3-540-44755-5_13},
	abstract = {In this paper we present a general library to reason about floating-point numbers within the Coq system. Most of the results of the library are proved for an arbitrary floating-point format and an arbitrary base. A special emphasis has been put on proving properties for exact computing, i.e. computing without rounding errors.},
	language = {en},
	booktitle = {Theorem {Proving} in {Higher} {Order} {Logics}},
	publisher = {Springer},
	author = {Daumas, Marc and Rideau, Laurence and Théry, Laurent},
	editor = {Boulton, Richard J. and Jackson, Paul B.},
	year = {2001},
	pages = {169--184},
}

@article{lester_using_2003,
	series = {Real {Numbers} and {Computers}},
	title = {Using {PVS} to validate the algorithms of an exact arithmetic},
	volume = {291},
	issn = {0304-3975},
	url = {https://www.sciencedirect.com/science/article/pii/S0304397502002268},
	doi = {10.1016/S0304-3975(02)00226-8},
	abstract = {The whole point of exact arithmetic is to generate answers to numeric problems, within some user-specified error. An implementation of exact arithmetic is therefore of questionable value, if it cannot be shown that it is generating correct answers. In this paper, we show that the algorithms used in an exact real arithmetic are correct. A program using the functions defined in this paper has been implemented in ‘C’ (a HASKELL version of which we provide as an appendix), and we are now convinced of its correctness. The table presented at the end of the paper shows that performing these proofs found three logical errors which had not been discovered by testing. One of these errors was only detected when the theorems were validated with PVS.},
	language = {en},
	number = {2},
	urldate = {2022-08-06},
	journal = {Theoretical Computer Science},
	author = {Lester, David and Gowland, Paul},
	month = jan,
	year = {2003},
	note = {Number: 2},
	keywords = {PVS, partly\_read},
	pages = {203--218},
}

@inproceedings{goubault_future_2006,
	address = {Toulouse, France},
	title = {Some future challenges in the validation of control systems},
	url = {https://hal.archives-ouvertes.fr/hal-02270346},
	abstract = {Starting with our work on the characterization of the imprecision error in programs using floating-point-numbers, by abstract interpretation, this paper shows that there are numerous perspectives, if one wants to fully qualify the numerical quality of control systems, as found in the aeronautical and automotive industry, for instance. Some very common functions (e.g. integrators) are hard to statically analyse, because their numerical correctness depend on a fine-grained specification of the classes of input signals they handle. This gets even more complex in the case of e.g. PID controllers, which interact in closed loop with an external environment, since their input signals are in part the consequence of their own computation, similarly for the imprecision errors. We show examples of non-trivial bad and good numerical behaviours, discuss the results of our methods, and present our current research directions, that should hopefully help characterize the imprecision error of such control systems.},
	urldate = {2022-08-06},
	booktitle = {Conference {ERTS}'06},
	author = {Goubault, E. and Martel, M. and Putot, S.},
	month = jan,
	year = {2006},
}

@inproceedings{fromherz_static_2018,
	address = {Cham},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Static {Value} {Analysis} of {Python} {Programs} by {Abstract} {Interpretation}},
	isbn = {978-3-319-77935-5},
	doi = {10.1007/978-3-319-77935-5_14},
	abstract = {We propose a static analysis by abstract interpretation for a significant subset of Python to infer variable values, run-time errors, and uncaught exceptions. Python is a high-level language with dynamic typing, a class-based object system, complex control structures such as generators, and a large library of builtin objects. This makes static reasoning on Python programs challenging. The control flow is highly dependent on the type of values, which we thus infer accurately.},
	language = {en},
	booktitle = {{NASA} {Formal} {Methods}},
	publisher = {Springer International Publishing},
	author = {Fromherz, Aymeric and Ouadjaout, Abdelraouf and Miné, Antoine},
	editor = {Dutle, Aaron and Muñoz, César and Narkawicz, Anthony},
	year = {2018},
	keywords = {custom analyser, partly\_read},
	pages = {185--202},
}

@inproceedings{aichernig_learning-based_2019,
	address = {Cham},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Learning-{Based} {Testing} of an {Industrial} {Measurement} {Device}},
	isbn = {978-3-030-20652-9},
	doi = {10.1007/978-3-030-20652-9_1},
	abstract = {Active automata learning algorithms have gained increasing importance in the field of model-based system verification. For some classes of systems - especially deterministic systems, like Mealy machines, a variety of learning algorithm implementations is readily available. In this paper, we apply this technique to a measurement device from the automotive industry in order to systematically test its behaviour. However, our system under learning shows sparse non-deterministic behaviour, preventing the direct application of the available learning tools.},
	language = {en},
	booktitle = {{NASA} {Formal} {Methods}},
	publisher = {Springer International Publishing},
	author = {Aichernig, Bernhard K. and Burghard, Christian and Korošec, Robert},
	editor = {Badger, Julia M. and Rozier, Kristin Yvonne},
	year = {2019},
	pages = {1--18},
}

@inproceedings{salvia_mixed_2019,
	address = {Cham},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {A {Mixed} {Real} and {Floating}-{Point} {Solver}},
	isbn = {978-3-030-20652-9},
	doi = {10.1007/978-3-030-20652-9_25},
	abstract = {Reasoning about mixed real and floating-point constraints is essential for developing accurate analysis tools for floating-point programs. This paper presents FPRoCK, a prototype tool for solving mixed real and floating-point formulas. FPRoCK transforms a mixed formula into an equisatisfiable one over the reals. This formula is then solved using an off-the-shelf SMT solver. FPRoCK is also integrated with the PRECiSA static analyzer, which computes a sound estimation of the round-off error of a floating-point program. It is used to detect infeasible computational paths, thereby improving the accuracy of PRECiSA.},
	language = {en},
	booktitle = {{NASA} {Formal} {Methods}},
	publisher = {Springer International Publishing},
	author = {Salvia, Rocco and Titolo, Laura and Feliú, Marco A. and Moscato, Mariano M. and Muñoz, César A. and Rakamarić, Zvonimir},
	editor = {Badger, Julia M. and Rozier, Kristin Yvonne},
	year = {2019},
	pages = {363--370},
}

@inproceedings{schoolderman_efficient_2021,
	address = {Cham},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Efficient {Verification} of {Optimized} {Code}},
	isbn = {978-3-030-76384-8},
	doi = {10.1007/978-3-030-76384-8_19},
	abstract = {Code that is highly optimized poses a problem for program-level verification: programmers can employ various clever tricks that are non-trivial to reason about. For cryptography on low-power devices, it is nonetheless crucial that implementations be functionally correct, secure, and efficient. These are usually crafted in hand-optimized machine code that eschew conventional control flow as much as possible.},
	language = {en},
	booktitle = {{NASA} {Formal} {Methods}},
	publisher = {Springer International Publishing},
	author = {Schoolderman, Marc and Moerman, Jonathan and Smetsers, Sjaak and van Eekelen, Marko},
	editor = {Dutle, Aaron and Moscato, Mariano M. and Titolo, Laura and Muñoz, César A. and Perez, Ivan},
	year = {2021},
	pages = {304--321},
}

@inproceedings{hertz_integrating_2021,
	address = {Cham},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Integrating {Runtime} {Verification} into a {Sounding} {Rocket} {Control} {System}},
	isbn = {978-3-030-76384-8},
	doi = {10.1007/978-3-030-76384-8_10},
	abstract = {An actuation fault in the aerobraking control system (ACS) took down Iowa State’s Nova Somnium rocket during the 2019 Spaceport America Cup competition, prematurely ending the team’s participation. The ACS engaged incorrectly before motor burnout, altering the rocket’s trajectory and leading to a dangerous crash. The ability to detect this fault in real time on-board the ACS’s Arduino microcontroller would have prevented an uncontrolled landing and rapid unscheduled disassembly, which posed a major safety threat and ended a year’s worth of effort by the 50-student team. Runtime verification (RV) specializes in efficiently catching this type of scenario; the R2U2 RV engine uniquely fits in the project’s resource constraints. We design specifications to detect ACS faults and trigger the appropriate mitigations. We discuss specification development, validation, coverage, and robustness against false positives. Experimental evaluation on the real, recorded flight data demonstrates that running R2U2 on the Nova Somnium ACS would have prevented this accident from occurring. We generalize our results and outline our plans for integrating runtime verification into future sounding rockets.},
	language = {en},
	booktitle = {{NASA} {Formal} {Methods}},
	publisher = {Springer International Publishing},
	author = {Hertz, Benjamin and Luppen, Zachary and Rozier, Kristin Yvonne},
	editor = {Dutle, Aaron and Moscato, Mariano M. and Titolo, Laura and Muñoz, César A. and Perez, Ivan},
	year = {2021},
	pages = {151--159},
}

@inproceedings{dimovski_program_2021,
	address = {Cham},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Program {Sketching} {Using} {Lifted} {Analysis} for {Numerical} {Program} {Families}},
	isbn = {978-3-030-76384-8},
	doi = {10.1007/978-3-030-76384-8_7},
	abstract = {This work presents a novel approach for synthesizing numerical program sketches using lifted (family-based) static program analysis. In particular, our approach leverages a lifted static analysis based on abstract interpretation, which is used for analyzing program families with numerical features. It takes as input the common code base, which encodes all variants of a program family, and produces precise results for all variants in a single analysis run. The elements of the underlying lifted analysis domain are decision trees, in which decision nodes are labeled with linear constraints defined over numerical features and leaf nodes belong to a given single-program analysis domain.},
	language = {en},
	booktitle = {{NASA} {Formal} {Methods}},
	publisher = {Springer International Publishing},
	author = {Dimovski, Aleksandar S. and Apel, Sven and Legay, Axel},
	editor = {Dutle, Aaron and Moscato, Mariano M. and Titolo, Laura and Muñoz, César A. and Perez, Ivan},
	year = {2021},
	pages = {95--112},
}

@inproceedings{noble_more_2022,
	address = {Cham},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {More {Programming} {Than} {Programming}: {Teaching} {Formal} {Methods} in a {Software} {Engineering} {Programme}},
	isbn = {978-3-031-06773-0},
	shorttitle = {More {Programming} {Than} {Programming}},
	doi = {10.1007/978-3-031-06773-0_23},
	abstract = {Formal methods for software correctness are critical to the future of software engineering—and so must be an essential part of software engineering education. Unfortunately, formal methods are often resisted by students due to perceived difficulty, mathematicity, and practical irrelevance. We redeveloped our software correctness course by taking a programming intensive approach, using the solver-aided language Dafny to provide instant formative feedback via automated assessment. Our redeveloped course increased student retention and resulted in the best evaluation for the course for at least ten years.},
	language = {en},
	booktitle = {{NASA} {Formal} {Methods}},
	publisher = {Springer International Publishing},
	author = {Noble, James and Streader, David and Gariano, Isaac Oscar and Samarakoon, Miniruwani},
	editor = {Deshmukh, Jyotirmoy V. and Havelund, Klaus and Perez, Ivan},
	year = {2022},
	pages = {431--450},
}

@inproceedings{su_insulin_2018,
	address = {Cham},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Insulin {Pump}: {Modular} {Modeling} of {Hybrid} {Systems} {Using} {Event}-{B}},
	isbn = {978-3-319-91271-4},
	shorttitle = {Insulin {Pump}},
	doi = {10.1007/978-3-319-91271-4_31},
	abstract = {This case study of an insulin pump is to describe our solution of the following difficulties. Firstly, how to model features to obtain a family of products. Secondly, how to handle complex constraints and synchronization of components when composing features. Thirdly, how to construct the continuous environment for the individual features as well as for the composed system.},
	language = {en},
	booktitle = {Abstract {State} {Machines}, {Alloy}, {B}, {TLA}, {VDM}, and {Z}},
	publisher = {Springer International Publishing},
	author = {Su, Wen and Chen, Jinxin and Khan, Shehroz},
	editor = {Butler, Michael and Raschke, Alexander and Hoang, Thai Son and Reichl, Klaus},
	year = {2018},
	pages = {403--408},
}

@inproceedings{ishii_approximate_2022,
	address = {Cham},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Approximate {Translation} from {Floating}-{Point} to {Real}-{Interval} {Arithmetic}},
	isbn = {978-3-031-06773-0},
	doi = {10.1007/978-3-031-06773-0_39},
	abstract = {Floating-point arithmetic (FPA) is a mechanical representation of real arithmetic (RA), where each operation is replaced with a rounded counterpart. Various numerical properties can be verified by using SMT solvers that support the logic of FPA. However, the scalability of the solving process remains limited when compared to RA. In this paper, we present a decision procedure for FPA that takes advantage of the efficiency of RA solving. The proposed method abstracts FP numbers as rational intervals and FPA expressions as interval arithmetic (IA) expressions; then, we solve IA formulas to check the satisfiability of an FPA formula using an off-the-shelf RA solver (we use CVC4 and Z3). In exchange for the efficiency gained by abstraction, the solving process becomes quasi-complete; we allow to output unknown when the satisfiability is affected by possible numerical errors. Furthermore, our IA is meticulously formalized to handle the special value NaN. We implemented the proposed method and compared it to four existing SMT solvers in the experiments. As a result, we confirmed that our solver was efficient for instances where rounding modes were parameterized.},
	language = {en},
	booktitle = {{NASA} {Formal} {Methods}},
	publisher = {Springer International Publishing},
	author = {Ishii, Daisuke and Tomita, Takashi and Aoki, Toshiaki},
	editor = {Deshmukh, Jyotirmoy V. and Havelund, Klaus and Perez, Ivan},
	year = {2022},
	pages = {733--751},
}

@inproceedings{villalba-moreno_reproducible_2019,
	title = {Reproducible {Summation} {Under} {HUB} {Format}},
	doi = {10.1109/ARITH.2019.00015},
	abstract = {Floating point reproducibility is a property claimed by programmers and end users. Half-Unit-Biased (HUB) is a new representation format in which the round to nearest is carried out by truncation, preventing any carry propagation and saving time and area. In this paper we study the reproducible summation of HUB numbers by using a error-free vector transformation technique, providing both a specific architecture and the usage of combined HUB/Standard floating point adders to achieve a reproducible result.},
	booktitle = {2019 {IEEE} 26th {Symposium} on {Computer} {Arithmetic} ({ARITH})},
	author = {Villalba-Moreno, Julio and Hormigo, Javier and Jaime, Francisco},
	month = jun,
	year = {2019},
	note = {ISSN: 2576-2265},
	pages = {38--45},
}

@inproceedings{boldo_formal_2021,
	title = {Some {Formal} {Tools} for {Computer} {Arithmetic}: {Flocq} and {Gappa}},
	shorttitle = {Some {Formal} {Tools} for {Computer} {Arithmetic}},
	doi = {10.1109/ARITH51176.2021.00031},
	abstract = {This invited paper presents two tools developed by the authors. Their purpose is to help the user in writing proofs regarding computer arithmetic, e.g., certifying a bound on a round-off error, while aiming at a high level of guarantee. Flocq is a library of mathematical definitions and theorems for the Coq proof assistant; Gappa is meant to compute bounds of values and errors, while producing the corresponding formal proof. We describe here these tools, how they interact and how they fit in a larger verification process.},
	booktitle = {2021 {IEEE} 28th {Symposium} on {Computer} {Arithmetic} ({ARITH})},
	author = {Boldo, Sylvie and Melquiond, Guillaume},
	month = jun,
	year = {2021},
	note = {ISSN: 2576-2265},
	keywords = {Coq, Gappa},
	pages = {111--114},
}

@inproceedings{revy_analyzing_2021,
	title = {Analyzing the impact of floating-point precision adaptation in iterative programs},
	doi = {10.1109/ARITH51176.2021.00016},
	abstract = {The amount of floating-point computations in numerical programs is ever increasing. In order to improve their performance, the current trend is to carefully adapt the precision of some floating-point operations, to take advantage of new features of modern architectures. Such adaptation process requires tools to evaluate the impact of these transformations on the accuracy of the output. This article presents an analysis tool to help developers in evaluating the impact of adapting the precision in floating-point programs, with a particular focus on iterative programs. This tool is implemented in the LLVM compilation framework, and it includes two main modules: fp2mp that instruments floating-point programs with multiple-precision computations, and a loop splitter that splits the iteration space of a loop into several subspaces. We illustrate the interest of this tool on various examples, and particularly how it enables to evaluate automatically the impact of adapting the precision of floating-point operations in loops by considering different precisions over the iteration space.},
	booktitle = {2021 {IEEE} 28th {Symposium} on {Computer} {Arithmetic} ({ARITH})},
	author = {Revy, Guillaume},
	month = jun,
	year = {2021},
	note = {ISSN: 2576-2265},
	pages = {25--32},
}

@inproceedings{gowland_survey_2001,
	address = {Berlin, Heidelberg},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {A {Survey} of {Exact} {Arithmetic} {Implementations}},
	isbn = {978-3-540-45335-2},
	doi = {10.1007/3-540-45335-0_3},
	abstract = {This paper provides a survey of practical systems for exact arithmetic. We describe some of the methods used in their implementation, and suggest reasons for the performance differences displayed by some of the competing systems at this years CCA Exact Arithmetic Competition.},
	language = {en},
	booktitle = {Computability and {Complexity} in {Analysis}},
	publisher = {Springer},
	author = {Gowland, Paul and Lester, David},
	editor = {Blanck, Jens and Brattka, Vasco and Hertling, Peter},
	year = {2001},
	keywords = {guides, partly\_read},
	pages = {30--47},
}

@inproceedings{beierle_abstract_2018,
	address = {Cham},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Abstract {State} {Machines} with {Exact} {Real} {Arithmetic}},
	isbn = {978-3-319-91271-4},
	doi = {10.1007/978-3-319-91271-4_10},
	abstract = {Type-2 Theory of Effectivity is a well established theory of computability on infinite strings, which in this paper is exploited to define a data type Real as part of the background structure of Abstract State Machines. Real numbers are represented by rapidly converging Cauchy sequences, on top of which standard operations such as addition, multiplication, division, exponentials, trigonometric functions, etc. can be defined. In this way exact computation with real numbers is enabled. Output can be generated at any degree of precision by exploring only sufficiently long prefixes of the representing Cauchy sequences.},
	language = {en},
	booktitle = {Abstract {State} {Machines}, {Alloy}, {B}, {TLA}, {VDM}, and {Z}},
	publisher = {Springer International Publishing},
	author = {Beierle, Christoph and Schewe, Klaus-Dieter},
	editor = {Butler, Michael and Raschke, Alexander and Hoang, Thai Son and Reichl, Klaus},
	year = {2018},
	pages = {139--154},
}

@inproceedings{hoang_hybrid_2018,
	address = {Cham},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {The {Hybrid} {ERTMS}/{ETCS} {Level} 3 {Case} {Study}},
	isbn = {978-3-319-91271-4},
	doi = {10.1007/978-3-319-91271-4_17},
	abstract = {This document presents a description of the European Rail Traffic Management System (ERTMS) case study. ERTMS is a system of standards for management and interoperation of signalling for railways by the European Union (EU). The case study focuses on the ERTMS Level 3 Hybrid principle, which accommodates different types of trains including ERTMS trains equiped with the Train Integrity Monitoring System (TIMS), ERTMS trains without TIMS, and non-ERTMS trains.},
	language = {en},
	booktitle = {Abstract {State} {Machines}, {Alloy}, {B}, {TLA}, {VDM}, and {Z}},
	publisher = {Springer International Publishing},
	author = {Hoang, Thai Son and Butler, Michael and Reichl, Klaus},
	editor = {Butler, Michael and Raschke, Alexander and Hoang, Thai Son and Reichl, Klaus},
	year = {2018},
	pages = {251--261},
}

@inproceedings{mashkoor_hemodialysis_2016,
	address = {Cham},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {The {Hemodialysis} {Machine} {Case} {Study}},
	isbn = {978-3-319-33600-8},
	doi = {10.1007/978-3-319-33600-8_29},
	abstract = {This documents presents a description of a case study concerning the control of a hemodialysis (HD) machine. It provides an overview of the requirements and the design of an HD machine including a sketch of the machine’s functionality, related safety conditions, and a top-level system architectural description.},
	language = {en},
	booktitle = {Abstract {State} {Machines}, {Alloy}, {B}, {TLA}, {VDM}, and {Z}},
	publisher = {Springer International Publishing},
	author = {Mashkoor, Atif},
	editor = {Butler, Michael and Schewe, Klaus-Dieter and Mashkoor, Atif and Biro, Miklos},
	year = {2016},
	pages = {329--343},
}

@inproceedings{boniol_landing_2014,
	address = {Cham},
	series = {Communications in {Computer} and {Information} {Science}},
	title = {The {Landing} {Gear} {System} {Case} {Study}},
	isbn = {978-3-319-07512-9},
	doi = {10.1007/978-3-319-07512-9_1},
	abstract = {This document presents a landing gear system. It describes the system and provides some of its requirements. We propose this case study as a benchmark for techniques and tools dedicated to the verification of behavioral properties of systems.},
	language = {en},
	booktitle = {{ABZ} 2014: {The} {Landing} {Gear} {Case} {Study}},
	publisher = {Springer International Publishing},
	author = {Boniol, Frédéric and Wiels, Virginie},
	editor = {Boniol, Frédéric and Wiels, Virginie and Ait Ameur, Yamine and Schewe, Klaus-Dieter},
	year = {2014},
	pages = {1--18},
}

@inproceedings{houdek_adaptive_2020,
	address = {Cham},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Adaptive {Exterior} {Light} and {Speed} {Control} {System}},
	isbn = {978-3-030-48077-6},
	doi = {10.1007/978-3-030-48077-6_24},
	abstract = {This case study continues the successful series of case studies for formal specification and verification of the ABZ conference series, which started with the landing gear system [1] and expanded with the hemodialysis medical device [4] and the European Train Control System (ETCS) [2] in the following years.},
	language = {en},
	booktitle = {Rigorous {State}-{Based} {Methods}},
	publisher = {Springer International Publishing},
	author = {Houdek, Frank and Raschke, Alexander},
	editor = {Raschke, Alexander and Méry, Dominique and Houdek, Frank},
	year = {2020},
	pages = {281--301},
}

@inproceedings{dyer_sterling_2021,
	address = {Cham},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Sterling: {A} {Web}-{Based} {Visualizer} for {Relational} {Modeling} {Languages}},
	isbn = {978-3-030-77543-8},
	shorttitle = {Sterling},
	doi = {10.1007/978-3-030-77543-8_7},
	abstract = {We introduce Sterling, a web-based visualization tool that provides interactive views of relational models and allows users to create custom visualizations using modern JavaScript libraries like D3 and Cytoscape. We outline its design goals and architecture, and describe custom visualizations developed with Sterling that enable verification studies of scientific software used in production. While development is driven primarily by the Alloy community, other relational modeling languages are accommodated by Sterling’s data agnostic architecture.},
	language = {en},
	booktitle = {Rigorous {State}-{Based} {Methods}},
	publisher = {Springer International Publishing},
	author = {Dyer, Tristan and Baugh, John},
	editor = {Raschke, Alexander and Méry, Dominique},
	year = {2021},
	pages = {99--104},
}

@inproceedings{cavalcanti_modelling_2020,
	address = {Cham},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Modelling and {Verification} of {Robotic} {Platforms} for {Simulation} {Using} {RoboStar} {Technology}},
	isbn = {978-3-030-48077-6},
	doi = {10.1007/978-3-030-48077-6_1},
	abstract = {The RoboStar framework supports model-based engineering of robotic applications.},
	language = {en},
	booktitle = {Rigorous {State}-{Based} {Methods}},
	publisher = {Springer International Publishing},
	author = {Cavalcanti, Ana},
	editor = {Raschke, Alexander and Méry, Dominique and Houdek, Frank},
	year = {2020},
	keywords = {Isabelle, read},
	pages = {3--5},
}

@inproceedings{bochot_model_2009,
	title = {Model checking flight control systems: {The} {Airbus} experience},
	shorttitle = {Model checking flight control systems},
	doi = {10.1109/ICSE-COMPANION.2009.5070960},
	abstract = {This paper presents experiments realized by Airbus on model checking a safety critical system, lessons learnt and ways forward to extend the industrial use of formal verification at design level.},
	booktitle = {2009 31st {International} {Conference} on {Software} {Engineering} - {Companion} {Volume}},
	author = {Bochot, Thomas and Virelizier, Pierre and Waeselynck, Helene and Wiels, Virginie},
	month = may,
	year = {2009},
	pages = {18--27},
}

@article{feron_control_2010,
	title = {From {Control} {Systems} to {Control} {Software}},
	volume = {30},
	issn = {1941-000X},
	doi = {10.1109/MCS.2010.938196},
	abstract = {This article describes an approach to documenting control programs, whereby the control program code is annotated with logical expressions describing the set of reachable program states. This approach constitutes the application of the Floyd-Hoare paradigm to control programs. It is shown that domain knowledge gathered by control theory about control-system specifications is applicable to developing stability and performance proofs of the corresponding control programs. The analyses discussed in this article can be used in various contexts. In particular, the analyses can be used in an autocoding environment, whereby diagram-based specifications in Simulink or other languages can be turned into formally annotated target codes with extensive proofs of stability and performance. These proofs are tightly woven in the codes, which can then be verified independently by a proof checker.},
	number = {6},
	journal = {IEEE Control Systems Magazine},
	author = {Feron, Eric},
	month = dec,
	year = {2010},
	note = {Number: 6
Conference Name: IEEE Control Systems Magazine},
	keywords = {partly\_read},
	pages = {50--71},
}

@inproceedings{meng_verified_2015,
	address = {Cham},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Verified {ROS}-{Based} {Deployment} of {Platform}-{Independent} {Control} {Systems}},
	isbn = {978-3-319-17524-9},
	doi = {10.1007/978-3-319-17524-9_18},
	abstract = {The paper considers the problem of model-based deployment of platform-independent control code on a specific platform. The approach is based on automatic generation of platform-specific glue code from an architectural model of the system. We present a tool, ROSGen, that generates the glue code based on a declarative specification of platform interfaces. Our implementation targets the popular Robot Operating System (ROS) platform. We demonstrate that the code generation process is amenable to formal verification. The code generator is implemented in Coq and relies on the infrastructure provided by the CompCert and VST tool. We prove that the generated code always correctly connects the controller function to sensors and actuators in the robot. We use ROSGen to implement a cruise control system on the LandShark robot.},
	language = {en},
	booktitle = {{NASA} {Formal} {Methods}},
	publisher = {Springer International Publishing},
	author = {Meng, Wenrui and Park, Junkil and Sokolsky, Oleg and Weirich, Stephanie and Lee, Insup},
	editor = {Havelund, Klaus and Holzmann, Gerard and Joshi, Rajeev},
	year = {2015},
	pages = {248--262},
}

@inproceedings{ricketts_towards_2015,
	title = {Towards verification of hybrid systems in a foundational proof assistant},
	doi = {10.1109/MEMCOD.2015.7340492},
	abstract = {Unsafe behavior of hybrid systems can have disastrous consequences, motivating the need for formal verification of the software running on these systems. Foundational verification in a proof assistant such as Coq is a promising technique that can provide extremely strong, foundational, guarantees about software systems. In this paper, we show how to apply this technique to hybrid systems. We define a TLA-inspired formalism in Coq for reasoning about hybrid systems and use it to verify two quadcopter modules: the first limits the quadcopter's velocity and the second limits its altitude. We ran both of these modules on an actual quadcopter, and they worked as intended. We also discuss lessons learned from our experience foundationally verifying hybrid systems.},
	booktitle = {2015 {ACM}/{IEEE} {International} {Conference} on {Formal} {Methods} and {Models} for {Codesign} ({MEMOCODE})},
	author = {Ricketts, Daniel and Malecha, Gregory and Alvarez, Mario M. and Gowda, Vignesh and Lerner, Sorin},
	month = sep,
	year = {2015},
	pages = {248--257},
}

@book{douglas_fundamentals_nodate,
	title = {The {Fundamentals} of {Control} {Theory}},
	author = {Douglas, Brian},
	keywords = {guides},
}

@misc{fabregat-traver_knowledge-based_2014,
	title = {Knowledge-{Based} {Automatic} {Generation} of {Linear} {Algebra} {Algorithms} and {Code}},
	url = {http://arxiv.org/abs/1404.3406},
	doi = {10.48550/arXiv.1404.3406},
	abstract = {This dissertation focuses on the design and the implementation of domain-specific compilers for linear algebra matrix equations. The development of efficient libraries for such equations, which lie at the heart of most software for scientific computing, is a complex process that requires expertise in a variety of areas, including the application domain, algorithms, numerical analysis and high-performance computing. Moreover, the process involves the collaboration of several people for a considerable amount of time. With our compilers, we aim to relieve the developers from both designing algorithms and writing code, and to generate routines that match or even surpass the performance of those written by human experts.},
	urldate = {2022-08-02},
	publisher = {arXiv},
	author = {Fabregat-Traver, Diego},
	month = apr,
	year = {2014},
	note = {Issue: arXiv:1404.3406
arXiv:1404.3406 [cs]},
}

@inproceedings{adams_clawz_2005,
	address = {Washington, DC, USA},
	title = {{CLAWZ}: {Cost}-{Effective} {Formal} {Verification} for {Control} {Systems}},
	volume = {2},
	isbn = {978-0-7803-9307-3},
	shorttitle = {{CLAWZ}},
	url = {http://ieeexplore.ieee.org/document/1563404/},
	doi = {10.1109/DASC.2005.1563404},
	abstract = {Control system software now plays a key role on many platforms, including aircraft and automobiles. However, as control system software has been performing increasingly complex tasks, the associated software development, maintenance and certification costs have escalated significantly. The CLawZ toolset is dedicated to the formal verification of control system software. By using some novel ideas, it achieves the highest levels of assurance whilst not suffering from the prohibitively high costs normally associated with applying formal verification. This toolset has been successfully used in the certification of a large scale, highly complex, flight safety critical system. This paper outlines the toolset, and explains how the approach used to build it enables costs to be dramatically reduced whilst not compromising on soundness.},
	urldate = {2022-04-09},
	booktitle = {24th {Digital} {Avionics} {Systems} {Conference}},
	publisher = {IEEE},
	author = {Adams, M.M. and Clayton, P.B. and Tudor, N.J.},
	year = {2005},
	pages = {10.D.6--1--10.D.6--10},
}

@inproceedings{hasan_formal_2013,
	address = {Grenoble, France},
	title = {Formal {Analysis} of {Steady} {State} {Errors} in {Feedback} {Control} {Systems} {Using} {HOL}-{Light}},
	isbn = {978-1-4673-5071-6},
	url = {http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=6513736},
	doi = {10.7873/DATE.2013.290},
	language = {en},
	urldate = {2022-04-09},
	booktitle = {Design, {Automation} \& {Test} in {Europe} {Conference} \& {Exhibition} ({DATE}), 2013},
	publisher = {IEEE Conference Publications},
	author = {Hasan, Osman and Ahmad, Muhammad},
	year = {2013},
	pages = {1423--1426},
}

@article{staroletov_designing_2019,
	title = {Designing robust quadcopter software based on a real-time partitioned operating system and formal verification techniques},
	volume = {31},
	issn = {20798156, 22206426},
	url = {https://www.ispras.ru/en/proceedings/isp_31_2019_4/isp_31_2019_4_39/},
	doi = {10.15514/ISPRAS-2019-31(4)-3},
	abstract = {The creation of reliable unmanned aerial vehicles (drones) now is an important task in the science and technology, because such devices can have a lot of use-cases in the digital economy and modern life, so we need to ensure the reliability here. In this article, it is proposed to assemble a quadcopter from low-cost components in order to obtain a hardware prototype and to develop a software solution for the flight controller with high-reliability requirements, which will meet avionics software standards using existing open-source software solutions, and also apply the results as a model for teaching courses “Components of operating systems” and “Software verification”. In the study, we proceed to analyse the structure of quadcopters and flight controllers for them, represent a self-assembly solution. We describe Ardupilot as open-source software for unmanned aerial vehicles, the appropriate APM controller and methods of PID control. Today's avionics standard of reliable software for flight controllers is a real-time partitioning operating system that is capable of responding to events from devices with an expected speed, as well as sharing processor time and memory between isolated partitions. A good example of such OS is the open-source POK (Partitioned Operating Kernel). In the repository, it contains an example design of a system for the quadcopters using AADL language for modeling its hardware and software. We apply such a technique with Model-driven engineering to a demo system that runs on real hardware and contains a flight management process with PID control as a partitioned process. Using a partitioned OS brings the reliability of flight system software to the next level. And to increase the level of control logic correctness we propose to use formal verification methods and provide examples of verifiable properties at the level of code using the deductive approach as well as at the level of the cyber-physical system using Differential dynamic logic to prove the stability.},
	number = {4},
	urldate = {2022-04-09},
	journal = {Proceedings of the Institute for System Programming of RAS},
	author = {Staroletov, S.M. and Amosov, M.S. and Shulga, K.M.},
	year = {2019},
	note = {Number: 4},
	pages = {39--60},
}

@book{garoche_formal_2019,
	address = {Princeton, New Jersey},
	series = {Princeton series in applied mathematics},
	title = {Formal verification of control system software},
	isbn = {978-0-691-18130-1},
	abstract = {An essential introduction to the analysis and verification of control systems software, the verification of control systems software is critical to a host of technologies and industries, from aeronautics and medical technology to the cars we drive--the failure of controller software can cost people their lives. In this authoritative and accessible book, Pierre-Loïc Garoche provides control engineers and computer scientists with an indispensable introduction to the formal techniques for analyzing and verifying this important class of software.Too often, control engineers are unaware of the issues surrounding the verification of software, while computer scientists tend to be unfamiliar with the specificities of controller software. Garoche provides a unified approach especially geared to graduate students in both fields, covering formal verification methods as well as the design and verification of controllers. He presents a wealth of new verification techniques for performing exhaustive analysis of controller software. These include new means to compute nonlinear invariants, the use of convex optimization tools, and methods for dealing with numerical imprecisions such as floating point computations occurring in the analyzed software.As the autonomy of these systems continues to increase--such as in autonomous cars, drones, and satellites and landers--the numerical functions in critical systems are growing ever more advanced. The techniques presented here are essential to support the formal analysis of the controller software being used in these new and emerging technologies},
	publisher = {Princeton University Press},
	author = {Garoche, Pierre-Loïc},
	year = {2019},
	note = {OCLC: on1059270929},
	keywords = {guides},
}

@article{zsombori_transformation_2005,
	title = {Transformation of {C} code to {Matlab}/{Simulink} models. {Approach} based on parsing},
	url = {http://rgdoi.net/10.13140/2.1.3464.6725},
	doi = {10.13140/2.1.3464.6725},
	urldate = {2022-04-09},
	author = {Zsombori, Vilmos},
	year = {2005},
	keywords = {partly\_read},
}

@article{arnold_specifying_2010,
	title = {Specifying and verifying sparse matrix codes},
	volume = {45},
	issn = {0362-1340},
	url = {http://doi.org/10.1145/1932681.1863581},
	doi = {10.1145/1932681.1863581},
	abstract = {Sparse matrix formats are typically implemented with low-level imperative programs. The optimized nature of these implementations hides the structural organization of the sparse format and complicates its verification. We define a variable-free functional language (LL) in which even advanced formats can be expressed naturally, as a pipeline-style composition of smaller construction steps. We translate LL programs to Isabelle/HOL and describe a proof system based on parametric predicates for tracking relationship between mathematical vectors and their concrete representations. This proof theory automatically verifies full functional correctness of many formats. We show that it is reusable and extensible to hierarchical sparse formats.},
	number = {9},
	urldate = {2022-08-02},
	journal = {ACM SIGPLAN Notices},
	author = {Arnold, Gilad and Hölzl, Johannes and Köksal, Ali Sinan and Bodík, Rastislav and Sagiv, Mooly},
	month = sep,
	year = {2010},
	note = {Number: 9},
	keywords = {Isabelle, partly\_read},
	pages = {249--260},
}

@misc{hamon_simulink_2008,
	title = {Simulink {Design} {Verifier}—{Applying} {Automated} {Formal} {Methods} to {Simulink} and {Stateflow}},
	abstract = {null},
	author = {Hamon, Grégoire and Erkök, Levent and Matthews, John},
	editor = {Rushby, John and Shankar, Natarajan},
	year = {2008},
	keywords = {partly\_read},
}

@article{siegel_combining_2008,
	title = {Combining symbolic execution with model checking to verify parallel numerical programs},
	volume = {17},
	issn = {1049-331X},
	url = {http://doi.org/10.1145/1348250.1348256},
	doi = {10.1145/1348250.1348256},
	abstract = {We present a method to verify the correctness of parallel programs that perform complex numerical computations, including computations involving floating-point arithmetic. This method requires that a sequential version of the program be provided, to serve as the specification for the parallel one. The key idea is to use model checking, together with symbolic execution, to establish the equivalence of the two programs. In this approach the path condition from symbolic execution of the sequential program is used to constrain the search through the parallel program. To handle floating-point operations, three different types of equivalence are supported. Several examples are presented, demonstrating the approach and actual errors that were found. Limitations and directions for future research are also described.},
	number = {2},
	urldate = {2022-08-02},
	journal = {ACM Transactions on Software Engineering and Methodology},
	author = {Siegel, Stephen F. and Mironova, Anastasia and Avrunin, George S. and Clarke, Lori A.},
	month = may,
	year = {2008},
	note = {Number: 2},
	keywords = {SPIN, partly\_read},
	pages = {10:1--10:34},
}

@article{woodcock_formal_2009,
	title = {Formal methods: {Practice} and experience},
	volume = {41},
	issn = {0360-0300},
	shorttitle = {Formal methods},
	url = {http://doi.org/10.1145/1592434.1592436},
	doi = {10.1145/1592434.1592436},
	abstract = {Formal methods use mathematical models for analysis and verification at any part of the program life-cycle. We describe the state of the art in the industrial use of formal methods, concentrating on their increasing use at the earlier stages of specification and design. We do this by reporting on a new survey of industrial use, comparing the situation in 2009 with the most significant surveys carried out over the last 20 years. We describe some of the highlights of our survey by presenting a series of industrial projects, and we draw some observations from these surveys and records of experience. Based on this, we discuss the issues surrounding the industrial adoption of formal methods. Finally, we look to the future and describe the development of a Verified Software Repository, part of the worldwide Verified Software Initiative. We introduce the initial projects being used to populate the repository, and describe the challenges they address.},
	number = {4},
	urldate = {2022-08-02},
	journal = {ACM Computing Surveys},
	author = {Woodcock, Jim and Larsen, Peter Gorm and Bicarregui, Juan and Fitzgerald, John},
	month = oct,
	year = {2009},
	note = {Number: 4},
	keywords = {guides},
	pages = {19:1--19:36},
}

@article{clarke_formal_1996,
	title = {Formal methods: state of the art and future directions},
	volume = {28},
	issn = {0360-0300},
	shorttitle = {Formal methods},
	url = {http://doi.org/10.1145/242223.242257},
	doi = {10.1145/242223.242257},
	number = {4},
	urldate = {2022-08-02},
	journal = {ACM Computing Surveys},
	author = {Clarke, Edmund M. and Wing, Jeannette M.},
	month = dec,
	year = {1996},
	note = {Number: 4},
	keywords = {guides, partly\_read},
	pages = {626--643},
}

@article{baugh_using_1992,
	title = {Using formal methods to specify the functional properties of engineering software},
	volume = {45},
	issn = {0045-7949},
	url = {https://www.sciencedirect.com/science/article/pii/004579499290440B},
	doi = {10.1016/0045-7949(92)90440-B},
	abstract = {This paper describes the use of formal methods in specifying the functional properties of engineering software components, an approach that enables one to deal more effectively with the complexities of large-scale engineering software systems. Because they are formal objects, these specifications can be manipulated using ordinary mathematics, validated with respect to formal requirements, and shown to satisfy properties such as consistency and completeness. In addition, their concise and unambiguous nature makes them suitable for both communication and commentary, which are not possible with substantial program texts. We present detailed examples of formally defined abstract data types, and discuss the role and potential benefits of formal specifications in engineering program design.},
	language = {en},
	number = {3},
	urldate = {2022-08-02},
	journal = {Computers \& Structures},
	author = {Baugh, J. W.},
	month = oct,
	year = {1992},
	note = {Number: 3},
	keywords = {partly\_read},
	pages = {557--570},
}

@article{chadha_formal_1999,
	title = {Formal specification of concurrent systems},
	volume = {30},
	issn = {0965-9978},
	url = {https://www.sciencedirect.com/science/article/pii/S0965997898000581},
	doi = {10.1016/S0965-9978(98)00058-1},
	abstract = {This paper presents a formal methodology for developing concurrent systems. We extend the Larch family of specification languages and tools with the CCS process algebra to support the specification and verification of concurrent systems. We present and follow a refinement strategy that relates an implementation in a programming language to a formal specification of such a system. We illustrate our methodology on an example that uses the preconditioned conjugate gradient method for solving a linear system of equations.},
	language = {en},
	number = {3},
	urldate = {2022-08-02},
	journal = {Advances in Engineering Software},
	author = {Chadha, HarpreetS. and Baugh, JohnW. and Wing, JeannetteM.},
	month = mar,
	year = {1999},
	note = {Number: 3},
	pages = {211--224},
}

@article{bientinesi_science_2005,
	title = {The science of deriving dense linear algebra algorithms},
	volume = {31},
	issn = {0098-3500},
	url = {http://doi.org/10.1145/1055531.1055532},
	doi = {10.1145/1055531.1055532},
	abstract = {In this article we present a systematic approach to the derivation of families of high-performance algorithms for a large set of frequently encountered dense linear algebra operations. As part of the derivation a constructive proof of the correctness of the algorithm is generated. The article is structured so that it can be used as a tutorial for novices. However, the method has been shown to yield new high-performance algorithms for well-studied linear algebra operations and should also be of interest to those who wish to produce best-in-class high-performance codes.},
	number = {1},
	urldate = {2022-08-02},
	journal = {ACM Transactions on Mathematical Software},
	author = {Bientinesi, Paolo and Gunnels, John A. and Myers, Margaret E. and Quintana-Ortí, Enrique S. and Geijn, Robert A. van de},
	month = mar,
	year = {2005},
	note = {Number: 1},
	keywords = {partly\_read},
	pages = {1--26},
}

@inproceedings{altuntas_hybrid_2018,
	title = {Hybrid {Theorem} {Proving} as a {Lightweight} {Method} for {Verifying} {Numerical} {Software}},
	doi = {10.1109/Correctness.2018.00005},
	abstract = {Large-scale numerical software requires substantial computer resources that complicate testing and debugging. A single run of a climate model may require many millions of core-hours and terabytes of disk space, making trial-and-error experiments burdensome and time consuming. In this study, we apply hybrid theorem proving from the field of cyber-physical systems to problems in scientific computation, and show how to verify the correctness of discrete updates that appear in the simulation of continuous physical systems. By viewing numerical software as a hybrid system that combines discrete and continuous behavior, test coverage and confidence in findings can be increased. We describe abstraction approaches for modeling numerical software and demonstrate the applicability of the approach in a case study that reproduces undesirable behavior encountered in a parameterization scheme, called the K-profile parameterization, widely used in ocean components of large-scale climate models. We then identify and model a fix in the configuration of the scheme, and verify that the undesired behavior is eliminated for all possible execution sequences. We conclude that hybrid theorem proving is an effective and efficient approach that can be used to verify and reason about properties of large-scale numerical software.},
	booktitle = {2018 {IEEE}/{ACM} 2nd {International} {Workshop} on {Software} {Correctness} for {HPC} {Applications} ({Correctness})},
	author = {Altuntas, Alper and Baugh, John},
	month = nov,
	year = {2018},
	keywords = {KeYmaera X, partly\_read},
	pages = {1--8},
}

@article{baugh_formal_2018,
	series = {Abstract {State} {Machines}, {Alloy}, {B}, {TLA}, {VDM} and {Z} ({ABZ} 2016)},
	title = {Formal methods and finite element analysis of hurricane storm surge: {A} case study in software verification},
	volume = {158},
	issn = {0167-6423},
	shorttitle = {Formal methods and finite element analysis of hurricane storm surge},
	url = {https://www.sciencedirect.com/science/article/pii/S0167642317301715},
	doi = {10.1016/j.scico.2017.08.012},
	abstract = {Used to predict the effects of hurricane storm surge, ocean circulation models are essential tools for evacuation planning, vulnerability assessment, and infrastructure design. Implemented as numerical solvers that operate on large-scale datasets, these models determine the geographic extent and severity of coastal floods and other impacts. In this study, we look at an ocean circulation model used in production and an extension made to it that offers substantial performance gains. To explore implementation choices and ensure soundness of the extension, we make use of Alloy, a declarative modeling language with tool support and an automatic form of analysis performed within a bounded scope using a SAT solver. Abstractions for relevant parts of the ocean circulation model are presented, including the physical representation of land and seafloor surfaces as a finite element mesh, and an algorithm operating on it that allows for the propagation of overland flows. The approach allows us to draw useful conclusions about implementation choices and guarantees about the extension, in particular that it is equivalence preserving.},
	language = {en},
	urldate = {2022-08-02},
	journal = {Science of Computer Programming},
	author = {Baugh, John and Altuntas, Alper},
	month = jun,
	year = {2018},
	keywords = {Alloy, Lingeling, MiniSat, partly\_read},
	pages = {100--121},
}

@article{baugh_general_2016,
	title = {A general characterization of the {Hardy} {Cross} method as sequential and multiprocess algorithms},
	volume = {6},
	issn = {2352-0124},
	url = {https://www.sciencedirect.com/science/article/pii/S2352012416300054},
	doi = {10.1016/j.istruc.2016.03.004},
	abstract = {The Hardy Cross method of moment distribution admits, for any problem, an entire family of distribution sequences. Intuitively, the method involves clamping the joints of beams and frames against rotation and balancing moments iteratively, whether consecutively, simultaneously, or in some combination of the two. We present common versions of the moment distribution algorithm and generalizations of them as both sequential and multiprocess algorithms, with the latter exhibiting the full range of asynchronous behavior allowed by the method. We prove, in the limit, that processes so defined converge to the same unique solution regardless of the distribution sequence or interleaving of steps. In defining the algorithms, we avoid overspecifying the order of computation initially using a sequential, nondeterministic process, and then more generally using concurrent processes.},
	language = {en},
	urldate = {2022-08-02},
	journal = {Structures},
	author = {Baugh, John and Liu, Shu},
	month = may,
	year = {2016},
	pages = {170--181},
}

@inproceedings{altuntas_verifying_2017,
	address = {New York, NY, USA},
	series = {Correctness'17},
	title = {Verifying {Concurrency} in an {Adaptive} {Ocean} {Circulation} {Model}},
	isbn = {978-1-4503-5127-0},
	url = {http://doi.org/10.1145/3145344.3145346},
	doi = {10.1145/3145344.3145346},
	abstract = {We present a model checking approach for verifying the correctness of concurrency in numerical models. The forms of concurrency we address are from (1) coupled modeling where distinct components, e.g., ocean, wave, and atmospheric, exchange interface conditions during runtime, and (2) multi-instance modeling where local variations of the same numerical model are executed concurrently to minimize common (and therefore redundant) computations. We present general guidelines for representing these forms of concurrency in an abstract verification model and then apply them to an adaptive ocean circulation model that determines the geographic extent and severity of coastal floods. The ocean model employs multi-instance concurrency: a collection of engineering design and failure scenarios are concurrently simulated using patches, regions of a grid that grow and shrink based on the hydrodynamic changes induced by each scenario. We show how concurrency inherent in the simulation model can be represented in a verification model to ensure correctness and to automatically generate safe synchronization arrangements.},
	urldate = {2022-08-02},
	booktitle = {Proceedings of the {First} {International} {Workshop} on {Software} {Correctness} for {HPC} {Applications}},
	publisher = {Association for Computing Machinery},
	author = {Altuntas, Alper and Baugh, John},
	month = nov,
	year = {2017},
	keywords = {SPIN, partly\_read},
	pages = {1--7},
}

@inproceedings{ishikawa_what_2009,
	address = {Berlin, Heidelberg},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {What {Top}-{Level} {Software} {Engineers} {Tackle} after {Learning} {Formal} {Methods}: {Experiences} from the {Top} {SE} {Project}},
	isbn = {978-3-642-04912-5},
	shorttitle = {What {Top}-{Level} {Software} {Engineers} {Tackle} after {Learning} {Formal} {Methods}},
	doi = {10.1007/978-3-642-04912-5_5},
	abstract = {In order to make practical use of formal methods, it is not sufficient for engineers to obtain general, fundamental knowledge of the methods and tools. Actually, it is also necessary for them to carefully consider their own contexts and determine adequate approaches to their own problems. Specifically, engineers need to choose adequate methods and tools, determine their usage strategies, and even customize or extend them for their effective and efficient use. Regarding the point, this paper reports and discusses experiences on education of formal methods in the Top SE program targeting software engineers in the industry. The program involves education of a variety of scientific methods and tools with group exercises on practical problems, allowing students to compare different approaches while understanding common principles. In addition, the program involves graduation studies where each student identifies and tackles their own problems. Statistics on problem settings in the graduation studies provide interesting insights into what top-level engineers tackles after learning formal methods.},
	language = {en},
	booktitle = {Teaching {Formal} {Methods}},
	publisher = {Springer},
	author = {Ishikawa, Fuyuki and Taguchi, Kenji and Yoshioka, Nobukazu and Honiden, Shinichi},
	editor = {Gibbons, Jeremy and Oliveira, José Nuno},
	year = {2009},
	keywords = {CSP, Event-B, JML, SMV, SPIN, UPPAAL, VDM, partly\_read},
	pages = {57--71},
}

@article{barthels_linnea_2021,
	title = {Linnea: {Automatic} {Generation} of {Efficient} {Linear} {Algebra} {Programs}},
	volume = {47},
	issn = {0098-3500},
	shorttitle = {Linnea},
	url = {http://doi.org/10.1145/3446632},
	doi = {10.1145/3446632},
	abstract = {The translation of linear algebra computations into efficient sequences of library calls is a non-trivial task that requires expertise in both linear algebra and high-performance computing. Almost all high-level languages and libraries for matrix computations (e.g., Matlab, Eigen) internally use optimized kernels such as those provided by BLAS and LAPACK; however, their translation algorithms are often too simplistic and thus lead to a suboptimal use of said kernels, resulting in significant performance losses. To combine the productivity offered by high-level languages, and the performance of low-level kernels, we are developing Linnea, a code generator for linear algebra problems. As input, Linnea takes a high-level description of a linear algebra problem; as output, it returns an efficient sequence of calls to high-performance kernels. Linnea uses a custom best-first search algorithm to find a first solution in less than a second, and increasingly better solutions when given more time. In 125 test problems, the code generated by Linnea almost always outperforms Matlab, Julia, Eigen, and Armadillo, with speedups up to and exceeding 10×.},
	number = {3},
	urldate = {2022-08-02},
	journal = {ACM Transactions on Mathematical Software},
	author = {Barthels, Henrik and Psarras, Christos and Bientinesi, Paolo},
	month = jun,
	year = {2021},
	note = {Number: 3},
	keywords = {partly\_read},
	pages = {22:1--22:26},
}

@misc{bientinesi_science_2002,
	title = {The {Science} of {Programming} {High}-{Performance} {Linear} {Algebra} {Libraries}},
	abstract = {When considering the unmanageable complexity of computer systems, Dijkstra recently made the following observations: 1. When exhaustive testing is impossible –i.e., almost always– our trust can only be based on proof (be it mechanized or not).
2. A program for which it is not clear why we should trust it, is of dubious value.
3. A program should be structured in such a way that the argument for its correctness is feasible and not unnecessarily laborious.
4. Given the proof, deriving a program justified by it, is much easier than, given the program, constructing a proof justifying it.
Over the last decade, our research in the area of the implementation of high performance sequential and parallel linear algebra libraries has made the wisdom of the above observations obvious. In this paper, we show how to apply formal derivation methods to linear algebra operations. By combining this approach with a high-level abstraction for coding such algorithms, a linear algebra library that is more desirable, as measured by the metric provided by the above observations, can be achieved. Moreover, such a library can include a richer array of algorithms and is, at the same time, more easily maintained and extended. Most surprisingly, the methodology results in more efficient implementations. The approach is sufficiently systematic that much of it can be, and has been, automated.},
	author = {Bientinesi, Paolo and Gunnels, John A. and Gustavson, Fred G. and Henry, Greg M. and Myers, Margaret E. and Quintana-Orti, Enrique S. and Geijn, Robert A. van de},
	year = {2002},
	keywords = {partly\_read},
}

@misc{parikh_deriving_2017,
	title = {Deriving {Correct} {High}-{Performance} {Algorithms}},
	url = {http://arxiv.org/abs/1710.04286},
	doi = {10.48550/arXiv.1710.04286},
	abstract = {Dijkstra observed that verifying correctness of a program is difficult and conjectured that derivation of a program hand-in-hand with its proof of correctness was the answer. We illustrate this goal-oriented approach by applying it to the domain of dense linear algebra libraries for distributed memory parallel computers. We show that algorithms that underlie the implementation of most functionality for this domain can be systematically derived to be correct. The benefit is that an entire family of algorithms for an operation is discovered so that the best algorithm for a given architecture can be chosen. This approach is very practical: Ideas inspired by it have been used to rewrite the dense linear algebra software stack starting below the Basic Linear Algebra Subprograms (BLAS) and reaching up through the Elemental distributed memory library, and every level in between. The paper demonstrates how formal methods and rigorous mathematical techniques for correctness impact HPC.},
	urldate = {2022-08-02},
	publisher = {arXiv},
	author = {Parikh, Devangi N. and Myers, Maggie E. and van de Geijn, Robert A.},
	month = oct,
	year = {2017},
	note = {Issue: arXiv:1710.04286
arXiv:1710.04286 [cs]},
}

@article{leman_better_2020,
	title = {Better together: {Elements} of successful scientific software development in a distributed collaborative community},
	volume = {16},
	issn = {1553-7358},
	shorttitle = {Better together},
	url = {https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1007507},
	doi = {10.1371/journal.pcbi.1007507},
	abstract = {Many scientific disciplines rely on computational methods for data analysis, model generation, and prediction. Implementing these methods is often accomplished by researchers with domain expertise but without formal training in software engineering or computer science. This arrangement has led to underappreciation of sustainability and maintainability of scientific software tools developed in academic environments. Some software tools have avoided this fate, including the scientific library Rosetta. We use this software and its community as a case study to show how modern software development can be accomplished successfully, irrespective of subject area. Rosetta is one of the largest software suites for macromolecular modeling, with 3.1 million lines of code and many state-of-the-art applications. Since the mid 1990s, the software has been developed collaboratively by the RosettaCommons, a community of academics from over 60 institutions worldwide with diverse backgrounds including chemistry, biology, physiology, physics, engineering, mathematics, and computer science. Developing this software suite has provided us with more than two decades of experience in how to effectively develop advanced scientific software in a global community with hundreds of contributors. Here we illustrate the functioning of this development community by addressing technical aspects (like version control, testing, and maintenance), community-building strategies, diversity efforts, software dissemination, and user support. We demonstrate how modern computational research can thrive in a distributed collaborative community. The practices described here are independent of subject area and can be readily adopted by other software development communities.},
	language = {en},
	number = {5},
	urldate = {2022-08-02},
	journal = {PLOS Computational Biology},
	author = {Leman, Julia Koehler and Weitzner, Brian D. and Renfrew, P. Douglas and Lewis, Steven M. and Moretti, Rocco and Watkins, Andrew M. and Mulligan, Vikram Khipple and Lyskov, Sergey and Adolf-Bryfogle, Jared and Labonte, Jason W. and Krys, Justyna and Consortium, RosettaCommons and Bystroff, Christopher and Schief, William and Gront, Dominik and Schueler-Furman, Ora and Baker, David and Bradley, Philip and Dunbrack, Roland and Kortemme, Tanja and Leaver-Fay, Andrew and Strauss, Charlie E. M. and Meiler, Jens and Kuhlman, Brian and Gray, Jeffrey J. and Bonneau, Richard},
	month = may,
	year = {2020},
	note = {Number: 5
Publisher: Public Library of Science},
	keywords = {partly\_read},
	pages = {e1007507},
}

@phdthesis{heavner_building_2022,
	address = {United States -- Colorado},
	type = {Ph.{D}.},
	title = {Building {Rank}-{Revealing} {Factorizations} with {Randomization}},
	copyright = {Database copyright ProQuest LLC; ProQuest does not claim copyright in the individual underlying works.},
	url = {https://www.proquest.com/docview/2234476332/abstract/1C9CDA10B9D64F06PQ/1},
	abstract = {This thesis describes a set of randomized algorithms for computing rank revealing factorizations of matrices. These algorithms are designed specifically to minimize the amount of data movement required, which is essential to high practical performance on modern computing hardware. The work presented builds on existing randomized algorithms for computing low-rank approximations to matrices, but essentially extends the range of applicability of these methods by allowing for the efficient decomposition of matrices of any numerical rank, including full rank matrices. In contrast, existing methods worked well only when the numerical rank was substantially smaller than the dimensions of the matrix.

The thesis describes algorithms for computing two of the most popular rank-revealing matrix decompositions: the column pivoted QR (CPQR) decomposition, and the so called UTV decomposition that factors a given matrix A as A = UTV*, where U and V have orthonormal columns and T is triangular. For each algorithm, the thesis presents algorithms that are tailored for different computing environments, including multicore shared memory processors, GPUs, distributed memory machines, and matrices that are stored on hard drives ("out of core").

The first chapter of the thesis consists of an introduction that provides context, reviews previous work in the field, and summarizes the key contributions. Beside the introduction, the thesis contains six additional chapters:

Chapter 2 introduces a fully blocked algorithm HQRRP for computing a QR factorization with column pivoting. The key to the full blocking of the algorithm lies in using randomized projections to create a low dimensional sketch of the data, where multiple good pivot columns may be cheaply computed. Numerical experiments show that HQRRP is several times faster than the classical algorithm for computing a column pivoted QR on a multicore machine, and the acceleration factor increases with the number of cores.

Chapter 3 introduces randUTV, a randomized algorithm for computing a rank-revealing factorization of the form A = UTV*, where U and V are orthogonal and T is upper triangular. RandUTV uses randomized methods to efficiently build U and V as approximations of the column and row spaces of A. The result is an algorithm that reveals rank nearly as well as the SVD and costs at most as much as a column pivoted QR.

Chapter 4 provides optimized implementations for shared and distributed memory architectures. For shared memory, we show that formulating randUTV as an algorithm-by-blocks increases its efficiency in parallel. The fifth chapter implements randUTV on the GPU and augments the algorithm with an over-sampling technique to further increase the low rank approximation properties of the resulting factorization. Chapter 6 implements both randUTV and HQRRP for use with matrices stored out of core. It is shown that reorganizing HQRRP as a left-looking algorithm to reduce the number of writes to the drive is in the tested cases necessary for the scalability of the algorithm when using spinning disk storage. Finally, chapter 7 discusses an alternative use for randUTV as a nuclear norm estimator and measures the acceleration gained from trimming down the algorithm when only singular value estimates are required.},
	language = {English},
	urldate = {2022-08-02},
	school = {University of Colorado at Boulder},
	author = {Heavner, Nathan D.},
	month = aug,
	year = {2022},
	note = {ISBN: 9781392165560},
	keywords = {partly\_read},
}

@techreport{hurd_formal_2003,
	title = {Formal verification of probabilistic algorithms},
	url = {https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-566.html},
	language = {en},
	number = {UCAM-CL-TR-566},
	urldate = {2022-08-02},
	institution = {University of Cambridge, Computer Laboratory},
	author = {Hurd, Joe},
	year = {2003},
	doi = {10.48456/tr-566},
	note = {Issue: UCAM-CL-TR-566},
	keywords = {HOL, partly\_read},
}

@article{ahlander_einstein_2002,
	title = {Einstein summation for multidimensional arrays},
	volume = {44},
	issn = {0898-1221},
	url = {https://www.sciencedirect.com/science/article/pii/S0898122102002109},
	doi = {10.1016/S0898-1221(02)00210-9},
	abstract = {One of the most common data structures, at least in scientific computing, is the multidimensional array. Some numerical algorithms may conveniently be expressed as a generalized matrix multiplication, which computes a multidimensional array from two other multidimensional arrays. By adopting index notation with the Einstein summation convention, an elegant tool for expressing generalized matrix multiplications is obtained. Index notation is the succinct and compact notation primarily used in tensor calculus. In this paper, we develop computer support for index notation as a domain specific language. Grammar and semantics are proposed, yielding an unambiguous interpretation algorithm. An object-oriented implementation of a C++ library that supports index notation is described. A key advantage with computer support of index notation is that the notational gap between a mathematical index notation algorithm and its implementation in a computer language is avoided. This facilitates program construction as well as program understanding. Program examples that demonstrate the close resemblance between code and the original mathematical formulation are presented.},
	language = {en},
	number = {8},
	urldate = {2022-08-02},
	journal = {Computers \& Mathematics with Applications},
	author = {Åhlander, K.},
	month = oct,
	year = {2002},
	note = {Number: 8},
	keywords = {partly\_read},
	pages = {1007--1017},
}

@inproceedings{baugh_state-based_2018,
	address = {Cham},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {State-{Based} {Formal} {Methods} in {Scientific} {Computation}},
	isbn = {978-3-319-91271-4},
	doi = {10.1007/978-3-319-91271-4_29},
	abstract = {Control systems, protocols, and hardware design are among the most common applications of state-based formal methods, and yet the types of modeling and analysis they enable are also well-suited to problems in scientific computation, where quality, reproducibility, and productivity are growing concerns. We survey the challenges faced by developers of scientific software, characterize the nature of the programs they write, and offer some perspective on the role that state-based methods can play in scientific domains.},
	language = {en},
	booktitle = {Abstract {State} {Machines}, {Alloy}, {B}, {TLA}, {VDM}, and {Z}},
	publisher = {Springer International Publishing},
	author = {Baugh, John and Dyer, Tristan},
	editor = {Butler, Michael and Raschke, Alexander and Hoang, Thai Son and Reichl, Klaus},
	year = {2018},
	keywords = {Alloy, guides, read},
	pages = {392--396},
}

@article{gauhar_formal_2021,
	title = {Formal verification of {Matrix} based {MATLAB} models using interactive theorem proving},
	volume = {7},
	issn = {2376-5992},
	url = {https://peerj.com/articles/cs-440},
	doi = {10.7717/peerj-cs.440},
	abstract = {MATLAB is a software based analysis environment that supports a high-level programing language and is widely used to model and analyze systems in various domains of engineering and sciences. Traditionally, the analysis of MATLAB models is done using simulation and debugging/testing frameworks. These methods provide limited coverage due to their inherent incompleteness. Formal verification can overcome these limitations, but developing the formal models of the underlying MATLAB models is a very challenging and time-consuming task, especially in the case of higher-order-logic models. To facilitate this process, we present a library of higher-order-logic functions corresponding to the commonly used matrix functions of MATLAB as well as a translator that allows automatic conversion of MATLAB models to higher-order logic. The formal models can then be formally verified in an interactive theorem prover. For illustrating the usefulness of the proposed library and approach, we present the formal analysis of a Finite Impulse Response (FIR) filter, which is quite commonly used in digital signal processing applications, within the sound core of the HOL Light theorem prover.},
	language = {en},
	urldate = {2022-08-02},
	journal = {PeerJ Computer Science},
	author = {Gauhar, Ayesha and Rashid, Adnan and Hasan, Osman and Bispo, João and Cardoso, João M. P.},
	month = mar,
	year = {2021},
	note = {Publisher: PeerJ Inc.},
	keywords = {HOL Light, partly\_read},
	pages = {e440},
}

@article{leroy_formal_2009,
	title = {Formal verification of a realistic compiler},
	volume = {52},
	issn = {0001-0782},
	url = {http://doi.org/10.1145/1538788.1538814},
	doi = {10.1145/1538788.1538814},
	abstract = {This paper reports on the development and formal verification (proof of semantic preservation) of CompCert, a compiler from Clight (a large subset of the C programming language) to PowerPC assembly code, using the Coq proof assistant both for programming the compiler and for proving its correctness. Such a verified compiler is useful in the context of critical software and its formal verification: the verification of the compiler guarantees that the safety properties proved on the source code hold for the executable compiled code as well.},
	number = {7},
	urldate = {2022-08-02},
	journal = {Communications of the ACM},
	author = {Leroy, Xavier},
	month = jul,
	year = {2009},
	note = {Number: 7},
	keywords = {Coq, partly\_read},
	pages = {107--115},
}

@inproceedings{selvakumar_formal_2021,
	title = {Formal {Verification} and {Analysis} of a {Pseudo} {Random} {Number} {Generator}},
	doi = {10.1109/VDAT53777.2021.9601109},
	abstract = {Formal verification and analysis of a crypto hardware requires a formal specification, formal proof of equivalence of the specification with the hardware realization. Pseudo Random Number Generator hardware in Verilog RTL or equivalent has an entropy source for random seed, crypto algorithms and processing unit, authenticated access depicting static behavior; and dynamic finite state machines (FSM) for data flow control, fault/error checks and recovery. This paper focusses on a unified, transitive, compositional formal verification and analysis of a FPGA based PRNG with statistical methods, quantitative physical measurements based analysis, symbolic logical equivalence and model checks, and properties verification.},
	booktitle = {2021 25th {International} {Symposium} on {VLSI} {Design} and {Test} ({VDAT})},
	author = {Selvakumar, David and Mervin, J and Pattanshetty, Shashikala and Vivian, D},
	month = sep,
	year = {2021},
	keywords = {CBMC, NuSMV, partly\_read},
	pages = {1--6},
}

@inproceedings{sedletsky_formal_2000,
	address = {Berlin, Heidelberg},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Formal {Verification} of the {Ricart}-{Agrawala} {Algorithm}},
	isbn = {978-3-540-44450-3},
	doi = {10.1007/3-540-44450-5_26},
	abstract = {This paper presents the first formal verification of the Ricart- Agrawala algorithm [RA81] for distributed mutual exclusion of an arbitrary number of nodes. It uses the Temporal Methodology of [MP95a]. We establish both the safety property of mutual exclusion and the liveness property of accessibility. To establish these properties for an arbitrary number of nodes, parameterized proof rules are used as presented in [MP95a] (for safety) and [MP94] (for liveness). A new and efficient notation is introduced to facilitate the presentation of liveness proofs by verification diagrams.},
	language = {en},
	booktitle = {{FST} {TCS} 2000: {Foundations} of {Software} {Technology} and {Theoretical} {Computer} {Science}},
	publisher = {Springer},
	author = {Sedletsky, Ekaterina and Pnueli, Amir and Ben-Ari, Mordechai},
	editor = {Kapoor, Sanjiv and Prasad, Sanjiva},
	year = {2000},
	pages = {325--335},
}

@article{de_dinechin_certifying_2011,
	title = {Certifying the {Floating}-{Point} {Implementation} of an {Elementary} {Function} {Using} {Gappa}},
	volume = {60},
	issn = {1557-9956},
	doi = {10.1109/TC.2010.128},
	abstract = {High confidence in floating-point programs requires proving numerical properties of final and intermediate values. One may need to guarantee that a value stays within some range, or that the error relative to some ideal value is well bounded. This certification may require a time-consuming proof for each line of code, and it is usually broken by the smallest change to the code, e.g., for maintenance or optimization purpose. Certifying floating-point programs by hand is, therefore, very tedious and error-prone. The Gappa proof assistant is designed to make this task both easier and more secure, due to the following novel features: It automates the evaluation and propagation of rounding errors using interval arithmetic. Its input format is very close to the actual code to validate. It can be used incrementally to prove complex mathematical properties pertaining to the code. It generates a formal proof of the results, which can be checked independently by a lower level proof assistant like Coq. Yet it does not require any specific knowledge about automatic theorem proving, and thus, is accessible to a wide community. This paper demonstrates the practical use of this tool for a widely used class of floating-point programs: implementations of elementary functions in a mathematical library.},
	number = {2},
	journal = {IEEE Transactions on Computers},
	author = {de Dinechin, Florent and Lauter, Christoph and Melquiond, Guillaume},
	month = feb,
	year = {2011},
	note = {Number: 2
Conference Name: IEEE Transactions on Computers},
	keywords = {Coq, Gappa, PVS, Sollya, read},
	pages = {242--253},
}

@inproceedings{pervez_formal_2006,
	address = {Berlin, Heidelberg},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Formal {Verification} of {Programs} {That} {Use} {MPI} {One}-{Sided} {Communication}},
	isbn = {978-3-540-39112-8},
	doi = {10.1007/11846802_13},
	abstract = {We used formal-verification methods based on model checking to analyze the correctness properties of one existing and two new distributed-locking algorithms implemented by using MPI’s one-sided communication. Model checking exposed an overlooked correctness issue with the first algorithm, which had been developed by relying only on manual reasoning. Model checking helped confirm the basic correctness properties of the two new algorithms, while also identifying the remaining problems in them. Our experience is that MPI-based programming, especially the tricky and relatively poorly understood one-sided communication features, stand to gain immensely from model checking. Considering that many other areas of concurrent hardware and software design now routinely employ model checking, our experience confirms that the MPI community can benefit greatly from the use of formal verification.},
	language = {en},
	booktitle = {Recent {Advances} in {Parallel} {Virtual} {Machine} and {Message} {Passing} {Interface}},
	publisher = {Springer},
	author = {Pervez, Salman and Gopalakrishnan, Ganesh and Kirby, Robert M. and Thakur, Rajeev and Gropp, William},
	editor = {Mohr, Bernd and Träff, Jesper Larsson and Worringen, Joachim and Dongarra, Jack},
	year = {2006},
	keywords = {SPIN, partly\_read},
	pages = {30--39},
}

@inproceedings{dutle_formal_2017,
	address = {Cham},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {A {Formal} {Analysis} of the {Compact} {Position} {Reporting} {Algorithm}},
	isbn = {978-3-319-72308-2},
	doi = {10.1007/978-3-319-72308-2_2},
	abstract = {The Compact Position Reporting (CPR) algorithm is a safety-critical element of the Automatic Dependent Surveillance - Broadcast (ADS-B) protocol. This protocol enables aircraft to share their current states, i.e., position and velocity, with traffic aircraft in their vicinity. CPR consists of a collection of functions that encode and decode aircraft position data (latitude and longitude). Incorrect position decoding from CPR has been reported to the American and European organizations responsible for the ADS-B standard. This paper presents a formal analysis of the CPR algorithm in the Prototype Verification System (PVS). This formal analysis shows that the published requirements for correct decoding are insufficient, even if computations are assumed to be performed using exact real arithmetic. As a result of this analysis tightened requirements are proposed. These requirements, which are being considered by the standards organizations, are formally proven to guarantee correct decoding under exact real arithmetic. In addition, this paper proposes mathematically equivalent, but computationally simpler forms to several expressions in the CPR functions in order to reduce imprecise calculation.},
	language = {en},
	booktitle = {Verified {Software}. {Theories}, {Tools}, and {Experiments}},
	publisher = {Springer International Publishing},
	author = {Dutle, Aaron and Moscato, Mariano and Titolo, Laura and Muñoz, César},
	editor = {Paskevich, Andrei and Wies, Thomas},
	year = {2017},
	keywords = {PVS, partly\_read},
	pages = {19--34},
}

@inproceedings{boldo_formal_2007,
	title = {Formal {Verification} of {Floating}-{Point} {Programs}},
	doi = {10.1109/ARITH.2007.20},
	abstract = {This paper introduces a methodology to perform formal verification of floating-point C programs. It extends an existing tool for the verification of C programs, Caduceus, with new annotations specific to floating-point arithmetic. The Caduceus first-order logic model for C programs is extended accordingly. Then verification conditions expressing the correctness of the programs are obtained in the usual way and can be discharged interactively with the Coq proof assistant, using an existing Coq formalization of floatingpoint arithmetic. This methodology is already implemented and has been successfully applied to several short floatingpoint programs, which are presented in this paper.},
	booktitle = {18th {IEEE} {Symposium} on {Computer} {Arithmetic} ({ARITH} '07)},
	author = {Boldo, Sylvie and Filliatre, Jean-Christophe},
	month = jun,
	year = {2007},
	note = {ISSN: 1063-6889},
	keywords = {Caduceus, Coq, partly\_read},
	pages = {187--194},
}

@inproceedings{filliatre_multi-prover_2004,
	address = {Berlin, Heidelberg},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Multi-prover {Verification} of {C} {Programs}},
	isbn = {978-3-540-30482-1},
	doi = {10.1007/978-3-540-30482-1_10},
	abstract = {Our goal is the verification of C programs at the source code level using formal proof tools. Programs are specified using annotations such as pre- and post-conditions and global invariants. An original approach is presented which allows to formally prove that a function implementation satisfies its specification and is free of null pointer dereferencing and out-of-bounds array access. The method is not bound to a particular back-end theorem prover. A significant part of the ANSI C language is supported, including pointer arithmetic and possible pointer aliasing. We describe a prototype tool and give some experimental results.},
	language = {en},
	booktitle = {Formal {Methods} and {Software} {Engineering}},
	publisher = {Springer},
	author = {Filliâtre, Jean-Christophe and Marché, Claude},
	editor = {Davies, Jim and Schulte, Wolfram and Barnett, Mike},
	year = {2004},
	keywords = {Caduceus, Coq, partly\_read},
	pages = {15--29},
}

@inproceedings{goubault_static_2006,
	address = {Berlin, Heidelberg},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Static {Analysis} of {Numerical} {Algorithms}},
	isbn = {978-3-540-37758-0},
	doi = {10.1007/11823230_3},
	abstract = {We present a new numerical abstract domain for static analysis of the errors introduced by the approximation by floating-point arithmetic of real numbers computation, by abstract interpretation [3]. This work extends a former domain [4,8], with an implicitly relational domain for the approximation of the floating-point values of variables, based on affine arithmetic [2]. It allows us to analyze non trivial numerical computations, that no other abstract domain we know of can analyze with such precise results, such as linear recursive filters of different orders, Newton methods for solving non-linear equations, polynomial iterations, conjugate gradient algorithms.},
	language = {en},
	booktitle = {Static {Analysis}},
	publisher = {Springer},
	author = {Goubault, Eric and Putot, Sylvie},
	editor = {Yi, Kwangkeun},
	year = {2006},
	keywords = {FLUCTUAT, partly\_read},
	pages = {18--34},
}

@phdthesis{stanton_non-orthogonal_nodate,
	title = {Non-orthogonal {Spin}-adaptation and {Application} to {Coupled} {Cluster} up to {Quadruple} {Excitations}},
	language = {en},
	author = {Stanton, John and Brodbelt, Jennifer and Makarov, Dmitrii and Rossky, Peter and van de Geijn, Robert},
	keywords = {partly\_read},
}

@article{goldberg_what_1991,
	title = {What every computer scientist should know about floating-point arithmetic},
	volume = {23},
	issn = {0360-0300},
	url = {http://doi.org/10.1145/103162.103163},
	doi = {10.1145/103162.103163},
	abstract = {Floating-point arithmetic is considered as esoteric subject by many people. This is rather surprising, because floating-point is ubiquitous in computer systems: Almost every language has a floating-point datatype; computers from PCs to supercomputers have floating-point accelerators; most compilers will be called upon to compile floating-point algorithms from time to time; and virtually every operating system must respond to floating-point exceptions such as overflow. This paper presents a tutorial on the aspects of floating-point that have a direct impact on designers of computer systems. It begins with background on floating-point representation and rounding error, continues with a discussion of the IEEE floating point standard, and concludes with examples of how computer system builders can better support floating point.},
	number = {1},
	urldate = {2022-08-01},
	journal = {ACM Computing Surveys},
	author = {Goldberg, David},
	month = mar,
	year = {1991},
	note = {Number: 1},
	keywords = {guides},
	pages = {5--48},
}

@inproceedings{de_oliveira_practical_2013,
	address = {San Francisco, California},
	series = {{SE}-{CSE} '13},
	title = {Practical formal correctness checking of million-core problem solving environments for {HPC}},
	isbn = {978-1-4673-6261-0},
	abstract = {While formal correctness checking methods have been deployed at scale in a number of important practical domains, we believe that such an experiment has yet to occur in the domain of high performance computing at the scale of a million CPU cores. This paper presents preliminary results from the Uintah Runtime Verification (URV) project that has been launched with this objective. Uintah is an asynchronous task-graph based problem-solving environment that has shown promising results on problems as diverse as fluid-structure interaction and turbulent combustion at well over 200K cores to date. Uintah has been tested on leading platforms such as Kraken, Keenland, and Titan consisting of multicore CPUs and GPUs, incorporates several innovative design features, and is following a roadmap for development well into the million core regime. The main results from the URV project to date are crystallized in two observations: (1) A diverse array of well-known ideas from light-weight formal methods and testing/observing HPC systems at scale have an excellent chance of succeeding. The real challenges are in finding out exactly which combinations of ideas to deploy, and where. (2) Large-scale problem solving environments for HPC must be designed such that they can be "crashed early" (at smaller scales of deployment) and "crashed often" (have effective ways of input generation and schedule perturbation that cause vulnerabilities to be attacked with higher probability). Furthermore, following each crash, one must "explain well" (given the extremely obscure ways in which an error finally manifests itself, we must develop ways to record information leading up to the crash in informative ways, to minimize off-site debugging burden). Our plans to achieve these goals and to measure our success are described. We also highlight some of the broadly applicable concepts and approaches.},
	urldate = {2022-07-31},
	booktitle = {Proceedings of the 5th {International} {Workshop} on {Software} {Engineering} for {Computational} {Science} and {Engineering}},
	publisher = {IEEE Press},
	author = {de Oliveira, Diego Caminha B. and Rakamarić, Zvonimir and Gopalakrishnan, Ganesh and Humphrey, Alan and Meng, Qingyu and Berzins, Martin},
	month = may,
	year = {2013},
	keywords = {partly\_read},
	pages = {75--83},
}

@incollection{gunnels_formal_2001,
	address = {Boston, MA},
	series = {{IFIP} — {The} {International} {Federation} for {Information} {Processing}},
	title = {Formal {Methods} for {High}-{Performance} {Linear} {Algebra} {Libraries}},
	isbn = {978-0-387-35407-1},
	url = {https://doi.org/10.1007/978-0-387-35407-1_12},
	abstract = {A colleague of ours, Dr. Timothy Mattson of Intel, once made the following observation: “Literature professors read literature. Computer Science professors should at least occasionally read code.” The point he was making was that in order to write superior prose one needs to read good (and bad) literature. Analogously, it is our thesis that exposure to elegant (and ugly) programs tends to yield the insights which are necessary if one wishes to produce consistently well-written code.
Since the advent of high-performance distributed-memory parallel computing, the need for intelligible code has become ever greater. Development and maintenance of libraries for these kinds of architectures is simply too complex to be amenable to conventional approaches to coding. Attempting to do so has led to the production of an abundance of inefficient, anfractuous code that is difficult to maintain and nigh-impossible to upgrade.
Having struggled with these issues for more than a decade, we have arrived at a conclusion which is somewhat surprising to us: the answer is to apply formal methods from Computer Science to the development of high-performance linear algebra libraries. The resulting approach has consistently resulted in aesthetically-pleasing, coherent code that greatly facilitates performance analysis, intelligent modularity, and the enforcement of program correctness via assertions. Since the technique is completely language-independent, it lends itself equally well to a wide spectrum of programming languages (and paradigms) ranging from C and Fortran to C++ and Java. In this paper, we illustrate our observations by looking at our Formal Linear Algebra Methods Environment (FLAME).},
	language = {en},
	urldate = {2022-07-31},
	booktitle = {The {Architecture} of {Scientific} {Software}: {IFIP} {TC2}/{WG2}.5 {Working} {Conference} on the {Architecture} of {Scientific} {Software} {October} 2–4, 2000, {Ottawa}, {Canada}},
	publisher = {Springer US},
	author = {Gunnels, John A. and van de Geijn, Robert A.},
	editor = {Boisvert, Ronald F. and Tang, Ping Tak Peter},
	year = {2001},
	doi = {10.1007/978-0-387-35407-1_12},
	keywords = {read},
	pages = {193--210},
}

@inproceedings{titolo_formally_2018,
	address = {Cham},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {A {Formally} {Verified} {Floating}-{Point} {Implementation} of the {Compact} {Position} {Reporting} {Algorithm}},
	isbn = {978-3-319-95582-7},
	doi = {10.1007/978-3-319-95582-7_22},
	abstract = {The Automatic Dependent Surveillance-Broadcast (ADS-B) system allows aircraft to communicate their current state, including position and velocity information, to other aircraft in their vicinity and to ground stations. The Compact Position Reporting (CPR) algorithm is the ADS-B module responsible for the encoding and decoding of aircraft positions. CPR is highly sensitive to computer arithmetic since it heavily relies on functions that are intrinsically unstable such as floor and modulo. In this paper, a formally-verified double-precision floating-point implementation of the CPR algorithm is presented. The verification proceeds in three steps. First, an alternative version of CPR, which reduces the floating-point rounding error is proposed. Then, the Prototype Verification System (PVS) is used to formally prove that the ideal real-number counterpart of the improved algorithm is mathematically equivalent to the standard CPR definition. Finally, the static analyzer Frama-C is used to verify that the double-precision implementation of the improved algorithm is correct with respect to its operational requirement. The alternative algorithm is currently being considered for inclusion in the revised version of the ADS-B standards document as the reference implementation of the CPR algorithm.},
	language = {en},
	booktitle = {Formal {Methods}},
	publisher = {Springer International Publishing},
	author = {Titolo, Laura and Moscato, Mariano M. and Muñoz, César A. and Dutle, Aaron and Bobot, François},
	editor = {Havelund, Klaus and Peleska, Jan and Roscoe, Bill and de Vink, Erik},
	year = {2018},
	keywords = {Alt-Ergo, Frama-C, Gappa, PVS, partly\_read},
	pages = {364--381},
}

@book{hutton_mathematics_2019,
	address = {Cham},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Mathematics of {Program} {Construction}: 13th {International} {Conference}, {MPC} 2019, {Porto}, {Portugal}, {October} 7–9, 2019, {Proceedings}},
	volume = {11825},
	isbn = {978-3-030-33635-6 978-3-030-33636-3},
	shorttitle = {Mathematics of {Program} {Construction}},
	url = {http://link.springer.com/10.1007/978-3-030-33636-3},
	language = {en},
	urldate = {2022-07-29},
	publisher = {Springer International Publishing},
	editor = {Hutton, Graham},
	year = {2019},
	doi = {10.1007/978-3-030-33636-3},
}

@article{alvarez-rodriguez_survey_2018,
	title = {Survey of {Scientific} {Programming} {Techniques} for the {Management} of {Data}-{Intensive} {Engineering} {Environments}},
	volume = {2018},
	issn = {1058-9244},
	url = {https://www.hindawi.com/journals/sp/2018/8467413/},
	doi = {10.1155/2018/8467413},
	abstract = {The present paper introduces and reviews existing technology and research works in the field of scientific programming methods and techniques in data-intensive engineering environments. More specifically, this survey aims to collect those relevant approaches that have faced the challenge of delivering more advanced and intelligent methods taking advantage of the existing large datasets. Although existing tools and techniques have demonstrated their ability to manage complex engineering processes for the development and operation of safety-critical systems, there is an emerging need to know how existing computational science methods will behave to manage large amounts of data. That is why, authors review both existing open issues in the context of engineering with special focus on scientific programming techniques and hybrid approaches. 1193 journal papers have been found as the representative in these areas screening 935 to finally make a full review of 122. Afterwards, a comprehensive mapping between techniques and engineering and nonengineering domains has been conducted to classify and perform a meta-analysis of the current state of the art. As the main result of this work, a set of 10 challenges for future data-intensive engineering environments have been outlined.},
	language = {en},
	urldate = {2022-07-27},
	journal = {Scientific Programming},
	author = {Álvarez-Rodríguez, Jose María and Alor-Hernández, Giner and Mejía-Miranda, Jezreel},
	month = oct,
	year = {2018},
	note = {Publisher: Hindawi},
	keywords = {partly\_read},
	pages = {e8467413},
}

@article{storer_bridging_2017,
	title = {Bridging the {Chasm}: {A} {Survey} of {Software} {Engineering} {Practice} in {Scientific} {Programming}},
	volume = {50},
	issn = {0360-0300},
	shorttitle = {Bridging the {Chasm}},
	url = {http://doi.org/10.1145/3084225},
	doi = {10.1145/3084225},
	abstract = {The use of software is pervasive in all fields of science. Associated software development efforts may be very large, long lived, and complex, requiring the commitment of significant resources. However, several authors have argued that the “gap” or “chasm” between software engineering and scientific programming is a serious risk to the production of reliable scientific results, as demonstrated in a number of case studies. This article reviews the research that addresses the gap, exploring how both software engineering and research practice may need to evolve to accommodate the use of software in science.},
	number = {4},
	urldate = {2022-07-27},
	journal = {ACM Computing Surveys},
	author = {Storer, Tim},
	month = aug,
	year = {2017},
	note = {Number: 4},
	keywords = {guides, partly\_read},
	pages = {47:1--47:32},
}

@article{jobredeaux_formal_2015,
	title = {Formal verification of control software},
	url = {https://smartech.gatech.edu/handle/1853/53841},
	abstract = {In a context of heightened requirements for safety-critical embedded systems and
ever-increasing costs of verification and validation, this research proposes to
advance the state of formal analysis for control software. Formal methods are a
field of computer science that uses mathematical techniques and formalisms to
rigorously analyze the behavior of programs. This research develops a framework
and tools to express and prove high level properties of control law
implementations. One goal is to bridge the gap between control theory and
computer science. An annotation language is extended with symbols and axioms to
describe control-related concepts at the code level. Libraries of theorems,
along with their proofs, are developed to enable an interactive proof assistant
to verify control-related properties. Through integration in a prototype tool,
the process of verification is made automatic, and applied to several example systems.In a context of heightened requirements for safety-critical embedded systems and
ever-increasing costs of verification and validation, this research proposes to
advance the state of formal analysis for control software. Formal methods are a
field of computer science that uses mathematical techniques and formalisms to
rigorously analyze the behavior of programs. This research develops a framework
and tools to express and prove high level properties of control law
implementations. One goal is to bridge the gap between control theory and
computer science. An annotation language is extended with symbols and axioms to
describe control-related concepts at the code level. Libraries of theorems,
along with their proofs, are developed to enable an interactive proof assistant
to verify control-related properties. Through integration in a prototype tool,
the process of verification is made automatic, and applied to several example systems.},
	language = {en\_US},
	urldate = {2022-08-05},
	author = {Jobredeaux, Romain J.},
	month = may,
	year = {2015},
	note = {Accepted: 2015-09-21T14:24:16Z
Publisher: Georgia Institute of Technology},
}

@inproceedings{bochot_model_2009,
	title = {Model checking flight control systems: {The} {Airbus} experience},
	shorttitle = {Model checking flight control systems},
	doi = {10.1109/ICSE-COMPANION.2009.5070960},
	abstract = {This paper presents experiments realized by Airbus on model checking a safety critical system, lessons learnt and ways forward to extend the industrial use of formal verification at design level.},
	booktitle = {2009 31st {International} {Conference} on {Software} {Engineering} - {Companion} {Volume}},
	author = {Bochot, Thomas and Virelizier, Pierre and Waeselynck, Helene and Wiels, Virginie},
	month = may,
	year = {2009},
	keywords = {Aerospace control, Aerospace safety, Air safety, Aircraft, Electrical equipment industry, Embedded system, Formal languages, Formal verification, Software testing, System testing},
	pages = {18--27},
}

@inproceedings{meng_verified_2015,
	address = {Cham},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Verified {ROS}-{Based} {Deployment} of {Platform}-{Independent} {Control} {Systems}},
	isbn = {978-3-319-17524-9},
	doi = {10.1007/978-3-319-17524-9_18},
	abstract = {The paper considers the problem of model-based deployment of platform-independent control code on a specific platform. The approach is based on automatic generation of platform-specific glue code from an architectural model of the system. We present a tool, ROSGen, that generates the glue code based on a declarative specification of platform interfaces. Our implementation targets the popular Robot Operating System (ROS) platform. We demonstrate that the code generation process is amenable to formal verification. The code generator is implemented in Coq and relies on the infrastructure provided by the CompCert and VST tool. We prove that the generated code always correctly connects the controller function to sensors and actuators in the robot. We use ROSGen to implement a cruise control system on the LandShark robot.},
	language = {en},
	booktitle = {{NASA} {Formal} {Methods}},
	publisher = {Springer International Publishing},
	author = {Meng, Wenrui and Park, Junkil and Sokolsky, Oleg and Weirich, Stephanie and Lee, Insup},
	editor = {Havelund, Klaus and Holzmann, Gerard and Joshi, Rajeev},
	year = {2015},
	keywords = {Architectural Model, Controller Function, Global Variable, Separation Logic, Unmanned Ground Vehicle},
	pages = {248--262},
}

@inproceedings{ricketts_towards_2015,
	title = {Towards verification of hybrid systems in a foundational proof assistant},
	doi = {10.1109/MEMCOD.2015.7340492},
	abstract = {Unsafe behavior of hybrid systems can have disastrous consequences, motivating the need for formal verification of the software running on these systems. Foundational verification in a proof assistant such as Coq is a promising technique that can provide extremely strong, foundational, guarantees about software systems. In this paper, we show how to apply this technique to hybrid systems. We define a TLA-inspired formalism in Coq for reasoning about hybrid systems and use it to verify two quadcopter modules: the first limits the quadcopter's velocity and the second limits its altitude. We ran both of these modules on an actual quadcopter, and they worked as intended. We also discuss lessons learned from our experience foundationally verifying hybrid systems.},
	booktitle = {2015 {ACM}/{IEEE} {International} {Conference} on {Formal} {Methods} and {Models} for {Codesign} ({MEMOCODE})},
	author = {Ricketts, Daniel and Malecha, Gregory and Alvarez, Mario M. and Gowda, Vignesh and Lerner, Sorin},
	month = sep,
	year = {2015},
	keywords = {Cognition, Computer architecture, Differential equations, Safety, Sensors, Software, Upper bound},
	pages = {248--257},
}

@article{kitts_field_2012,
	title = {Field operation of a robotic small waterplane area twin hull boat for shallow-water bathymetric characterization: {A} {Robotic} {SWATH} {Boat} for {Bathymetry}},
	volume = {29},
	issn = {15564959},
	shorttitle = {Field operation of a robotic small waterplane area twin hull boat for shallow-water bathymetric characterization},
	url = {https://onlinelibrary.wiley.com/doi/10.1002/rob.21427},
	doi = {10.1002/rob.21427},
	language = {en},
	number = {6},
	urldate = {2022-05-08},
	journal = {Journal of Field Robotics},
	author = {Kitts, Christopher and Mahacek, Paul and Adamek, Thomas and Rasal, Ketan and Howard, Vincent and Li, Steve and Badaoui, Alexi and Kirkwood, William and Wheat, Geoffrey and Hulme, Sam},
	month = nov,
	year = {2012},
	pages = {924--938},
}

@book{douglas_fundamentals_nodate,
	title = {The {Fundamentals} of {Control} {Theory}},
	author = {Douglas, Brian},
}

@article{noauthor_control_2010,
	title = {From {Control} {Systems} to {Control} {Software}},
	volume = {30},
	issn = {1066-033X, 1941-000X},
	url = {https://ieeexplore.ieee.org/document/5643477/},
	doi = {10.1109/MCS.2010.938196},
	number = {6},
	urldate = {2022-04-09},
	journal = {IEEE Control Systems},
	month = dec,
	year = {2010},
	pages = {50--71},
}

@article{zsombori_transformation_2005,
	title = {Transformation of {C} code to {Matlab}/{Simulink} models. {Approach} based on parsing},
	url = {http://rgdoi.net/10.13140/2.1.3464.6725},
	doi = {10.13140/2.1.3464.6725},
	urldate = {2022-04-09},
	author = {Zsombori, Vilmos},
	year = {2005},
}

@book{garoche_formal_2019,
	address = {Princeton, New Jersey},
	series = {Princeton series in applied mathematics},
	title = {Formal verification of control system software},
	isbn = {9780691181301},
	abstract = {An essential introduction to the analysis and verification of control systems software, the verification of control systems software is critical to a host of technologies and industries, from aeronautics and medical technology to the cars we drive--the failure of controller software can cost people their lives. In this authoritative and accessible book, Pierre-Loïc Garoche provides control engineers and computer scientists with an indispensable introduction to the formal techniques for analyzing and verifying this important class of software.Too often, control engineers are unaware of the issues surrounding the verification of software, while computer scientists tend to be unfamiliar with the specificities of controller software. Garoche provides a unified approach especially geared to graduate students in both fields, covering formal verification methods as well as the design and verification of controllers. He presents a wealth of new verification techniques for performing exhaustive analysis of controller software. These include new means to compute nonlinear invariants, the use of convex optimization tools, and methods for dealing with numerical imprecisions such as floating point computations occurring in the analyzed software.As the autonomy of these systems continues to increase--such as in autonomous cars, drones, and satellites and landers--the numerical functions in critical systems are growing ever more advanced. The techniques presented here are essential to support the formal analysis of the controller software being used in these new and emerging technologies},
	publisher = {Princeton University Press},
	author = {Garoche, Pierre-Loïc},
	year = {2019},
	note = {OCLC: on1059270929},
	keywords = {Automatic control, Computer software},
}

@article{staroletov_designing_2019,
	title = {Designing robust quadcopter software based on a real-time partitioned operating system and formal verification techniques},
	volume = {31},
	issn = {20798156, 22206426},
	url = {https://www.ispras.ru/en/proceedings/isp_31_2019_4/isp_31_2019_4_39/},
	doi = {10.15514/ISPRAS-2019-31(4)-3},
	number = {4},
	urldate = {2022-04-09},
	journal = {Proceedings of the Institute for System Programming of RAS},
	author = {Staroletov, S.M. and Amosov, M.S. and Shulga, K.M.},
	year = {2019},
	pages = {39--60},
}

@inproceedings{hasan_formal_2013,
	address = {Grenoble, France},
	title = {Formal {Analysis} of {Steady} {State} {Errors} in {Feedback} {Control} {Systems} {Using} {HOL}-{Light}},
	isbn = {9781467350716},
	url = {http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=6513736},
	doi = {10.7873/DATE.2013.290},
	language = {en},
	urldate = {2022-04-09},
	booktitle = {Design, {Automation} \& {Test} in {Europe} {Conference} \& {Exhibition} ({DATE}), 2013},
	publisher = {IEEE Conference Publications},
	author = {Hasan, Osman and Ahmad, Muhammad},
	year = {2013},
	pages = {1423--1426},
}

@inproceedings{chan_formal_nodate,
	title = {Formal {Verification} of {Stability} {Properties} of {Cyber}-{Physical} {Systems}},
	author = {Chan, Mattthew and Rocketts, Daniel and Lerner, Sorin and Malecha, Gregory},
}

@inproceedings{adams_clawz_2005,
	address = {Washington, DC, USA},
	title = {{CLAWZ}: {Cost}-{Effective} {Formal} {Verification} for {Control} {Systems}},
	volume = {2},
	isbn = {9780780393073},
	shorttitle = {{CLAWZ}},
	url = {http://ieeexplore.ieee.org/document/1563404/},
	doi = {10.1109/DASC.2005.1563404},
	urldate = {2022-04-09},
	booktitle = {24th {Digital} {Avionics} {Systems} {Conference}},
	publisher = {IEEE},
	author = {Adams, M.M. and Clayton, P.B. and Tudor, N.J.},
	year = {2005},
	pages = {10.D.6--1--10.D.6--10},
}

@inproceedings{anta_automatic_2010,
	address = {New York, NY, USA},
	series = {{EMSOFT} '10},
	title = {Automatic verification of control system implementations},
	isbn = {9781605589046},
	url = {https://doi.org/10.1145/1879021.1879024},
	doi = {10.1145/1879021.1879024},
	abstract = {Software implementations of controllers for physical subsystems form the core of many modern safety-critical systems such as aircraft flight control and automotive engine control. A fundamental property of such implementations is stability, the guarantee that the physical plant converges to a desired behavior under the actions of the controller. We present a methodology and a tool to perform automated static analysis of embedded controller code for stability of the controlled physical system. The design of controllers for physical systems provides not only the controllers but also mathematical proofs of their stability under idealized mathematical models. Unfortunately, since these models do not capture most of the implementation details, it is not always clear if the stability properties are retained by the software implementation, either because of software bugs, or because of imprecisions arising from fixed-precision arithmetic or timing. Our methodology is based on the following separation of concerns. First, we analyze the controller mathematical models to derive bounds on the implementation errors that can be tolerated while still guaranteeing stability. Second, we automatically analyze the controller software to check if the maximal implementation error is within the tolerance bound computed in the first step. We have implemented this methodology in Costan, a tool to check stability for controller implementations. Using Costan, we analyzed a set of control examples whose mathematical models are given in Matlab/Simulink and whose C implementation is generated using Real-Time Workshop. Unlike previous static analysis research, which has focused on proving low-level runtime properties such as absence of buffer overruns or arithmetic overflows, our technique combines analysis of the mathematical controller models and automated analysis of source code to guarantee application-level stability properties.},
	urldate = {2022-04-08},
	booktitle = {Proceedings of the tenth {ACM} international conference on {Embedded} software},
	publisher = {Association for Computing Machinery},
	author = {Anta, Adolfo and Majumdar, Rupak and Saha, Indranil and Tabuada, Paulo},
	month = oct,
	year = {2010},
	keywords = {controller design, fixed-point arithmetic, program analysis, stability},
	pages = {9--18},
}

@inproceedings{zhou_design_2020,
	title = {The {Design} and {Development} of an {Affordable} {Unmanned} {Surface} {Vehicle} for {Estuary} {Research} and {STEM} {Education}},
	doi = {10.1109/IEEECONF38699.2020.9389085},
	abstract = {Unmanned Surface Vehicles (USVs) have been under significant development over the last twenty years. They have been used in a wide range of applications in oceanography and estuary environmental assessment. At the University of Rhode Island, we are developing a USV called Leo that stands for low-cost estuary open-source. The USV was constructed with commercial-off-the-shelf components with a total cost of under \$3,000. The main application of Leo is assessing and monitoring the freshwater pond water quality and bottom sediment. In this paper, we will present the overall design and development of Leo and present preliminary field testing results in a freshwater pond.},
	booktitle = {Global {Oceans} 2020: {Singapore} – {U}.{S}. {Gulf} {Coast}},
	author = {Zhou, Mingxi and Shi, Jianguang},
	month = oct,
	year = {2020},
	note = {ISSN: 0197-7385},
	keywords = {Oceanography, Open source software, Open-source robotics, Robots, Sea surface, Sediments, Testing, Unmanned Surface Vehicle, Water quality, estuary research},
	pages = {1--5},
}

@article{zaghi_hydrodynamic_2016,
	series = {Transport {Research} {Arena} {TRA2016}},
	title = {Hydrodynamic {Characterization} of {USV} {Vessels} with {Innovative} {SWATH} {Configuration} for {Coastal} {Monitoring} and {Low} {Environmental} {Impact}},
	volume = {14},
	issn = {2352-1465},
	url = {https://www.sciencedirect.com/science/article/pii/S2352146516301223},
	doi = {10.1016/j.trpro.2016.05.121},
	abstract = {The high costs associated with the use of research oceanographic vessels and the maturity of the unmanned surface vehicles (USV) makes now possible to develop systems for monitoring coastal areas based on networks of independent USVs. This type of vessels is a valid alternative to conventional vessels, which have a limited mission profile due to their high environmental impact (conventional propulsion systems based on polluting fossil fuels) inhibiting their access to protected coastal regions. Moreover, conventional vessels have high hydrodynamic resistance (limiting the autonomy) producing high levels of noise that can dramatically influence the monitoring equipment shipped: beside the environmental impact reduction, there is also the necessity of low-resistance/low-noise hydrodynamic specification. Consequently, the coastal monitoring (of also protected regions) needs unconventional vessels able to address both the issues related to the environmental impact and the hydrodynamic performance. In this framework, this work aims to characterize the hydrodynamic performance of a system based on USV units able to launch and recover autonomous vehicles of different nature (gliders, AUVs, motor-gliders, wire-guided ROVs), and able to acquire environmental data (in the column water from free-surface to the sea floor), in order to meet the requirements of civil and military applications. The cutting-edge aspects that characterize the USV studied are the hull SWATH type (Small Waterplane Area Twin Hulls) non-conventional, optimized so as to ensure a unique seakeeping and a reduced resistance, along with the propulsion system with propellers in mantle, developed to combine propulsive efficiency and low noise. In the present paper, a SWATH-shaped USV designed for monitoring of protected coastal regions is numerically studied solving the Navier-Stokes equations on the fully appended vessels with several environmental conditions. An accurate hydrodynamic characterization will presented in order to investigate its performances and eventual maneuverability issues.},
	language = {en},
	urldate = {2022-04-02},
	journal = {Transportation Research Procedia},
	author = {Zaghi, Stefano and Dubbioso, Giulio and Broglia, Riccardo and Muscari, Roberto},
	month = jan,
	year = {2016},
	keywords = {CFD, Intereference Factor, SWATH, UAV},
	pages = {1562--1570},
}

@inproceedings{wang_hydrodynamic_2016,
	title = {Hydrodynamic analysis of a {SWATH} planing {USV} based on {CFD}},
	doi = {10.1109/OCEANSAP.2016.7485460},
	abstract = {As small waterplane area twin hull (SWATH) has excellent seakeeping performance and low wave resistance, this structure has been applied to unmanned surface vehicle (USV). However, with the increase of speed, fluid resistances will increase exponentially because of its large wet surface. A way to improve this situation is to reduce the depth of draft at high speed, so that all or a part of the volume of the submerged bodies is above the surface of water. Based on this idea, a new type of SWATH USV is designed in this paper. The two submerged bodies of the USV have a planing boat shape. At high speed, hydrodynamic lift force generated by the submerged bodies of the USV can push most part of the submerged bodies out of water, which can greatly reduce the resistance of the USV. In this paper, computational fluid dynamic (CFD) method is used to analyze the attitude and resistance of the USV at different speed, showing that the designed USV can achieve the expected movement characteristics and low resistance at high speed.},
	booktitle = {{OCEANS} 2016 - {Shanghai}},
	author = {Wang, Chao and Lin, Yang and Hu, Zhiqiang and Geng, Lingbo and Li, Dongdong},
	month = apr,
	year = {2016},
	keywords = {CFD, Computational fluid dynamics, Computational modeling, Hydrodynamics, Immune system, Marine vehicles, Planing, SWATH, Surface resistance, USV},
	pages = {1--4},
}

@inproceedings{villa_design_2016,
	title = {Design and control of an unmanned surface vehicle for environmental monitoring applications},
	doi = {10.1109/CCRA.2016.7811411},
	abstract = {Unmanned Surface Vehicles (USV) have been used in a wide range of applications, in particular in environmental monitoring. In this work we propose the design and control of an USV which is intended to be used for monitoring environmental variables of the main inlet waters located in Cartagena de Indias, Colombia, such as Chambacu, Cabrero and San Lazaro. The paper shows the results obtained in the naval design, focused on the hull design, and the control strategy for unmanned navigability which is tested in simulation.},
	booktitle = {2016 {IEEE} {Colombian} {Conference} on {Robotics} and {Automation} ({CCRA})},
	author = {Villa, J. L. and Paez, J. and Quintero, C. and Yime, E. and Cabrera, J.},
	month = sep,
	year = {2016},
	keywords = {Boats, Control systems, Mathematical model, Navigation, Ocean temperature, Vehicles},
	pages = {1--5},
}

@article{sohn_design_2015,
	title = {Design of a {Fuel}-{Cell}-{Powered} {Catamaran}-{Type} {Unmanned} {Surface} {Vehicle}},
	volume = {40},
	issn = {1558-1691},
	doi = {10.1109/JOE.2014.2315889},
	abstract = {The goal of this study is to verify the applicability of fuel cells for powering surface vessels by developing a small catamaran-type unmanned surface vehicle (USV) powered by a hydrogen fuel cell. This study encompasses the entire process of designing a fuel-cell-powered USV, as well as sea trial tests with a 1.487-m full-scale prototype. To improve the performance and system efficiency of the USV, a simulation-based hull form design and integrated control systems were implemented during the design process. First, the optimum hull form of the catamaran, with the optimum separation, was determined based on hydrodynamic optimization using parametric models to achieve good fuel economy. Second, an automatic control system integrated with the global positioning and inertial navigation systems was implemented in the designed catamaran so that it had the ability to perform waypoint, departure, station keeping, and turning circle maneuvers. Next, the gain parameters of the fuzzy proportional-integral-derivative (PID) controller were adjusted to assure reliable tracking control. Automatically controlled trial tests were then conducted to validate the performance of the autonomous surface vehicle with respect to the fuel cell power requirements and its dynamic motion. Based on the results of the trial tests and the transient response of the fuel cell, a hybrid power control algorithm for the fuel cell and the batteries was implemented for more efficient power utilization. This catamaran-type unmanned surface vehicle powered with a fuel cell can be utilized for ocean environment monitoring and multifunctional missions.},
	number = {2},
	journal = {IEEE Journal of Oceanic Engineering},
	author = {Sohn, Seok-In and Oh, Jung-Hwan and Lee, Yeon-Seung and Park, Dae-Hwan and Oh, Il-Kwon},
	month = apr,
	year = {2015},
	keywords = {Fuel cell, Fuel cells, Marine vehicles, Parametric statistics, Resistance, Sea surface, Surface waves, Vehicles, hull separation, hybrid power control, simulation-based design, transient response, unmanned surface vehicle (USV)},
	pages = {388--396},
}

@inproceedings{prasad_hydrodynamics_2018,
	title = {Hydrodynamics of {Advanced}-hull {Surface} {Vehicles}},
	doi = {10.1109/OCEANS.2018.8604717},
	abstract = {Hydrodynamics of an advanced catamaran unmanned surface vehicle (USV) in shallow waters involving CFD-based modeling and simulation is described, in support of system identification and development of a physics-based control system for USV operations in coastal waters. The key objectives of the study are to develop the necessary CFD tool, validate it through comparison of computed results with results of field tests of the vehicle, and conduct a parametric study of the vehicle performance at different Froude numbers in calm water. The characteristics of the wave resistance, wave-hull interactions and free surface flow patterns around the hulls of the surface vehicle are also determined. The CFD tool will serve as a performance prediction tool for the USV.},
	booktitle = {{OCEANS} 2018 {MTS}/{IEEE} {Charleston}},
	author = {Prasad, Bijoy and Dhanak, Manhar},
	month = oct,
	year = {2018},
	note = {ISSN: 0197-7385},
	keywords = {CFD, Color, Computational modeling, Dynamics, Fluids, Mathematical model, Sea surface, Surface waves, Unmanned surface vehicle, dynamic mesh, free surface flow, volume of fluid method, wave resistance, wave-hull interactions},
	pages = {1--7},
}

@inproceedings{metcalfe_compact_2017,
	title = {A compact, low-cost unmanned surface vehicle for shallow inshore applications},
	doi = {10.1109/IntelliSys.2017.8324246},
	abstract = {This paper describes the preliminary design, implementation, and testing of a Police Robot for Inspecting and Mapping underwater Evidence (PRIME), an Unmanned Surface Vehicle (USV) developed to aid and support police search teams in shallow-water and inshore reconnaissance operations. Manual processing of such areas can be time consuming and difficult, with dangerous debris and low visibility causing further hindrance in some scenarios. PRIME uses a combination of MultiBeam EchoSounder (MBES) and Side Scan Sonar (SSS) systems for high resolution underwater imaging. Additional navigational sensors provide PRIME with further data allowing for position control, path planning and autonomous navigation within complex environments such as inland waterways. Such applications pose significant design constraints, with the USV required to be compact and portable, relatively inexpensive and scenario-configurable. We present some approaches taken to address these challenges, based around a modular hardware and software architecture using the Robot Operating System (ROS) framework. Data gathered from field tests using initial prototypes for the detection of body-shaped test targets is also discussed.},
	booktitle = {2017 {Intelligent} {Systems} {Conference} ({IntelliSys})},
	author = {Metcalfe, Ben and Thomas, Ben and Treloar, Alfie and Rymansaib, Zuhayr and Hunter, Alan and Wilson, Peter},
	month = sep,
	year = {2017},
	keywords = {Autonomous, Cameras, Law enforcement, Robot sensing systems, Sonar, Sonar navigation, police, sonar, underwater search, unmanned surface vehicle},
	pages = {961--968},
}

@inproceedings{manley_unmanned_2008,
	title = {Unmanned surface vehicles, 15 years of development},
	volume = {2008-Supplement},
	doi = {10.1109/OCEANS.2008.5289429},
	abstract = {To celebrate the 40th Anniversary of the Oceanic Engineering Society (OES) at the MTS/IEEE OCEANS 2008 Conference in Quebec City a series of review papers were requested from OES technical committee chairs. In response to that request this paper provides a review of the field of unmanned surface vehicles (USVs) and autonomous surface craft (ASCs). The paper discusses the enabling technologies that have allowed USVs to emerge as a viable platform for marine operations as well as the application areas where they offer value. The paper tracks developments in technology from early systems developed by the author in 1993 through the latest developments and demonstration programs. The future outlook for USV technology is also described.},
	booktitle = {{OCEANS} 2008},
	author = {Manley, Justin E.},
	month = sep,
	year = {2008},
	note = {ISSN: 0197-7385},
	keywords = {Marine technology, Marine vehicles, Navigation, Oceanic Engineering Society, Paper technology, Remotely operated vehicles, Rivers, Sea measurements, Sea surface, Testing},
	pages = {1--4},
}

@article{liu_unmanned_2016,
	title = {Unmanned surface vehicles: {An} overview of developments and challenges},
	volume = {41},
	issn = {1367-5788},
	shorttitle = {Unmanned surface vehicles},
	url = {https://www.sciencedirect.com/science/article/pii/S1367578816300219},
	doi = {10.1016/j.arcontrol.2016.04.018},
	abstract = {With growing worldwide interest in commercial, scientific, and military issues associated with both oceans and shallow waters, there has been a corresponding growth in demand for the development of unmanned surface vehicles (USVs) with advanced guidance, navigation and control (GNC) capabilities. This paper presents a comprehensive literature review of recent progress in USVs development. The paper first provides an overview of both historical and recent USVs development, along with some fundamental definitions. Next, existing USVs GNC approaches are outlined and classified according to various criteria, such as their applications, methodologies, and challenges. Finally, more general challenges and future directions of USVs towards more practical GNC capabilities are highlighted.},
	language = {en},
	urldate = {2022-04-02},
	journal = {Annual Reviews in Control},
	author = {Liu, Zhixiang and Zhang, Youmin and Yu, Xiang and Yuan, Chi},
	month = jan,
	year = {2016},
	keywords = {Autonomy, Guidance, navigation and control (GNC), Overview, Unmanned surface vehicles (USVs)},
	pages = {71--93},
}

@article{blaich_design_2013,
	series = {9th {IFAC} {Conference} on {Control} {Applications} in {Marine} {Systems}},
	title = {Design of a {Twin} {Hull} {Based} {USV} with {Enhanced} {Maneuverability}},
	volume = {46},
	issn = {1474-6670},
	url = {https://www.sciencedirect.com/science/article/pii/S1474667016461240},
	doi = {10.3182/20130918-4-JP-3022.00056},
	abstract = {This paper provides an overview of the development of a catamaran-like autonomous surface vessel. The vessel is intended to serve as an experimental platform to study algorithms for control, sensor data fusion as well as path planning and collision avoidance. The mechanical design, the electronics and software architecture is described together with the sensor and actuator setup. The propulsion system comprises of two azimuth thrusters with limited azimuth angles. This concept provides additional degrees of freedom resulting in an overactuated control system. A mathematical model of the vessel has been adapted and implemented for model based control strategies, simulation and hardware in the loop testing. In this paper some results of the parameter identification process are presented. For the overactuated system a control allocation algorithm has been developed.},
	language = {en},
	number = {33},
	urldate = {2022-04-02},
	journal = {IFAC Proceedings Volumes},
	author = {Blaich, Michael and Wirtensohn, Stefan and Oswald, Markus and Hamburger, Oliver and Reuter, Johannes},
	month = jan,
	year = {2013},
	keywords = {USV conception, control allocation, parameter identification},
	pages = {1--6},
}

@inproceedings{abduljabbar_design_2018,
	title = {Design and implementation of autonomous surface vehicle},
	doi = {10.1109/MELCON.2018.8379109},
	abstract = {This paper explores the design and implementation of an autonomous surface vehicle (ASV) at Qatar University which includes mechanical design, image processing, control and navigation, and power management. A PID controller is designed for the heading control and waypoint control of the ASV and both simulation and experimental results are presented.},
	booktitle = {2018 19th {IEEE} {Mediterranean} {Electrotechnical} {Conference} ({MELECON})},
	author = {Abduljabbar, Majd and Sneineh, Ruslan Abu and Qiblawey, Yazan and Orabi, Yousef and Meskin, Nader},
	month = may,
	year = {2018},
	note = {ISSN: 2158-8481},
	keywords = {ASV, Autonomous Control, Batteries, Boats, Brushless DC motors, Heading Control, Mathematical model, PID, Power system stability, Waypoint Control},
	pages = {287--292},
}

@article{su_dynamic_2021,
	title = {Dynamic event-triggered formation control for {AUVs} with fixed-time integral sliding mode disturbance observer},
	volume = {240},
	issn = {00298018},
	url = {https://linkinghub.elsevier.com/retrieve/pii/S0029801821012415},
	doi = {10.1016/j.oceaneng.2021.109893},
	language = {en},
	urldate = {2022-03-28},
	journal = {Ocean Engineering},
	author = {Su, Bo and Wang, Hong-bin and Wang, Yueling},
	month = nov,
	year = {2021},
	pages = {109893},
}

@article{lyridis_improved_2021,
	title = {An improved ant colony optimization algorithm for unmanned surface vehicle local path planning with multi-modality constraints},
	volume = {241},
	issn = {00298018},
	url = {https://linkinghub.elsevier.com/retrieve/pii/S0029801821012385},
	doi = {10.1016/j.oceaneng.2021.109890},
	language = {en},
	urldate = {2022-03-28},
	journal = {Ocean Engineering},
	author = {Lyridis, Dimitrios V.},
	month = dec,
	year = {2021},
	pages = {109890},
}

@article{yao_auv_2021,
	title = {{AUV} path planning for coverage search of static target in ocean environment},
	volume = {241},
	issn = {00298018},
	url = {https://linkinghub.elsevier.com/retrieve/pii/S0029801821013809},
	doi = {10.1016/j.oceaneng.2021.110050},
	language = {en},
	urldate = {2022-03-28},
	journal = {Ocean Engineering},
	author = {Yao, Peng and Qiu, Liyan and Qi, Jiaping and Yang, Rui},
	month = dec,
	year = {2021},
	pages = {110050},
}

@article{ben_novel_2021,
	title = {A novel cooperative navigation algorithm based on factor graph with cycles for {AUVs}},
	volume = {241},
	issn = {00298018},
	url = {https://linkinghub.elsevier.com/retrieve/pii/S0029801821013585},
	doi = {10.1016/j.oceaneng.2021.110024},
	language = {en},
	urldate = {2022-03-28},
	journal = {Ocean Engineering},
	author = {Ben, Yueyang and Sun, Yan and Li, Qian and Zang, Xinle},
	month = dec,
	year = {2021},
	pages = {110024},
}

@article{zhou_obstacle_2022,
	title = {Obstacle avoidance strategy for an autonomous surface vessel based on modified deep deterministic policy gradient},
	volume = {243},
	issn = {00298018},
	url = {https://linkinghub.elsevier.com/retrieve/pii/S0029801821014876},
	doi = {10.1016/j.oceaneng.2021.110166},
	language = {en},
	urldate = {2022-03-28},
	journal = {Ocean Engineering},
	author = {Zhou, Chang and Wang, Yiting and Wang, Lei and He, Huacheng},
	month = jan,
	year = {2022},
	pages = {110166},
}

@article{gao_course_2022,
	title = {Course keeping control strategy for large oil tankers based on nonlinear feedback of swish function},
	volume = {244},
	issn = {00298018},
	url = {https://linkinghub.elsevier.com/retrieve/pii/S0029801821016796},
	doi = {10.1016/j.oceaneng.2021.110385},
	language = {en},
	urldate = {2022-03-28},
	journal = {Ocean Engineering},
	author = {Gao, Shihang and Zhang, Xianku},
	month = jan,
	year = {2022},
	pages = {110385},
}

@article{ma_path_2022,
	title = {Path planning of {UUV} based on {HQPSO} algorithm with considering the navigation error},
	volume = {244},
	issn = {00298018},
	url = {https://linkinghub.elsevier.com/retrieve/pii/S0029801821013780},
	doi = {10.1016/j.oceaneng.2021.110048},
	language = {en},
	urldate = {2022-03-28},
	journal = {Ocean Engineering},
	author = {Ma, Yan and Feng, Wei and Mao, Zhaoyong and Li, Heng and Meng, Xiangyao},
	month = jan,
	year = {2022},
	pages = {110048},
}

@inproceedings{evans_palx2014language_1968,
	address = {New York, NY, USA},
	series = {{ACM} '68},
	title = {{PAL}\&\#x2014;a language designed for teaching programming linguistics},
	isbn = {9781450374866},
	url = {https://doi.org/10.1145/800186.810604},
	doi = {10.1145/800186.810604},
	abstract = {This paper describes PAL—a new computer language. Given the fact that new languages seem to appear in computer literature at the rate of several per month, it seems incumbent on one who creates a new language to justify having done so. In the present case, there are two important considerations: control and specification. Let us consider each of these in turn. By virtue of our having designed PAL, it is ours. There is no PAL Users Group or Committee of Vested Interests concerned with retaining upward compatibility with what was done last year (or last month). This doesn't mean we change the specifications of the language every few weeks (our students are, in a real sense, our Committee of Vested Interests), but it does mean we can make decisions on changes solely on technical grounds. More important, though, we can design the language to meet the criteria we think important. For example, the language almost demands interpretive execution. Since no one writes production programs in PAL we are able to put up with inefficiencies in the implementation that would otherwise be intolerable. Thus we have designed our own language so that we will have control over it.},
	urldate = {2022-03-26},
	booktitle = {Proceedings of the 1968 23rd {ACM} national conference},
	publisher = {Association for Computing Machinery},
	author = {Evans, Arthur},
	month = jan,
	year = {1968},
	pages = {395--403},
}

@article{landin_next_1966,
	title = {The next 700 programming languages},
	volume = {9},
	issn = {0001-0782},
	url = {https://doi.org/10.1145/365230.365257},
	doi = {10.1145/365230.365257},
	abstract = {A family of unimplemented computing languages is described that is intended to span differences of application area by a unified framework. This framework dictates the rules about the uses of user-coined names, and the conventions about characterizing functional relationships. Within this framework the design of a specific language splits into two independent parts. One is the choice of written appearances of programs (or more generally, their physical representation). The other is the choice of the abstract entities (such as numbers, character-strings, list of them, functional relations among them) that can be referred to in the language. The system is biased towards “expressions” rather than “statements.” It includes a nonprocedural (purely functional) subsystem that aims to expand the class of users' needs that can be met by a single print-instruction, without sacrificing the important properties that make conventional right-hand-side expressions easy to construct and understand.},
	number = {3},
	urldate = {2022-03-27},
	journal = {Communications of the ACM},
	author = {Landin, P. J.},
	month = mar,
	year = {1966},
	pages = {157--166},
}

@inproceedings{turner_history_2013,
	address = {Berlin, Heidelberg},
	title = {Some {History} of {Functional} {Programming} {Languages}},
	isbn = {9783642404474},
	doi = {10.1007/978-3-642-40447-4_1},
	abstract = {We study a series of milestones leading to the emergence of lazy, higher order, polymorphically typed, purely functional programming languages. An invited lecture given at TFP12, St Andrews University, 12 June 2012.},
	language = {en},
	booktitle = {Trends in {Functional} {Programming}},
	publisher = {Springer},
	author = {Turner, D. A.},
	editor = {Loidl, Hans-Wolfgang and Peña, Ricardo},
	year = {2013},
	pages = {1--20},
}

@inproceedings{odersky_pizza_1997,
	address = {New York, NY, USA},
	series = {{POPL} '97},
	title = {Pizza into {Java}: translating theory into practice},
	isbn = {9780897918534},
	shorttitle = {Pizza into {Java}},
	url = {https://doi.org/10.1145/263699.263715},
	doi = {10.1145/263699.263715},
	abstract = {Pizza is a strict superset of Java that incorporates three ideas from the academic community: parametric polymorphism, higher-order functions, and algebraic data types. Pizza is defined by translation into Java and compiles into the Java Virtual Machine, requirements which strongly constrain the design space. Nonetheless, Pizza fits smoothly to Java, with only a few rough edges.},
	urldate = {2022-03-24},
	booktitle = {Proceedings of the 24th {ACM} {SIGPLAN}-{SIGACT} symposium on {Principles} of programming languages},
	publisher = {Association for Computing Machinery},
	author = {Odersky, Martin and Wadler, Philip},
	month = jan,
	year = {1997},
	keywords = {originating language},
	pages = {146--159},
}

@inproceedings{augustsson_compiler_1984,
	address = {New York, NY, USA},
	series = {{LFP} '84},
	title = {A compiler for lazy {ML}},
	isbn = {9780897911429},
	url = {https://doi.org/10.1145/800055.802038},
	doi = {10.1145/800055.802038},
	abstract = {LML is a strongly typed, statically scoped functional Language with Lazy evaluation. It is compiled trough a number of program transformations which makes the code generation easier. Code is generated in two steps, first code for an abstract graph manipulation machine, the G-machine. From this code machine code is generated. Some benchmark tests are also presented.},
	urldate = {2022-03-23},
	booktitle = {Proceedings of the 1984 {ACM} {Symposium} on {LISP} and functional programming},
	publisher = {Association for Computing Machinery},
	author = {Augustsson, Lennart},
	month = aug,
	year = {1984},
	keywords = {originating language},
	pages = {218--227},
}

@inproceedings{cardelli_compiling_1984,
	address = {New York, NY, USA},
	series = {{LFP} '84},
	title = {Compiling a functional language},
	isbn = {9780897911429},
	url = {https://doi.org/10.1145/800055.802037},
	doi = {10.1145/800055.802037},
	abstract = {This paper summarizes my experience in implementing a compiler for a functional language. The language is ML(1) [Milner 84] and the compiler was first implemented in 1980 as a personal project when I was a postgraduate student at the University of Edinburgh(2). At the time, I was familiar with programming language semantics but knew very little about compiler technology; interpreters had been my main programming concern. Major influences in the design of this compiler have been [Steele 77] [Steele 78] and the implementation folklore for statically and dynamically scoped dialects of Lisp [Allen 78]. As a result, the internal structure of the compiler is fairly unorthodox, if compared for example with [Aho 78]. Anyway, a compiler for a language like ML has to be different. ML is interactive, statically scoped, strongly typed, polymorphic, and has first class higher-order functions, type inference and dynamic allocation. These features preclude many well-known implementation styles, particularly the ones used for Lisp (because of static scoping), the Algol family (because of functional values) and C (because of nested scoping and strong typing). The interaction of these features is what gives ML its “character”, and makes compilation challenging. The compiler has been recently partially converted to the new ML standard. The major points of interest which are discussed in this paper are: (a) the interactive interpreter-like usage; (b) the polymorphic type inference algorithm; (c) the compilation of pattern matching; (d) the optimization of the representation of user defined data types; (e) the compilation of functional closures, function application and variable access; (f) the intermediate abstract machine and its formal operational semantics; (g) modules and type-safe separate compilation.},
	urldate = {2022-03-23},
	booktitle = {Proceedings of the 1984 {ACM} {Symposium} on {LISP} and functional programming},
	publisher = {Association for Computing Machinery},
	author = {Cardelli, Luca},
	month = aug,
	year = {1984},
	keywords = {early implementation},
	pages = {208--217},
}

@inproceedings{milner_proposal_1984,
	address = {New York, NY, USA},
	series = {{LFP} '84},
	title = {A proposal for standard {ML}},
	isbn = {9780897911429},
	url = {https://doi.org/10.1145/800055.802035},
	doi = {10.1145/800055.802035},
	urldate = {2022-03-23},
	booktitle = {Proceedings of the 1984 {ACM} {Symposium} on {LISP} and functional programming},
	publisher = {Association for Computing Machinery},
	author = {Milner, Robin},
	month = aug,
	year = {1984},
	keywords = {originating language},
	pages = {184--197},
}

@article{turner_recursion_1978,
	title = {Recursion {Equations} as a {Programming} {Language}},
	journal = {Functional Programming and its Applications},
	author = {Turner},
	year = {1978},
	keywords = {making the case},
	pages = {1--10},
}

@book{turner_sasl_1976,
	title = {{SASL} {Language} {Manual}},
	author = {Turner, D A},
	year = {1976},
	keywords = {originating language},
}

@inproceedings{burstall_hope_1980,
	address = {New York, NY, USA},
	series = {{LFP} '80},
	title = {{HOPE}: {An} experimental applicative language},
	isbn = {9781450373968},
	shorttitle = {{HOPE}},
	url = {https://doi.org/10.1145/800087.802799},
	doi = {10.1145/800087.802799},
	abstract = {An applicative language called HOPE is described and discussed. The underlying goal of the design and implementation effort was to produce a very simple programming language which encourages the construction of clear and manipulable programs. HOPE does not include an assignment statement; this is felt to be an important simplification. The user may freely define his own data types, without the need to devise a complicated encoding in terms of low-level types. The language is very strongly typed, and as implemented it incorporates a typechecker which handles polymorphic types and overloaded operators. Functions are defined by a set of recursion equations; the left-hand side of each equation includes a pattern used to determine which equation to use for a given argument. The availability of arbitrary higher-order types allows functions to be defined which 'package' recursion. Lazily-evaluated lists are provided, allowing the use of infinite lists which could be used to provide interactive input/output and concurrency. HOPE also includes a simple modularisation facility which may be used to protect the implementation of an abstract data type.},
	urldate = {2022-03-23},
	booktitle = {Proceedings of the 1980 {ACM} conference on {LISP} and functional programming},
	publisher = {Association for Computing Machinery},
	author = {Burstall, R. M. and MacQueen, D. B. and Sannella, D. T.},
	month = aug,
	year = {1980},
	keywords = {originating language},
	pages = {136--143},
}

@article{sarda_station-keeping_2016,
	title = {Station-keeping control of an unmanned surface vehicle exposed to current and wind disturbances},
	volume = {127},
	issn = {0029-8018},
	url = {https://www.sciencedirect.com/science/article/pii/S0029801816304206},
	doi = {https://doi.org/10.1016/j.oceaneng.2016.09.037},
	abstract = {Field trials of a 4m long, 180kg, unmanned surface vehicle (USV) have been conducted to evaluate the performance of station-keeping heading and position controllers in an outdoor marine environment disturbed by wind and current. The USV has a twin hull configuration and a custom-designed propulsion system, which consists of two azimuthing thrusters, one for each hull. Nonlinear proportional derivative, backstepping and sliding mode feedback controllers were tested in winds of about 4–5 knots, with and without wind feedforward control. The controllers were tested when the longitudinal axis of the USV was aligned with the mean wind direction and when the longitudinal axis was perpendicular to the mean wind direction. It was found that the sliding mode controller performed best overall and that the addition of wind feedforward control did not significantly improve its effectiveness. However, wind feedforward control did substantially improve the performance of the proportional derivative and backstepping controllers when the mean wind direction was perpendicular to the longitudinal axis of the USV. An analysis of the length scales present in the power spectrum of the turbulent speed fluctuations in the wind suggests that a single anemometer is sufficient to characterize the speed and direction of the wind acting on the USV.},
	journal = {Ocean Engineering},
	author = {Sarda, Edoardo I. and Qu, Huajin and Bertaska, Ivan R. and Ellenrieder, Karl D. von},
	year = {2016},
	keywords = {Nonlinear control, Station-keeping, Unmanned surface vehicles, Wind feedforward},
	pages = {305--324},
}

@article{sarda_station-keeping_2016-1,
	title = {Station-keeping control of an unmanned surface vehicle exposed to current and wind disturbances},
	volume = {127},
	issn = {0029-8018},
	url = {https://www.sciencedirect.com/science/article/pii/S0029801816304206},
	doi = {https://doi.org/10.1016/j.oceaneng.2016.09.037},
	abstract = {Field trials of a 4m long, 180kg, unmanned surface vehicle (USV) have been conducted to evaluate the performance of station-keeping heading and position controllers in an outdoor marine environment disturbed by wind and current. The USV has a twin hull configuration and a custom-designed propulsion system, which consists of two azimuthing thrusters, one for each hull. Nonlinear proportional derivative, backstepping and sliding mode feedback controllers were tested in winds of about 4–5 knots, with and without wind feedforward control. The controllers were tested when the longitudinal axis of the USV was aligned with the mean wind direction and when the longitudinal axis was perpendicular to the mean wind direction. It was found that the sliding mode controller performed best overall and that the addition of wind feedforward control did not significantly improve its effectiveness. However, wind feedforward control did substantially improve the performance of the proportional derivative and backstepping controllers when the mean wind direction was perpendicular to the longitudinal axis of the USV. An analysis of the length scales present in the power spectrum of the turbulent speed fluctuations in the wind suggests that a single anemometer is sufficient to characterize the speed and direction of the wind acting on the USV.},
	journal = {Ocean Engineering},
	author = {Sarda, Edoardo I. and Qu, Huajin and Bertaska, Ivan R. and Ellenrieder, Karl D. von},
	year = {2016},
	keywords = {Nonlinear control, Station-keeping, Unmanned surface vehicles, Wind feedforward},
	pages = {305--324},
}

@inproceedings{finnie-ansley_robots_2022,
	address = {Virtual Event Australia},
	title = {The {Robots} {Are} {Coming}: {Exploring} the {Implications} of {OpenAI} {Codex} on {Introductory} {Programming}},
	isbn = {978-1-4503-9643-1},
	shorttitle = {The {Robots} {Are} {Coming}},
	url = {https://dl.acm.org/doi/10.1145/3511861.3511863},
	doi = {10.1145/3511861.3511863},
	language = {en},
	urldate = {2022-02-26},
	booktitle = {Australasian {Computing} {Education} {Conference}},
	publisher = {ACM},
	author = {Finnie-Ansley, James and Denny, Paul and Becker, Brett A. and Luxton-Reilly, Andrew and Prather, James},
	month = feb,
	year = {2022},
	pages = {10--19},
}

@inproceedings{demarco_computationally-efficient_2015,
	address = {Washington, DC},
	title = {A computationally-efficient {2D} imaging sonar model for underwater robotics simulations in {Gazebo}},
	isbn = {978-0-933957-43-5},
	url = {http://ieeexplore.ieee.org/document/7404349/},
	doi = {10.23919/OCEANS.2015.7404349},
	urldate = {2022-01-18},
	booktitle = {{OCEANS} 2015 - {MTS}/{IEEE} {Washington}},
	publisher = {IEEE},
	author = {DeMarco, Kevin J. and West, Michael E. and Howard, Ayanna M.},
	month = oct,
	year = {2015},
	pages = {1--7},
}

@inproceedings{manhaes_uuv_2016,
	address = {Monterey, CA, USA},
	title = {{UUV} {Simulator}: {A} {Gazebo}-based package for underwater intervention and multi-robot simulation},
	isbn = {978-1-5090-1537-5},
	shorttitle = {{UUV} {Simulator}},
	url = {http://ieeexplore.ieee.org/document/7761080/},
	doi = {10.1109/OCEANS.2016.7761080},
	urldate = {2022-01-18},
	booktitle = {{OCEANS} 2016 {MTS}/{IEEE} {Monterey}},
	publisher = {IEEE},
	author = {Manhaes, Musa Morena Marcusso and Scherer, Sebastian A. and Voss, Martin and Douat, Luiz Ricardo and Rauschenbach, Thomas},
	month = sep,
	year = {2016},
	pages = {1--8},
}

@inproceedings{cook_survey_2014,
	address = {Oxford, MS, USA},
	title = {A survey of {AUV} and robot simulators for multi-vehicle operations},
	isbn = {978-1-4799-4344-9},
	url = {http://ieeexplore.ieee.org/document/7054411/},
	doi = {10.1109/AUV.2014.7054411},
	urldate = {2022-01-18},
	booktitle = {2014 {IEEE}/{OES} {Autonomous} {Underwater} {Vehicles} ({AUV})},
	publisher = {IEEE},
	author = {Cook, Daniel and Vardy, Andrew and Lewis, Ron},
	month = oct,
	year = {2014},
	pages = {1--8},
}

@inproceedings{bingham_toward_2019,
	address = {Seattle, WA, USA},
	title = {Toward {Maritime} {Robotic} {Simulation} in {Gazebo}},
	isbn = {978-0-578-57618-3},
	url = {https://ieeexplore.ieee.org/document/8962724/},
	doi = {10.23919/OCEANS40490.2019.8962724},
	urldate = {2022-01-18},
	booktitle = {{OCEANS} 2019 {MTS}/{IEEE} {SEATTLE}},
	publisher = {IEEE},
	author = {Bingham, Brian and Aguero, Carlos and McCarrin, Michael and Klamo, Joseph and Malia, Joshua and Allen, Kevin and Lum, Tyler and Rawson, Marshall and Waqar, Rumman},
	month = oct,
	year = {2019},
	pages = {1--10},
}

@article{graf_lower_2020,
	title = {Lower your guards: a compositional pattern-match coverage checker},
	volume = {4},
	shorttitle = {Lower your guards},
	url = {https://doi.org/10.1145/3408989},
	doi = {10.1145/3408989},
	abstract = {A compiler should warn if a function defined by pattern matching does not cover its inputs—that is, if there are missing or redundant patterns. Generating such warnings accurately is difficult for modern languages due to the myriad of language features that interact with pattern matching. This is especially true in Haskell, a language with a complicated pattern language that is made even more complex by extensions offered by the Glasgow Haskell Compiler (GHC). Although GHC has spent a significant amount of effort towards improving its pattern-match coverage warnings, there are still several cases where it reports inaccurate warnings. We introduce a coverage checking algorithm called Lower Your Guards, which boils down the complexities of pattern matching into guard trees. While the source language may have many exotic forms of patterns, guard trees only have three different constructs, which vastly simplifies the coverage checking process. Our algorithm is modular, allowing for new forms of source-language patterns to be handled with little changes to the overall structure of the algorithm. We have implemented the algorithm in GHC and demonstrate places where it performs better than GHC’s current coverage checker, both in accuracy and performance.},
	number = {ICFP},
	urldate = {2021-07-06},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Graf, Sebastian and Peyton Jones, Simon and Scott, Ryan G.},
	month = aug,
	year = {2020},
	keywords = {Haskell, guards, pattern matching, strictness},
	pages = {107:1--107:30},
}

@inproceedings{swidan_programming_2018,
	address = {Espoo Finland},
	title = {Programming {Misconceptions} for {School} {Students}},
	isbn = {9781450356282},
	url = {https://dl.acm.org/doi/10.1145/3230977.3230995},
	doi = {10.1145/3230977.3230995},
	language = {en},
	urldate = {2021-06-13},
	booktitle = {Proceedings of the 2018 {ACM} {Conference} on {International} {Computing} {Education} {Research}},
	publisher = {ACM},
	author = {Swidan, Alaaeddin and Hermans, Felienne and Smit, Marileen},
	month = aug,
	year = {2018},
	keywords = {COMP7872},
	pages = {151--159},
}

@article{pea_cognitive_1984,
	title = {On the cognitive effects of learning computer programming},
	volume = {2},
	issn = {0732118X},
	url = {https://linkinghub.elsevier.com/retrieve/pii/0732118X84900187},
	doi = {10.1016/0732-118X(84)90018-7},
	language = {en},
	number = {2},
	urldate = {2021-06-13},
	journal = {New Ideas in Psychology},
	author = {Pea, Roy D. and Kurland, D.Midian},
	month = jan,
	year = {1984},
	keywords = {COMP7872},
	pages = {137--168},
}

@book{fincher_cambridge_2019,
	edition = {1},
	title = {The {Cambridge} {Handbook} of {Computing} {Education} {Research}},
	isbn = {9781108654555 9781108496735 9781108721899},
	url = {https://www.cambridge.org/core/product/identifier/9781108654555/type/book},
	urldate = {2021-06-13},
	publisher = {Cambridge University Press},
	editor = {Fincher, Sally A. and Robins, Anthony V.},
	month = feb,
	year = {2019},
	doi = {10.1017/9781108654555},
	keywords = {COMP7872},
}

@inproceedings{mohnen_context_1996,
	address = {Berlin, Heidelberg},
	series = {{IFL} '96},
	title = {Context {Patterns} in {Haskell}},
	isbn = {3-540-63237-9},
	booktitle = {Selected {Papers} from the 8th {International} {Workshop} on {Implementation} of {Functional} {Languages}},
	publisher = {Springer-Verlag},
	author = {Mohnen, Markus},
	year = {1996},
	pages = {41--57},
}

@article{antoy_evaluation_2005,
	title = {Evaluation strategies for functional logic programming},
	volume = {40},
	issn = {0747-7171},
	url = {https://www.sciencedirect.com/science/article/pii/S0747717105000325},
	doi = {https://doi.org/10.1016/j.jsc.2004.12.007},
	abstract = {Recent advances in the foundations and the implementations of functional logic programming languages originate from far-reaching results on narrowing evaluation strategies. Narrowing is a computation similar to rewriting which yields substitutions in addition to normal forms. In functional logic programming, the classes of rewrite systems to which narrowing is applied are, for the most part, subclasses of the constructor-based, possibly conditional, rewrite systems. Many interesting narrowing strategies, particularly for the smallest subclasses of the constructor-based rewrite systems, are generalizations of well-known rewrite strategies. However, some strategies for larger non-confluent subclasses have been developed just for functional logic computations. This paper discusses the elements that play a relevant role in evaluation strategies for functional logic computations, describes some important classes of rewrite systems that model functional logic programs, shows examples of the differences in expressiveness provided by these classes, and reviews the characteristics of narrowing strategies proposed for each class of rewrite systems.},
	number = {1},
	journal = {Journal of Symbolic Computation},
	author = {Antoy, Sergio},
	year = {2005},
	keywords = {Constructor-based rewrite systems, Definitional trees, Evaluation strategies, Functional logic programming, Narrowing},
	pages = {875--903},
}

@inproceedings{antoy_declarative_2006,
	address = {Berlin, Heidelberg},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Declarative {Programming} with {Function} {Patterns}},
	isbn = {978-3-540-32656-4},
	doi = {10.1007/11680093_2},
	abstract = {We propose an extension of functional logic languages that allows the definition of operations with patterns containing other defined operation symbols. Such “function patterns” have many advantages over traditional constructor patterns. They allow a direct representation of specifications as declarative programs, provide better abstractions of patterns as first-class objects, and support the high-level programming of queries and transformation of complex structures. Moreover, they avoid known problems that occur in traditional programs using strict equality. We define their semantics via a transformation into standard functional logic programs. Since this transformation might introduce an infinite number of rules, we suggest an implementation that can be easily integrated with existing functional logic programming systems.},
	language = {en},
	booktitle = {Logic {Based} {Program} {Synthesis} and {Transformation}},
	publisher = {Springer},
	author = {Antoy, Sergio and Hanus, Michael},
	editor = {Hill, Patricia M.},
	year = {2006},
	keywords = {Constraint Logic Programming, Function Pattern, Logic Program, Logic Programming, Logic Variable},
	pages = {6--22},
}

@misc{noauthor_docker_2019,
	title = {Docker {Build}: {A} {Beginner}'s {Guide} to {Building} {Docker} {Images}},
	shorttitle = {Docker {Build}},
	url = {https://stackify.com/docker-build-a-beginners-guide-to-building-docker-images/},
	abstract = {Docker has changed the way we create applications, but isn’t a new idea. If building Docker images has been daunting for you, they won’t be after this post.},
	language = {en-US},
	urldate = {2021-01-14},
	journal = {Stackify},
	month = jul,
	year = {2019},
}

@misc{noauthor_pure_nodate,
	title = {Pure 5.15.3-1 - {Personal} overview},
	url = {https://research-management.mq.edu.au/admin/workspace/personal/overview/},
	urldate = {2020-09-30},
}

@inproceedings{sirkia_combining_2016,
	address = {New York, NY, USA},
	series = {Koli {Calling} '16},
	title = {Combining parson's problems with program visualization in {CS1} context},
	isbn = {978-1-4503-4770-9},
	url = {https://doi.org/10.1145/2999541.2999558},
	doi = {10.1145/2999541.2999558},
	abstract = {Parson's problems, in which students solve programming assignments by putting code fragments in the correct order, can be an easy way to start the assignments as there is no need to write code or struggle with the syntax. In this paper, we report results from a preliminary experiment in which we combined two existing libraries, js-parsons and Jsvee. We extended the original feedback of js-parsons with program visualizations to show for the students how their solution was executed and why it possibly did not work as expected. We analyzed the usage of the visualizations, and the results show that over half of the students viewed them if they were available. Novices who used the visualizations tend to need more submissions than the other novices, which may imply the weaker students find visualizations more useful. However, more research is needed to analyze the learning effects.},
	urldate = {2020-09-06},
	booktitle = {Proceedings of the 16th {Koli} {Calling} {International} {Conference} on {Computing} {Education} {Research}},
	publisher = {Association for Computing Machinery},
	author = {Sirkiä, Teemu},
	month = nov,
	year = {2016},
	keywords = {CS1, feedback, parson's problems, program visualization},
	pages = {155--159},
}

@inproceedings{tew_developing_2010,
	address = {Milwaukee, Wisconsin, USA},
	title = {Developing a validated assessment of fundamental {CS1} concepts},
	isbn = {978-1-4503-0006-3},
	url = {http://portal.acm.org/citation.cfm?doid=1734263.1734297},
	doi = {10.1145/1734263.1734297},
	abstract = {Previous studies of student programming ability have raised questions about students’ ability to problem solve, read and analyze code, and understand introductory computing concepts. However, it is unclear whether these results are the product of failures of student comprehension or our inability to accurately measure their performance. We propose a method for creating a language independent CS1 assessment instrument and present the results of our analysis used to deﬁne the common conceptual content that will serve as the framework for the exam. We conclude with a discussion of future work and our progress towards developing the assessment.},
	language = {en},
	urldate = {2020-08-20},
	booktitle = {Proceedings of the 41st {ACM} technical symposium on {Computer} science education - {SIGCSE} '10},
	publisher = {ACM Press},
	author = {Tew, Allison Elliott and Guzdial, Mark},
	year = {2010},
	pages = {97},
}

@inproceedings{sloane_respect_2014,
	title = {Respect your parents: {How} attribution and rewriting can get along},
	shorttitle = {Respect your parents},
	url = {https://researchers.mq.edu.au/en/publications/respect-your-parents-how-attribution-and-rewriting-can-get-along},
	language = {English},
	urldate = {2020-08-17},
	booktitle = {Software language engineering: 7th {International} {Conference}, {SLE} 2014, {Västerås}, {Sweden}, {September} 15-16, 2014 {Proceedings}},
	publisher = {Springer, Springer Nature},
	author = {Sloane, Anthony M. and Roberts, Matthew and Hamey, Leonard G. C.},
	year = {2014},
	pages = {191--210},
}

@inproceedings{kennedy_compiling_2007,
	address = {New York, NY, USA},
	series = {{ICFP} '07},
	title = {Compiling with continuations, continued},
	isbn = {978-1-59593-815-2},
	url = {https://doi.org/10.1145/1291151.1291179},
	doi = {10.1145/1291151.1291179},
	abstract = {We present a series of CPS-based intermediate languages suitable for functional language compilation, arguing that they have practical benefits over direct-style languages based on A-normal form (ANF) or monads. Inlining of functions demonstrates the benefits most clearly: in ANF-based languages, inlining involves a re-normalization step that rearranges let expressions and possibly introduces a new 'join point' function, and in monadic languages, commuting conversions must be applied; in contrast, inlining in our CPS language is a simple substitution of variables for variables. We present a contification transformation implemented by simple rewrites on the intermediate language. Exceptions are modelled using so-called 'double-barrelled' CPS. Subtyping on exception constructors then gives a very straightforward effect analysis for exceptions. We also show how a graph-based representation of CPS terms can be implemented extremely efficiently, with linear-time term simplification.},
	urldate = {2020-08-11},
	booktitle = {Proceedings of the 12th {ACM} {SIGPLAN} international conference on {Functional} programming},
	publisher = {Association for Computing Machinery},
	author = {Kennedy, Andrew},
	month = oct,
	year = {2007},
	keywords = {continuation passing style, continuations, functional programming languages, monads, optimizing compilation},
	pages = {177--190},
}

@inproceedings{tiwari_candoia_2017,
	address = {Buenos Aires, Argentina},
	title = {Candoia: {A} {Platform} for {Building} and {Sharing} {Mining} {Software} {Repositories} {Tools} as {Apps}},
	isbn = {978-1-5386-1544-7},
	shorttitle = {Candoia},
	url = {http://ieeexplore.ieee.org/document/7962355/},
	doi = {10.1109/MSR.2017.56},
	abstract = {We propose Candoia, a novel platform and ecosystem for building and sharing Mining Software Repositories (MSR) tools. Using Candoia, MSR tools are built as apps and Candoia ecosystem, acting as an appstore, allows effective sharing. Candoia platform provides, data extraction tools for curating custom datasets for user projects, and data abstractions for enabling uniform access to MSR artifacts from disparate sources, which makes apps portable and adoptable across diverse software project settings of MSR researchers and practitioners. The structured design of a Candoia app and the languages selected for building various components of a Candoia app promotes easy customization. To evaluate Candoia we have built over two dozen MSR apps for analyzing bugs, software evolution, project management aspects, and source code and programming practices showing the applicability of the platform for building a variety of MSR apps. For testing portability of apps across diverse project settings, we tested the apps using ten popular project repositories, such as Apache Tomcat, JUnit, Node.js, etc, and found that apps required no changes to be portable. We performed a user study to test customizability and we found that five of eight Candoia users found it very easy to customize an existing app. Candoia is available for download.},
	language = {en},
	urldate = {2020-08-06},
	booktitle = {2017 {IEEE}/{ACM} 14th {International} {Conference} on {Mining} {Software} {Repositories} ({MSR})},
	publisher = {IEEE},
	author = {Tiwari, Nitin M. and Upadhyaya, Ganesha and Nguyen, Hoan Anh and Rajan, Hridesh},
	month = may,
	year = {2017},
	pages = {53--63},
}

@inproceedings{bird_promises_2009,
	address = {Vancouver, BC, Canada},
	title = {The promises and perils of mining git},
	isbn = {978-1-4244-3493-0},
	url = {http://ieeexplore.ieee.org/document/5069475/},
	doi = {10.1109/MSR.2009.5069475},
	abstract = {We are now witnessing the rapid growth of decentralized source code management (DSCM) systems, in which every developer has her own repository. DSCMs facilitate a style of collaboration in which work output can ﬂow sideways (and privately) between collaborators, rather than always up and down (and publicly) via a central repository. Decentralization comes with both the promise of new data and the peril of its misinterpretation. We focus on git, a very popular DSCM used in high-proﬁle projects. Decentralization, and other features of git, such as automatically recorded contributor attribution, lead to richer content histories, giving rise to new questions such as “How do contributions ﬂow between developers to the ofﬁcial project repository?” However, there are pitfalls. Commits may be reordered, deleted, or edited as they move between repositories. The semantics of terms common to SCMs and DSCMs sometimes differ markedly, potentially creating confusion. For example, a commit is immediately visible to all developers in centralized SCMs, but not in DSCMs. Our goal is to help researchers interested in DSCMs avoid these and other perils when mining and analyzing git data.},
	language = {en},
	urldate = {2020-08-06},
	booktitle = {2009 6th {IEEE} {International} {Working} {Conference} on {Mining} {Software} {Repositories}},
	publisher = {IEEE},
	author = {Bird, Christian and Rigby, Peter C. and Barr, Earl T. and Hamilton, David J. and German, Daniel M. and Devanbu, Prem},
	month = may,
	year = {2009},
	pages = {1--10},
}

@inproceedings{ma_world_2019,
	address = {Montreal, QC, Canada},
	title = {World of {Code}: {An} {Infrastructure} for {Mining} the {Universe} of {Open} {Source} {VCS} {Data}},
	isbn = {978-1-72813-412-3},
	shorttitle = {World of {Code}},
	url = {https://ieeexplore.ieee.org/document/8816786/},
	doi = {10.1109/MSR.2019.00031},
	abstract = {Open source software (OSS) is essential for modern society and, while substantial research has been done on individual (typically central) projects, only a limited understanding of the periphery of the entire OSS ecosystem exists. For example, how are tens of millions of projects in the periphery interconnected through technical dependencies, code sharing, or knowledge ﬂows? To answer such questions we a) create a very large and frequently updated collection of version control data for FLOSS projects named World of Code (WoC) and b) provide basic tools for conducting research that depends on measuring interdependencies among all FLOSS projects. Our current WoC implementation is capable of being updated on a monthly basis and contains over 12B git objects. To evaluate its research potential and to create vignettes for its usage, we employ WoC in conducting several research tasks. In particular, we ﬁnd that it is capable of supporting trend evaluation, ecosystem measurement, and the determination of package usage. We expect WoC to spur investigation into global properties of OSS development leading to increased resiliency of the entire OSS ecosystem. Our infrastructure facilitates the discovery of key technical dependencies, code ﬂow, and social networks that provide the basis to determine the structure and evolution of the relationships that drive FLOSS activities and innovation.},
	language = {en},
	urldate = {2020-08-06},
	booktitle = {2019 {IEEE}/{ACM} 16th {International} {Conference} on {Mining} {Software} {Repositories} ({MSR})},
	publisher = {IEEE},
	author = {Ma, Yuxing and Bogart, Chris and Amreen, Sadika and Zaretzki, Russell and Mockus, Audris},
	month = may,
	year = {2019},
	pages = {143--154},
}

@article{prat_relating_2020,
	title = {Relating {Natural} {Language} {Aptitude} to {Individual} {Differences} in {Learning} {Programming} {Languages}},
	volume = {10},
	copyright = {2020 The Author(s)},
	issn = {2045-2322},
	url = {https://www.nature.com/articles/s41598-020-60661-8},
	doi = {10.1038/s41598-020-60661-8},
	abstract = {This experiment employed an individual differences approach to test the hypothesis that learning modern programming languages resembles second “natural” language learning in adulthood. Behavioral and neural (resting-state EEG) indices of language aptitude were used along with numeracy and fluid cognitive measures (e.g., fluid reasoning, working memory, inhibitory control) as predictors. Rate of learning, programming accuracy, and post-test declarative knowledge were used as outcome measures in 36 individuals who participated in ten 45-minute Python training sessions. The resulting models explained 50–72\% of the variance in learning outcomes, with language aptitude measures explaining significant variance in each outcome even when the other factors competed for variance. Across outcome variables, fluid reasoning and working-memory capacity explained 34\% of the variance, followed by language aptitude (17\%), resting-state EEG power in beta and low-gamma bands (10\%), and numeracy (2\%). These results provide a novel framework for understanding programming aptitude, suggesting that the importance of numeracy may be overestimated in modern programming education environments.},
	language = {en},
	number = {1},
	urldate = {2020-07-22},
	journal = {Scientific Reports},
	author = {Prat, Chantel S. and Madhyastha, Tara M. and Mottarella, Malayka J. and Kuo, Chu-Hsuan},
	month = mar,
	year = {2020},
	note = {Number: 1
Publisher: Nature Publishing Group},
	keywords = {COMP7872},
	pages = {3817},
}

@inproceedings{tew_fcs1_2011,
	address = {Dallas, TX, USA},
	series = {{SIGCSE} '11},
	title = {The {FCS1}: a language independent assessment of {CS1} knowledge},
	isbn = {978-1-4503-0500-6},
	shorttitle = {The {FCS1}},
	url = {https://doi.org/10.1145/1953163.1953200},
	doi = {10.1145/1953163.1953200},
	abstract = {A primary goal of many CS education projects is to determine the extent to which a given intervention has had an impact on student learning. However, computing lacks valid assessments for pedagogical or research purposes. Without such valid assessments, it is difficult to accurately measure student learning or establish a relationship between the instructional setting and learning outcomes. We developed the Foundational CS1 (FCS1) Assessment instrument, the first assessment instrument for introductory computer science concepts that is applicable across a variety of current pedagogies and programming languages. We applied methods from educational and psychological test development, adapting them as necessary to fit the disciplinary context. We conducted a large scale empirical study to demonstrate that pseudo-code was an appropriate mechanism for achieving programming language independence. Finally, we established the validity of the assessment using a multi-faceted argument, combining interview data, statistical analysis of results on the assessment, and CS1 exam scores.},
	urldate = {2020-07-20},
	booktitle = {Proceedings of the 42nd {ACM} technical symposium on {Computer} science education},
	publisher = {Association for Computing Machinery},
	author = {Tew, Allison Elliott and Guzdial, Mark},
	month = mar,
	year = {2011},
	keywords = {COMP7872, CS1, assessment, programming, validity},
	pages = {111--116},
}

@phdthesis{tew_assessing_2010,
	address = {USA},
	type = {phd},
	title = {Assessing fundamental introductory computing concept knowledge in a language independent manner},
	abstract = {Measuring student learning is fundamental to any educational endeavor. A primary goal of many computer science education projects is to determine the extent to which a given instructional intervention has had an impact on student learning. However, the field of computing lacks valid and reliable assessment instruments for pedagogical or research purposes. Without such valid assessments, it is difficult to accurately measure student learning or establish a relationship between the instructional setting and learning outcomes. The goal of assessment research in computer science is to have valid ways of measuring student conceptions of fundamental topics, which will enable both research into how understanding of knowledge in the domain develops as well as enable curricular innovation and reform grounded in this knowledge. My dissertation work focused on three questions regarding assessment of introductory concepts in computer science. How can existing test development methods be applied and adapted to create a valid assessment instrument for CS1 conceptual knowledge\_\_ \_\_ To what extent can pseudo-code be used as the mechanism for achieving programming language independence in an assessment instrument\_\_ \_\_ And to what extent does the language independent instrument provide a valid measure of CS1 conceptual knowledge\_\_ \_\_ I developed the Foundational CS1 (FCS1) Assessment instrument, the first assessment instrument for introductory computer science concepts that is applicable across a variety of current pedagogies and programming languages. I applied methods from educational and psychological test development, adapting them as necessary to fit the disciplinary context. I conducted think aloud interviews and a large scale empirical study to demonstrate that pseudo-code was an appropriate mechanism for achieving programming language independence. Student participants were able to read and reason in the pseudo-code syntax without difficulty and were able to transfer conceptual knowledge from their CS1 programming language to pseudo-code. Finally, I established the validity of the assessment using a multi-faceted argument, combining interview data, statistical analysis of results on the assessment, and exam scores. The contributions of this research are: (1) An example of how to bootstrap the process for developing the first assessment instrument for a disciplinary specific design-based field. (2) Identification that although it may not be possible to correlate scores between computer science exams created with different measurement goals, the validity claims of the individual assessments are not diminished. (3) A demonstration that novice computing students, at an appropriate level of development, can transfer their understanding of fundamental concepts to pseudo-code notation. (4) A valid assessment of introductory computing concepts for procedurally-based introductory computing courses taught in Java, Matlab, or Python at the university level.},
	school = {Georgia Institute of Technology},
	author = {Tew, Allison Elliott},
	year = {2010},
	note = {ISBN-13: 9781124564494},
}

@book{guzdial_learner-centered_2015,
	title = {Learner-{Centered} {Design} of {Computing} {Education}: {Research} on {Computing} for {Everyone}},
	isbn = {978-1-62705-352-5},
	shorttitle = {Learner-{Centered} {Design} of {Computing} {Education}},
	url = {https://ieeexplore.ieee.org/document/7374855},
	abstract = {Computing education is in enormous demand. Many students (both children and adult) are realizing that they will need programming in the future. This book presents the argument that they are not all going to use programming in the same way and for the same purposes. What do we mean when we talk about teaching everyone to program? When we target a broad audience, should we have the same goals as computer science education for professional software developers? How do we design computing education that works for everyone? This book proposes use of a learner-centered design approach to create computing education for a broad audience. It considers several reasons for teaching computing to everyone and how the different reasons lead to different choices about learning goals and teaching methods. The book reviews the history of the idea that programming isn’t just for the professional software developer. It uses research studies on teaching computing in liberal arts programs, to graphic designers, to high school teachers, in order to explore the idea that computer science for everyone requires us to re-think how we teach and what we teach. The conclusion describes how we might create computing education for everyone.},
	urldate = {2020-07-21},
	publisher = {Morgan \& Claypool},
	author = {Guzdial, Mark},
	year = {2015},
	note = {Conference Name: Learner-Centered Design of Computing Education: Research on Computing for Everyone
Publication Title: Learner-Centered Design of Computing Education: Research on Computing for Everyone},
	keywords = {COMP7872, computer science education, computing education, learner-centered design},
}

@inproceedings{swidan_effect_2019,
	address = {Chengdu,Sichuan, China},
	series = {{CompEd} '19},
	title = {The {Effect} of {Reading} {Code} {Aloud} on {Comprehension}: {An} {Empirical} {Study} with {School} {Students}},
	isbn = {978-1-4503-6259-7},
	shorttitle = {The {Effect} of {Reading} {Code} {Aloud} on {Comprehension}},
	url = {https://doi.org/10.1145/3300115.3309504},
	doi = {10.1145/3300115.3309504},
	abstract = {In recent times, programming is increasingly taught to younger students in schools. While learning programming is known to be difficult, we can lighten the learning experience of this age group by adopting pedagogies that are common to them, but not as common in CS education. One of these pedagogies is Reading Aloud (RA), a familiar strategy when young children and beginners start learning how to read in their natural language. RA is linked with a better comprehension of text for beginner readers. We hypothesize that reading code aloud during introductory lessons will lead to better code comprehension. To this end, we design and execute a controlled experiment with the experimental group participants reading the code aloud during the lessons. The participants are 49 primary school students between 9 and 13 years old, who follow three lessons in programming in Python. The lessons are followed by a comprehension assessment based on Bloom's taxonomy. The results show that the students of the experimental group scored significantly higher in the Remembering-level questions compared to the ones in the control group. There is no significant difference between the two groups in their answers to the Understanding-level questions. Furthermore, the participants in both groups followed some of the instructed vocalizations more frequently such as the variable's assignment (is). Vocalizing the indentation spaces in a for -loop was among the least followed. Our paper suggests that using RA for teaching programming in schools will contribute to improving code comprehension with its effect on syntax remembering.},
	urldate = {2020-07-20},
	booktitle = {Proceedings of the {ACM} {Conference} on {Global} {Computing} {Education}},
	publisher = {Association for Computing Machinery},
	author = {Swidan, Alaaeddin and Hermans, Felienne},
	month = may,
	year = {2019},
	keywords = {COMP7872, bloom's taxonomy, primary school, programming education, reading aloud (RA)},
	pages = {178--184},
}

@article{fedorenko_language_2019,
	title = {The {Language} of {Programming}: {A} {Cognitive} {Perspective}},
	volume = {23},
	issn = {1364-6613},
	shorttitle = {The {Language} of {Programming}},
	url = {http://www.sciencedirect.com/science/article/pii/S1364661319301020},
	doi = {10.1016/j.tics.2019.04.010},
	abstract = {Computer programming is becoming essential across fields. Traditionally grouped with science, technology, engineering, and mathematics (STEM) disciplines, programming also bears parallels to natural languages. These parallels may translate into overlapping processing mechanisms. Investigating the cognitive basis of programming is important for understanding the human mind and could transform education practices.},
	language = {en},
	number = {7},
	urldate = {2020-07-21},
	journal = {Trends in Cognitive Sciences},
	author = {Fedorenko, Evelina and Ivanova, Anna and Dhamala, Riva and Bers, Marina Umaschi},
	month = jul,
	year = {2019},
	keywords = {COMP7872, cognitive architecture, computer programming, education policy, language processing},
	pages = {525--528},
}

@incollection{robins_cognitive_2019,
	address = {Cambridge},
	series = {Cambridge {Handbooks} in {Psychology}},
	title = {Cognitive {Sciences} for {Computing} {Education}},
	isbn = {978-1-108-49673-5},
	url = {https://www.cambridge.org/core/books/cambridge-handbook-of-computing-education-research/cognitive-sciences-for-computing-education/319D706EF1A2E8D6A6B8EA7697CE5BE2},
	urldate = {2020-07-21},
	booktitle = {The {Cambridge} {Handbook} of {Computing} {Education} {Research}},
	publisher = {Cambridge University Press},
	author = {Robins, Anthony V. and Margulieux, Lauren E. and Morrison, Briana B.},
	editor = {Robins, Anthony V. and Fincher, Sally A.},
	year = {2019},
	doi = {10.1017/9781108654555.010},
	pages = {231--275},
}

@inproceedings{xie_item_2019,
	address = {Minneapolis, MN, USA},
	series = {{SIGCSE} '19},
	title = {An {Item} {Response} {Theory} {Evaluation} of a {Language}-{Independent} {CS1} {Knowledge} {Assessment}},
	isbn = {978-1-4503-5890-3},
	url = {https://doi.org/10.1145/3287324.3287370},
	doi = {10.1145/3287324.3287370},
	abstract = {Tests serve an important role in computing education, measuring achievement and differentiating between learners with varying knowledge. But tests may have flaws that confuse learners or may be too difficult or easy, making test scores less valid and reliable. We analyzed the Second Computer Science 1 (SCS1) concept inventory, a widely used assessment of introductory computer science (CS1) knowledge, for such flaws. The prior validation study of the SCS1 used Classical Test Theory and was unable to determine whether differences in scores were a result of question properties or learner knowledge. We extended this validation by modeling question difficulty and learner knowledge separately with Item Response Theory (IRT) and performing expert review on problematic questions. We found that three questions measured knowledge that was unrelated to the rest of the SCS1, and four questions were too difficult for our sample of 489 undergrads from two universities.},
	urldate = {2020-07-20},
	booktitle = {Proceedings of the 50th {ACM} {Technical} {Symposium} on {Computer} {Science} {Education}},
	publisher = {Association for Computing Machinery},
	author = {Xie, Benjamin and Davidson, Matthew J. and Li, Min and Ko, Andrew J.},
	month = feb,
	year = {2019},
	keywords = {COMP7872, assessment, concept inventory, cs1, item response theory, validity},
	pages = {699--705},
}

@inproceedings{parker_replication_2016,
	address = {New York, NY, USA},
	series = {{ICER} '16},
	title = {Replication, {Validation}, and {Use} of a {Language} {Independent} {CS1} {Knowledge} {Assessment}},
	isbn = {978-1-4503-4449-4},
	url = {http://doi.acm.org/10.1145/2960310.2960316},
	doi = {10.1145/2960310.2960316},
	abstract = {Computing education lags other discipline-based education research in the number and range of validated assessments available to the research community. Validated assessments are important for researchers to reduce experimental error due to flawed assessments and to allow for comparisons between different experiments. Although the need is great, building assessments from scratch is difficult. Once an assessment is built, it's important to be able to replicate it, in order to address problems within it, or to extend it. We developed the Second CS1 Assessment (SCS1) as an isomorphic version of a previously validated language-independent assessment for introductory computer science, the FCS1. Replicating the FCS1 is important to enable free use by a broader research community. This paper is documentation of our process for replicating an existing validated assessment and validating the success of our replication. We present initial use of SCS1 by other research groups, to serve as examples of where it might be used in the future. SCS1 is useful for researchers, but care must be taken to avoid undermining the validity argument.},
	urldate = {2018-04-24},
	booktitle = {Proceedings of the 2016 {ACM} {Conference} on {International} {Computing} {Education} {Research}},
	publisher = {ACM},
	author = {Parker, Miranda C. and Guzdial, Mark and Engleman, Shelly},
	year = {2016},
	keywords = {COMP7872, CS1, assessment, replication, validity},
	pages = {93--101},
}

@article{quille_cs1_2019,
	title = {{CS1}: how will they do? {How} can we help? {A} decade of research and practice},
	volume = {29},
	issn = {0899-3408, 1744-5175},
	shorttitle = {{CS1}},
	url = {https://www.tandfonline.com/doi/full/10.1080/08993408.2019.1612679},
	doi = {10.1080/08993408.2019.1612679},
	abstract = {Background and Context: Computer Science attrition rates (in the western world) are very concerning, with a large number of students failing to progress each year. It is well acknowledged that a signiﬁcant factor of this attrition, is the students’ diﬃculty to master the introductory programming module, often referred to as CS1.},
	language = {en},
	number = {2-3},
	urldate = {2020-07-11},
	journal = {Computer Science Education},
	author = {Quille, Keith and Bergin, Susan},
	month = jul,
	year = {2019},
	pages = {254--282},
}

@article{morrison_curious_2020,
	title = {The curious case of loops},
	volume = {30},
	issn = {0899-3408, 1744-5175},
	url = {https://www.tandfonline.com/doi/full/10.1080/08993408.2019.1707544},
	doi = {10.1080/08993408.2019.1707544},
	abstract = {Background and Context: Subgoal labeled worked examples have been extensively researched, but the research has been reported piecemeal. This paper aggregates data from three studies, including data previously unreported, to holistically examine the eﬀect of subgoal labeled worked examples across three student populations and across diﬀerent instructional designs.},
	language = {en},
	number = {2},
	urldate = {2020-07-11},
	journal = {Computer Science Education},
	author = {Morrison, Briana B. and Margulieux, Lauren E. and Decker, Adrienne},
	month = apr,
	year = {2020},
	pages = {127--154},
}

@article{martinez_efficient_2020,
	title = {Efficient plagiarism detection for software modeling assignments},
	volume = {30},
	issn = {0899-3408, 1744-5175},
	url = {https://www.tandfonline.com/doi/full/10.1080/08993408.2020.1711495},
	doi = {10.1080/08993408.2020.1711495},
	abstract = {Background and Context: Reports suggest plagiarism is a common occurrence in universities. While plagiarism detection mechanisms exist for textual artifacts, this is less so for non-code related ones such as software design artifacts like models, metamodels or model transformations.},
	language = {en},
	number = {2},
	urldate = {2020-07-11},
	journal = {Computer Science Education},
	author = {Martínez, Salvador and Wimmer, Manuel and Cabot, Jordi},
	month = apr,
	year = {2020},
	pages = {187--215},
}

@article{ciftci_effect_2020,
	title = {The effect of coding courses on the cognitive abilities and problem-solving skills of preschool children},
	volume = {30},
	issn = {0899-3408, 1744-5175},
	url = {https://www.tandfonline.com/doi/full/10.1080/08993408.2019.1696169},
	doi = {10.1080/08993408.2019.1696169},
	abstract = {Background and Context: There are studies which indicate that computer programming supports high-level abilities for everyone such as creative thinking, questioning, problem solving and critical thinking which are considered within the scope of 21st-century abilities.},
	language = {en},
	number = {1},
	urldate = {2020-07-11},
	journal = {Computer Science Education},
	author = {Çiftci, Serdar and Bildiren, Ahmet},
	month = jan,
	year = {2020},
	pages = {3--21},
}

@article{campe_pair_2020,
	title = {Pair programming in middle school: variations in interactions and behaviors},
	volume = {30},
	issn = {0899-3408, 1744-5175},
	shorttitle = {Pair programming in middle school},
	url = {https://www.tandfonline.com/doi/full/10.1080/08993408.2019.1648119},
	doi = {10.1080/08993408.2019.1648119},
	abstract = {Background and Context: Pair programming is used in classrooms to promote learning and engage a more diverse group of students in computing ﬁelds, but little is known about what it looks like in middle school.},
	language = {en},
	number = {1},
	urldate = {2020-07-11},
	journal = {Computer Science Education},
	author = {Campe, Shannon and Denner, Jill and Green, Emily and Torres, David},
	month = jan,
	year = {2020},
	pages = {22--46},
}

@article{borge_embedded_2020,
	title = {Embedded design: engaging students as active participants in the learning of human-centered design practices},
	volume = {30},
	issn = {0899-3408},
	shorttitle = {Embedded design},
	url = {https://doi.org/10.1080/08993408.2019.1688592},
	doi = {10.1080/08993408.2019.1688592},
	abstract = {Background and Context: in this paper, we argue that integrating Human-Computer Interaction (HCI) into K-12 computing education can present learners with opportunities to develop human-centered design skills as well as higher-order thinking skills.Objective: to address the issues related to the development of HCI forms of expertise, we introduce an approach, called embedded design, which extends cognitive apprenticeship methods.Method: we present case studies to illustrate the embedded design approach.Findings: six principles were drawn from the case studies, to inform the implementation of the embedded design approach. Three principles address learners as agents, actively participating in domain thinking processes, and three principles address facilitators as learning designers, orchestrating the co-construction of knowledge.Implications: embedded design provides concrete guidance for implementation to help learners to improve their own thinking processes and succeed in computing education fields, but more research is needed to extend what is known about these complex learning contexts.},
	number = {1},
	urldate = {2020-07-11},
	journal = {Computer Science Education},
	author = {Borge, Marcela and Toprani, Dhvani and Yan, Shulong and Xia, Yu},
	month = jan,
	year = {2020},
	note = {Publisher: Routledge
\_eprint: https://doi.org/10.1080/08993408.2019.1688592},
	keywords = {Correction, HCI education, K-12 education, design thinking, human-centered design, informal learning, instructional methods},
	pages = {47--71},
}

@misc{noauthor_disjoint_nodate,
	title = {Disjoint intersection types {\textbar} {Proceedings} of the 21st {ACM} {SIGPLAN} {International} {Conference} on {Functional} {Programming}},
	url = {https://dl.acm.org/doi/10.1145/2951913.2951945},
	urldate = {2020-07-03},
}

@misc{microsoft_pattern_2019,
	title = {Pattern {Matching} in {C}\#},
	url = {https://docs.microsoft.com/en-us/dotnet/csharp/pattern-matching},
	author = {Microsoft},
	year = {2019},
}

@misc{noauthor_pattern_nodate,
	title = {Pattern {Matching} for {Java}},
	url = {https://cr.openjdk.java.net/~briangoetz/amber/pattern-match.html},
	urldate = {2020-07-02},
}

@misc{noauthor_pep_nodate,
	title = {{PEP} 622 -- {Structural} {Pattern} {Matching} {\textbar} {Python}.org},
	url = {https://www.python.org/dev/peps/pep-0622/},
	urldate = {2020-07-02},
}

@incollection{remy_type_1994,
	address = {Cambridge, MA, USA},
	title = {Type inference for records in natural extension of {ML}},
	isbn = {978-0-262-07155-0},
	urldate = {2020-06-28},
	booktitle = {Theoretical aspects of object-oriented programming: types, semantics, and language design},
	publisher = {MIT Press},
	author = {Rémy, Didier},
	month = aug,
	year = {1994},
	pages = {67--95},
}

@misc{noauthor_abstracting_nodate,
	title = {Abstracting extensible data types: or, rows by any other name {\textbar} {Proceedings} of the {ACM} on {Programming} {Languages}},
	url = {https://dl.acm.org/doi/10.1145/3290325},
	urldate = {2020-06-29},
}

@inproceedings{leijen_extensible_2005,
	title = {Extensible records with scoped labels},
	url = {https://www.microsoft.com/en-us/research/publication/extensible-records-with-scoped-labels/},
	abstract = {Records provide a safe and flexible way to construct data structures. We describe a natural approach to typing polymorphic and extensible records that is simple, easy to use in practice, and straightforward to implement. A novel aspect of this work is that records can contain duplicate labels, effectively introducing a form of scoping over the labels. Furthermore, it is a fully orthogonal extension to existing type systems and programming languages. In particular, we show how it can be used conveniently with standard Hindley-Milner, qualified types, and ML-F. The records are implemented in the experimental Morrow interpreter. There is separate technical report that gives the constructive proofs of soundness and completeness.},
	booktitle = {Proceedings of the 2005 {Symposium} on {Trends} in {Functional} {Programming} ({TFP}'05), {Tallin}, {Estonia}},
	author = {Leijen, Daan},
	month = sep,
	year = {2005},
	note = {Edition: Proceedings of the 2005 Symposium on Trends in Functional Programming (TFP'05), Tallin, Estonia},
}

@inproceedings{cardelli_operations_1990,
	address = {New York, NY},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Operations on records},
	isbn = {9780387348087},
	doi = {10.1007/BFb0040253},
	abstract = {We define a simple collection of operations for creating and manipulating record structures, where records are intended as finite associations of values to labels. A second-order type system over these operations supports both subtyping and polymorphism. We provide typechecking algorithms and limited semantic models.Our approach unifies and extends previous notions of records, bounded quantification, record extension, and parametrization by row-variables. The general aim is to provide foundations for concepts found in object-oriented languages, within a framework based on typed lambda-calculus.},
	language = {en},
	booktitle = {Mathematical {Foundations} of {Programming} {Semantics}},
	publisher = {Springer},
	author = {Cardelli, Luca and Mitchell, John C.},
	editor = {Main, M. and Melton, A. and Mislove, M. and Schmidt, D.},
	year = {1990},
	keywords = {Inference Rule , Subtype Relation , Type Inference , Type Rule , Type System },
	pages = {22--52},
}

@inproceedings{wand_complete_1987,
	title = {Complete {Type} {Inference} for {Simple} {Objects}},
	url = {http://www.ccs.neu.edu/home/wand/papers/wand-lics-87.pdf},
	urldate = {2020-06-29},
	booktitle = {Proceedings of the {Symposium} on {Logic} in {Computer} {Science} ({LICS} '87), {Ithaca}, {New} {York}, {USA}, {June} 22-25, 1987},
	publisher = {IEEE Computer Society},
	author = {Wand, Mitchell},
	year = {1987},
	keywords = {invention},
	pages = {37--44},
}

@misc{noauthor_zotero_nodate,
	title = {Zotero {\textbar} {Downloads}},
	url = {https://www.zotero.org/download/},
	urldate = {2020-06-29},
}

@misc{noauthor_zotero_nodate-1,
	title = {Zotero {\textbar} {Downloads}},
	url = {https://www.zotero.org/download/},
	urldate = {2020-06-29},
}

@inproceedings{van_deursen_building_1999,
	title = {Building documentation generators},
	doi = {10.1109/ICSM.1999.792497},
	abstract = {In order to maintain the consistency between sources and documentation, while at the same time providing documentation at the design level, it is necessary to generate documentation from sources in such a way that it can be integrated with hand-written documentation. In order to simplify the construction of documentation generators, we introduce island grammars, which only define those syntactic structures needed for (re)documentation purposes. We explain how they can be used to obtain various forms of documentation, such as data dependency diagrams for mainframe batch jobs. Moreover, we discuss how the derived information can be made available via a hypertext structure. We conclude with an industrial case study in which a 600,000 LOC COBOL legacy system is redocumented using the techniques presented in the paper.},
	booktitle = {Proceedings {IEEE} {International} {Conference} on {Software} {Maintenance} - 1999 ({ICSM}'99). '{Software} {Maintenance} for {Business} {Change}' ({Cat}. {No}.{99CB36360})},
	author = {Van Deursen, A. and Kuipers, T.},
	year = {1999},
	note = {ISSN: 1063-6773},
	keywords = {000 LOC COBOL legacy system, 600, Cost function, Documentation, Lab-on-a-chip, Outsourcing, Read only memory, data dependency diagrams, design level, documentation generators, grammars, hand-written documentation, hypermedia, hypertext structure, island grammars, mainframe batch jobs, redocumentation, syntactic structures, system documentation},
	pages = {40--49},
}

@article{xie_row_2020,
	title = {Row and {Bounded} {Polymorphism} via {Disjoint} {Polymorphism}},
	abstract = {Polymorphism and subtyping are important features in mainstream OO languages. The most common way to integrate the two is via F{\textless}: style bounded quantiﬁcation. A closely related mechanism is row polymorphism, which provides an alternative to subtyping, while still enabling many of the same applications. Yet another approach is to have type systems with intersection types and polymorphism. A recent addition to this design space are calculi with disjoint intersection types and disjoint polymorphism. With all these alternatives it is natural to wonder how they are related.},
	language = {en},
	author = {Xie, Ningning},
	year = {2020},
	pages = {40},
}

@inproceedings{moonen_generating_2001,
	title = {Generating robust parsers using island grammars},
	doi = {10.1109/WCRE.2001.957806},
	abstract = {Source model extraction, the automated extraction of information from system artifacts, is a common phase in reverse engineering tools. One of the major challenges of this phase is creating extractors that can deal with irregularities in the artifacts that are typical for the reverse engineering domain (for example, syntactic errors, incomplete source code, language dialects and embedded languages). The paper proposes a solution in the form of island grammars, a special kind of grammar that combines the detailed specification possibilities of grammars with the liberal behavior of lexical approaches. We show how island grammars can be used to generate robust parsers that combine the accuracy of syntactical analysis with the speed, flexibility and tolerance usually only found in lexical analysis. We conclude with a discussion of the development of MANGROVE, a generator for source model extractors based on island grammars and describe its application to a number of case studies.},
	booktitle = {Proceedings {Eighth} {Working} {Conference} on {Reverse} {Engineering}},
	author = {Moonen, L.},
	year = {2001},
	note = {ISSN: 1095-1350},
	keywords = {Application software, Computer languages, Data mining, Libraries, MANGROVE, Maintenance engineering, Mars, Reverse engineering, Robustness, Software maintenance, Transaction databases, automated information extraction, case studies, computational linguistics, detailed specification, embedded languages, fuzzy parsing, grammars, incomplete source code, island grammars, language dialects, lexical approaches, parser generation, partial parsing, program analysis, program compilers, reverse engineering, reverse engineering domain, reverse engineering tools, robust parser generation, robust parsers, source model extraction, source model extractors, syntactic errors, syntactical analysis, system artifacts},
	pages = {13--22},
}

@article{noauthor_download_nodate,
	title = {download},
}

@article{post_island_nodate,
	title = {Island {Grammars} in {ASF}+{SDF}},
	language = {en},
	author = {Post, Erik},
	pages = {132},
}

@misc{noauthor_ki0o1azwvnolngkc4cbocnxtl1cx99rybvu1jccaoiijpg_nodate,
	title = {{Ki0o1AZwvNoLNgkC4CbocNXTL1Cx99RYBVU1JcCaoII}.jpg ({WEBP} {Image}, 4018 × 3242 pixels) - {Scaled} (21\%)},
	url = {https://external-preview.redd.it/Ki0o1AZwvNoLNgkC4CbocNXTL1Cx99RYBVU1JcCaoII.jpg?auto=webp&s=fb07f58ffbf1869f716a383b29300e7e5072459c},
	urldate = {2020-04-19},
}

@misc{noauthor_wood_nodate,
	title = {Wood {Pellet} {Test}: {Is} {Bottom} up {Ventilation} {Best}? {Firebox} {Stove}.},
	shorttitle = {Wood {Pellet} {Test}},
	url = {https://www.youtube.com/watch?v=B6xRaQPos3A},
	abstract = {Wood Pellet Test: Is Bottom up Ventilation Best? Firebox Stove.

Contact us: info@fireboxstove.com
Purchase products here: https://www.fireboxstove.com/index.ph...

I have been Using Wood Pellets in my Firebox quite a bit lately and have wondered how big of a difference the bottom up ventilation makes in performance and inefficiency.
So this test compares two Firebox set ups, one with the bottom ventilation closed and one open. The results are interesting, but was what I was expecting.
 The firebox with the ventilation open burned hotter \&amp; faster until all the fuel was consumed then the hot coals continued to stay at a cooking temperature for quite a while.
 The Firebox with the closed ventilation burned slower and lasted longer but went cold abruptly before all the fuel was gone because it didn't maintain hot coals.
I used a QuickStove fuel disk to get the Wood Pellets started.},
	urldate = {2020-03-31},
}

@misc{noauthor_definition_nodate,
	title = {The {Definition} of {Standard} {ML}: {Revised} - {Robin} {Milner}, {Mads} {Tofte}, {Robert} {Harper}, {David} {MacQueen} - {Google} {Books}},
	url = {https://books.google.com.au/books?hl=en&lr=&id=e0PhKfbj-p8C&oi=fnd&pg=PR9&ots=TlQVcUwddq&sig=_BP8IgsZx6lOEgzFwO_HYu-u7kY&redir_esc=y#v=onepage&q&f=false},
	urldate = {2019-11-21},
}

@book{kernighan_c_1988,
	edition = {2nd},
	title = {The {C} {Programming} {Language}},
	isbn = {9780131103702},
	abstract = {From the Publisher:This second editon describes C as defined by the ANSI standard. This book is meant to help the reader learn how to program in C. The book assumes some familiarity with basic programming concepts like variables, assignment statements, loops, and functions. A novice programmer should be able to read along and pick up the language.  FEATURES:   All examples have been tested, which is in machine-readable form. It discusses various aspects of C in more detail, although the emphasis is on examples of complete programs, rather than isolated fragments. It deals with basic data types, operators and expressions. Covers functions and program structure, external variables, scope rules, multiple source files, and also touches on the preprocessor.  It also describes an interface between C programs and the UNIX operating system, concentrating on input/output, the file system, and storage allocation. It also provides a language reference manual. The official statement of the syntax and semantics of C is the ANSI standard.},
	publisher = {Prentice Hall Professional Technical Reference},
	author = {Kernighan, Brian W.},
	editor = {Ritchie, Dennis M.},
	year = {1988},
}

@inproceedings{maranget_compiling_2008,
	address = {New York, NY, USA},
	series = {{ML} '08},
	title = {Compiling {Pattern} {Matching} to {Good} {Decision} {Trees}},
	isbn = {9781605580623},
	url = {http://doi.acm.org/10.1145/1411304.1411311},
	doi = {10.1145/1411304.1411311},
	abstract = {We address the issue of compiling ML pattern matching to compact and efficient decisions trees. Traditionally, compilation to decision trees is optimized by (1) implementing decision trees as dags with maximal sharing; (2) guiding a simple compiler with heuristics. We first design new heuristics that are inspired by necessity, a concept from lazy pattern matching that we rephrase in terms of decision tree semantics. Thereby, we simplify previous semantic frameworks and demonstrate a straightforward connection between necessity and decision tree runtime efficiency. We complete our study by experiments, showing that optimizing compilation to decision trees is competitive with the optimizing match compiler of Le Fessant and Maranget (2001).},
	urldate = {2019-10-19},
	booktitle = {Proceedings of the 2008 {ACM} {SIGPLAN} {Workshop} on {ML}},
	publisher = {ACM},
	author = {Maranget, Luc},
	year = {2008},
	note = {event-place: Victoria, BC, Canada},
	keywords = {decision trees, heuristics, match compilers},
	pages = {35--46},
}

@inproceedings{augustsson_compiling_1985,
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Compiling pattern matching},
	isbn = {9783540396772},
	language = {en},
	booktitle = {Functional {Programming} {Languages} and {Computer} {Architecture}},
	publisher = {Springer Berlin Heidelberg},
	author = {Augustsson, Lennart},
	editor = {Jouannaud, Jean-Pierre},
	year = {1985},
	keywords = {Expression Sequence , Pattern Match , Pattern Sequence , Recursive Call , Simple Pattern },
	pages = {368--381},
}

@misc{noauthor_zotero_nodate-2,
	title = {Zotero {\textbar} {Downloads}},
	url = {https://www.zotero.org/download/},
	urldate = {2019-10-19},
}

@inproceedings{wadler_views:_1987,
	address = {New York, NY, USA},
	series = {{POPL} '87},
	title = {Views: {A} {Way} for {Pattern} {Matching} to {Cohabit} with {Data} {Abstraction}},
	isbn = {978-0-89791-215-0},
	shorttitle = {Views},
	url = {http://doi.acm.org/10.1145/41625.41653},
	doi = {10.1145/41625.41653},
	abstract = {Pattern matching and data abstraction are important concepts in designing programs, but they do not fit well together. Pattern matching depends on making public a free data type representation, while data abstraction depends on hiding the representation. This paper proposes the views mechanism as a means of reconciling this conflict. A view allows any type to be viewed as a free data type, thus combining the clarity of pattern matching with the efficiency of data abstraction.},
	urldate = {2019-02-18},
	booktitle = {Proceedings of the 14th {ACM} {SIGACT}-{SIGPLAN} {Symposium} on {Principles} of {Programming} {Languages}},
	publisher = {ACM},
	author = {Wadler, P.},
	year = {1987},
	note = {event-place: Munich, West Germany},
	pages = {307--313},
}

@article{pretnar_introduction_nodate,
	title = {An {Introduction} to {Algebraic} {Effects} and {Handlers}.  {Invited} tutorial paper},
	author = {Pretnar, Matija},
}

@inproceedings{tullsen_first_2000,
	title = {First {Class} {Patterns}},
	abstract = {. Pattern matching is a great convenience in programming. However, pattern matching has its problems: it conicts with data abstraction; it is complex (at least in Haskell, which has pattern guards, irrefutable patterns, n+k patterns, as patterns, etc.); it is a source of runtime errors; and lastly, one cannot abstract over patterns as they are not a rst class language construct. This paper proposes a simplication of pattern matching that makes patterns rst class. The key idea is to treat patterns as functions of type a!Maybe bi.e., a!(Nothing{\textbar}Just b);  thus, patterns and pattern combinators can be written as functions in the language. 1 Introduction A hotly debated issue in the language Haskell [HJW92] has been patterns. What are their semantics? Do we want n+1 patterns? Do we need @-patterns? When do we match lazily and when do we match strictly? Do we need to extend patterns with pattern guards? And etc. In this paper I will propose, not another extension, but a simplicat...},
	booktitle = {In 2nd {International} {Workshop} on {Practial} {Aspects} of {Declarative} {Languages}, volume 1753 of {LNCS}},
	publisher = {Springer-Verlag},
	author = {Tullsen, Mark},
	year = {2000},
	pages = {1--15},
}

@misc{noauthor_first_nodate,
	title = {First {Class} {Patterns}? {\textbar} {SpringerLink}},
	url = {https://link.springer.com/chapter/10.1007/3-540-46584-7_1},
	urldate = {2019-01-31},
}

@article{brotherston_complexity_2018,
	title = {On the {Complexity} of {Pointer} {Arithmetic} in {Separation} {Logic} (an extended version)},
	url = {http://arxiv.org/abs/1803.03164},
	abstract = {We investigate the complexity consequences of adding pointer arithmetic to separation logic. Speciﬁcally, we study extensions of the points-to fragment of symbolic-heap separation logic with various forms of Presburger arithmetic constraints.},
	language = {en},
	urldate = {2018-12-01},
	journal = {arXiv:1803.03164 [cs]},
	author = {Brotherston, James and Kanovich, Max},
	month = mar,
	year = {2018},
	note = {arXiv: 1803.03164},
	keywords = {Computer Science - Logic in Computer Science},
}

@article{egi_non-linear_2018,
	title = {Non-linear {Pattern} {Matching} with {Backtracking} for {Non}-free {Data} {Types}},
	url = {http://arxiv.org/abs/1808.10603},
	abstract = {Non-free data types are data types whose data have no canonical forms. For example, multisets are non-free data types because the multiset \{a, b, b\} has two other equivalent but literally diﬀerent forms \{b, a, b\} and \{b, b, a\}. Pattern matching is known to provide a handy tool set to treat such data types. Although many studies on pattern matching and implementations for practical programming languages have been proposed so far, we observe that none of these studies satisfy all the criteria of practical pattern matching, which are as follows: i) eﬃciency of the backtracking algorithm for non-linear patterns, ii) extensibility of matching process, and iii) polymorphism in patterns.},
	language = {en},
	urldate = {2018-12-01},
	journal = {arXiv:1808.10603 [cs]},
	author = {Egi, Satoshi and Nishiwaki, Yuichi},
	month = aug,
	year = {2018},
	note = {arXiv: 1808.10603},
	keywords = {Computer Science - Programming Languages},
}

@article{kunze_formal_2018,
	title = {Formal {Small}-step {Verification} of a {Call}-by-value {Lambda} {Calculus} {Machine}},
	volume = {11275},
	url = {http://arxiv.org/abs/1806.03205},
	doi = {10.1007/978-3-030-02768-1_15},
	abstract = {We formally verify an abstract machine for a call-by-value λ-calculus with de Bruijn terms, simple substitution, and small-step semantics. We follow a stepwise reﬁnement approach starting with a naive stack machine with substitution. We then reﬁne to a machine with closures, and ﬁnally to a machine with a heap providing structure sharing for closures. We prove the correctness of the three reﬁnement steps with compositional small-step bottom-up simulations. There is an accompanying Coq development verifying all results.},
	language = {en},
	urldate = {2018-12-01},
	journal = {arXiv:1806.03205 [cs]},
	author = {Kunze, Fabian and Smolka, Gert and Forster, Yannick},
	year = {2018},
	note = {arXiv: 1806.03205},
	keywords = {Computer Science - Logic in Computer Science, Computer Science - Programming Languages},
	pages = {264--283},
}

@article{noauthor_after_nodate,
	title = {After the gold rush: {Toward} {Sustainable} {Scholarship} in {Computing}},
}

@inproceedings{boustedt_threshold_2007,
	address = {New York, NY, USA},
	series = {{SIGCSE} '07},
	title = {Threshold {Concepts} in {Computer} {Science}: {Do} {They} {Exist} and {Are} {They} {Useful}?},
	isbn = {1-59593-361-1},
	shorttitle = {Threshold {Concepts} in {Computer} {Science}},
	url = {http://doi.acm.org/10.1145/1227310.1227482},
	doi = {10.1145/1227310.1227482},
	abstract = {Yes, and Yes.We are currently undertaking an pirical investigation of "Threshold Concepts" in Computer Science, with input from both instructors and students. We have found good pirical evidence that at least two concepts---Object-oriented programming and pointers--are Threshold Concepts, and that there are potentially many more others.In this paper, we present results gathered using various experimental techniques, and discuss how Threshold Concepts can affect the learning process.},
	urldate = {2018-04-10},
	booktitle = {Proceedings of the 38th {SIGCSE} {Technical} {Symposium} on {Computer} {Science} {Education}},
	publisher = {ACM},
	author = {Boustedt, Jonas and Eckerdal, Anna and McCartney, Robert and Moström, Jan Erik and Ratcliffe, Mark and Sanders, Kate and Zander, Carol},
	year = {2007},
	keywords = {learning theory, threshold concepts},
	pages = {504--508},
}

@article{fu_taintassembly:_2018,
	title = {{TaintAssembly}: {Taint}-{Based} {Information} {Flow} {Control} {Tracking} for {WebAssembly}},
	shorttitle = {{TaintAssembly}},
	url = {https://arxiv.org/abs/1802.01050},
	language = {en},
	urldate = {2018-03-09},
	author = {Fu, William and Lin, Raymond and Inge, Daniel},
	month = feb,
	year = {2018},
}

@article{hartmanis_turing_1994,
	title = {Turing {Award} {Lecture} on {Computational} {Complexity} and the {Nature} of {Computer} {Science}},
	volume = {37},
	issn = {0001-0782},
	url = {http://doi.acm.org/10.1145/194313.214781},
	doi = {10.1145/194313.214781},
	number = {10},
	urldate = {2018-03-02},
	journal = {Commun. ACM},
	author = {Hartmanis, Juris},
	month = oct,
	year = {1994},
	pages = {37--43},
}

@article{bennedsen_abstraction_2006,
	title = {Abstraction {Ability} {As} an {Indicator} of {Success} for {Learning} {Object}-oriented {Programming}?},
	volume = {38},
	issn = {0097-8418},
	url = {http://doi.acm.org/10.1145/1138403.1138430},
	doi = {10.1145/1138403.1138430},
	abstract = {Computer science educators generally agree that abstract thinking is a crucial component for learning computer science in general and programming in particular. We report on a study to confirm the hypothesis that general abstraction ability has a positive impact on programming ability. Abstraction ability is operationalized as stages of cognitive development (for which validated tests exist). Programming ability is operationalized as grade in the final assessment of a model-based objects-first CS1. The validity of the operationalizations is discussed. Surprisingly, our study shows that there is no correlation between stage of cognitive development (abstraction ability) and final grade in CS1 (programming ability). Possible explanations are identified.},
	number = {2},
	urldate = {2018-03-02},
	journal = {SIGCSE Bull.},
	author = {Bennedsen, Jens and Caspersen, Michael E.},
	month = jun,
	year = {2006},
	keywords = {CS1, abstraction, model-based programming, objects-first, success factors},
	pages = {39--43},
}

@article{sorva_notional_2013,
	title = {Notional {Machines} and {Introductory} {Programming} {Education}},
	volume = {13},
	issn = {1946-6226},
	url = {http://doi.acm.org/10.1145/2483710.2483713},
	doi = {10.1145/2483710.2483713},
	abstract = {This article brings together, summarizes, and comments on several threads of research that have contributed to our understanding of the challenges that novice programmers face when learning about the runtime dynamics of programs and the role of the computer in program execution. More specifically, the review covers the literature on programming misconceptions, the cognitive theory of mental models, constructivist theory of knowledge and learning, phenomenographic research on experiencing programming, and the theory of threshold concepts. These bodies of work are examined in relation to the concept of a “notional machine”—an abstract computer for executing programs of a particular kind. As a whole, the literature points to notional machines as a major challenge in introductory programming education. It is argued that instructors should acknowledge the notional machine as an explicit learning objective and address it in teaching. Teaching within some programming paradigms, such as object-oriented programming, may benefit from using multiple notional machines at different levels of abstraction. Pointers to some promising pedagogical techniques are provided.},
	number = {2},
	urldate = {2018-03-02},
	journal = {Trans. Comput. Educ.},
	author = {Sorva, Juha},
	month = jul,
	year = {2013},
	keywords = {CS1, Notional machine, constructivism, introductory programming education, literature review, mental models, misconceptions, phenomenography, threshold concepts},
	pages = {8:1--8:31},
}

@inproceedings{calcagno_separation_2005,
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {From {Separation} {Logic} to {First}-{Order} {Logic}},
	isbn = {978-3-540-25388-4, 978-3-540-31982-5},
	url = {https://link.springer.com/chapter/10.1007/978-3-540-31982-5_25},
	doi = {10.1007/978-3-540-31982-5_25},
	abstract = {Separation logic is a spatial logic for reasoning locally about heap structures. A decidable fragment of its assertion language was presented in [1], based on a bounded model property. We exploit this property to give an encoding of this fragment into a first-order logic containing only the propositional connectives, quantification over the natural numbers and equality. This result is the first translation from Separation Logic into a logic which does not depend on the heap, and provides a direct decision procedure based on well-studied algorithms for first-order logic. Moreover, our translation is compositional in the structure of formulae, whilst previous results involved enumerating either heaps or formulae arising from the bounded model property.},
	language = {en},
	urldate = {2018-03-01},
	booktitle = {Foundations of {Software} {Science} and {Computational} {Structures}},
	publisher = {Springer, Berlin, Heidelberg},
	author = {Calcagno, Cristiano and Gardner, Philippa and Hague, Matthew},
	month = apr,
	year = {2005},
	pages = {395--409},
}

@article{mayer_psychology_1981,
	title = {The {Psychology} of {How} {Novices} {Learn} {Computer} {Programming}},
	volume = {13},
	issn = {0360-0300},
	url = {http://doi.acm.org/10.1145/356835.356841},
	doi = {10.1145/356835.356841},
	number = {1},
	urldate = {2018-02-28},
	journal = {ACM Comput. Surv.},
	author = {Mayer, Richard E.},
	month = mar,
	year = {1981},
	pages = {121--141},
}

@inproceedings{haas_bringing_2017,
	address = {New York, NY, USA},
	series = {{PLDI} 2017},
	title = {Bringing the {Web} {Up} to {Speed} with {WebAssembly}},
	isbn = {978-1-4503-4988-8},
	url = {http://doi.acm.org/10.1145/3062341.3062363},
	doi = {10.1145/3062341.3062363},
	abstract = {The maturation of the Web platform has given rise to sophisticated and demanding Web applications such as interactive 3D visualization, audio and video software, and games. With that, efficiency and security of code on the Web has become more important than ever. Yet JavaScript as the only built-in language of the Web is not well-equipped to meet these requirements, especially as a compilation target.   Engineers from the four major browser vendors have risen to the challenge and collaboratively designed a portable low-level bytecode called WebAssembly. It offers compact representation, efficient validation and compilation, and safe low to no-overhead execution. Rather than committing to a specific programming model, WebAssembly is an abstraction over modern hardware, making it language-, hardware-, and platform-independent, with use cases beyond just the Web. WebAssembly has been designed with a formal semantics from the start. We describe the motivation, design and formal semantics of WebAssembly and provide some preliminary experience with implementations.},
	urldate = {2018-02-23},
	booktitle = {Proceedings of the 38th {ACM} {SIGPLAN} {Conference} on {Programming} {Language} {Design} and {Implementation}},
	publisher = {ACM},
	author = {Haas, Andreas and Rossberg, Andreas and Schuff, Derek L. and Titzer, Ben L. and Holman, Michael and Gohman, Dan and Wagner, Luke and Zakai, Alon and Bastien, JF},
	year = {2017},
	keywords = {assembly languages, just-in-time compilers, programming languages, type systems, virtual machines},
	pages = {185--200},
}

@inproceedings{perez_separation_2013,
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Separation {Logic} {Modulo} {Theories}},
	isbn = {978-3-319-03541-3, 978-3-319-03542-0},
	url = {https://link.springer.com/chapter/10.1007/978-3-319-03542-0_7},
	doi = {10.1007/978-3-319-03542-0_7},
	abstract = {Logical reasoning about program behaviours often requires dealing with heap structures as well as scalar data types. Advances in Satisfiability Modulo Theories (SMT) offer efficient procedures for dealing with scalar values, yet they lack expressive support for dealing with heap structures. In this paper, we present an approach that integrates separation logic–a prominent logic for reasoning about linked data structures on the heap–and existing SMT solving technology. Our model-based approach communicates heap aliasing information between theory and separation logic reasoning, providing an efficient decision procedure for discharging verification conditions in program analysis and verification.},
	language = {en},
	urldate = {2018-01-23},
	booktitle = {Programming {Languages} and {Systems}},
	publisher = {Springer, Cham},
	author = {Pérez, Juan Antonio Navarro and Rybalchenko, Andrey},
	month = dec,
	year = {2013},
	pages = {90--106},
}

@inproceedings{piskac_automating_2013,
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Automating {Separation} {Logic} {Using} {SMT}},
	isbn = {978-3-642-39798-1, 978-3-642-39799-8},
	url = {https://link.springer.com/chapter/10.1007/978-3-642-39799-8_54},
	doi = {10.1007/978-3-642-39799-8_54},
	abstract = {Separation logic (SL) has gained widespread popularity because of its ability to succinctly express complex invariants of a program’s heap configurations. Several specialized provers have been developed for decidable SL fragments. However, these provers cannot be easily extended or combined with solvers for other theories that are important in program verification, e.g., linear arithmetic. In this paper, we present a reduction of decidable SL fragments to a decidable first-order theory that fits well into the satisfiability modulo theories (SMT) framework. We show how to use this reduction to automate satisfiability, entailment, frame inference, and abduction problems for separation logic using SMT solvers. Our approach provides a simple method of integrating separation logic into existing verification tools that provide SMT backends, and an elegant way of combining SL fragments with other decidable first-order theories. We implemented this approach in a verification tool and applied it to heap-manipulating programs whose verification involves reasoning in theory combinations.},
	language = {en},
	urldate = {2018-01-23},
	booktitle = {Computer {Aided} {Verification}},
	publisher = {Springer, Berlin, Heidelberg},
	author = {Piskac, Ruzica and Wies, Thomas and Zufferey, Damien},
	month = jul,
	year = {2013},
	pages = {773--789},
}

@inproceedings{reynolds_decision_2016,
	title = {A decision procedure for separation logic in {SMT}},
	booktitle = {International {Symposium} on {Automated} {Technology} for {Verification} and {Analysis}},
	publisher = {Springer},
	author = {Reynolds, Andrew and Iosif, Radu and Serban, Cristina and King, Tim},
	year = {2016},
	pages = {244--261},
}

@article{reynolds_decision_2016-1,
	title = {A {Decision} {Procedure} for {Separation} {Logic} in {SMT}},
	url = {http://arxiv.org/abs/1603.06844},
	abstract = {This paper presents a complete decision procedure for the entire quantifier-free fragment of Separation Logic (\${\textbackslash}seplog\$) interpreted over heaplets with data elements ranging over a parametric multi-sorted (possibly infinite) domain. The algorithm uses a combination of theories and is used as a specialized solver inside a DPLL(\$T\$) architecture. A prototype was implemented within the CVC4 SMT solver. Preliminary evaluation suggests the possibility of using this procedure as a building block of a more elaborate theorem prover for SL with inductive predicates, or as back-end of a bounded model checker for programs with low-level pointer and data manipulations.},
	urldate = {2018-01-19},
	journal = {arXiv:1603.06844 [cs]},
	author = {Reynolds, Andrew and Iosif, Radu and King, Tim},
	month = mar,
	year = {2016},
	note = {arXiv: 1603.06844},
	keywords = {Computer Science - Logic in Computer Science},
}

@inproceedings{kastner_compcert:_2018,
	title = {{CompCert}: {Practical} {Experience} on {Integrating} and {Qualifying} a {Formally} {Verified} {Optimizing} {Compiler}},
	shorttitle = {{CompCert}},
	url = {https://hal.inria.fr/hal-01643290/document},
	abstract = {CompCert is the first commercially available optimizing compiler that is formally verified, using machine-assisted mathematical proofs, to be exempt from mis-compilation. The executable code it produces is proved to behave exactly as specified by the semantics of the source C program. This article gives an overview of the use of CompCert to gain certification credits for a highly safety-critical industry application, certified according to IEC 60880. We will briefly introduce the target application, illustrate the process of changing the existing compiler infrastructure to CompCert, and discuss performance characteristics. The main part focuses on the tool qualification strategy, in particular on how to take advantage of the formal correctness proof in the certification process.},
	language = {en},
	urldate = {2018-01-15},
	author = {Kästner, Daniel and Barrho, Jörg and Wünsche, Ulrich and Schlickling, Marc and Schommer, Bernhard and Schmidt, Michael and Ferdinand, Christian and Leroy, Xavier and Blazy, Sandrine},
	month = jan,
	year = {2018},
}

@article{hardin_reasoning_2015,
	title = {Reasoning about {LLVM} code using {Codewalker}},
	journal = {arXiv preprint arXiv:1509.06083},
	author = {Hardin, David S.},
	year = {2015},
}

@article{winterstein_separation_2016,
	title = {Separation logic for high-level synthesis},
	volume = {9},
	number = {2},
	journal = {ACM Transactions on Reconfigurable Technology and Systems (TRETS)},
	author = {Winterstein, Felix J. and Bayliss, Samuel R. and Constantinides, George A.},
	year = {2016},
	pages = {10},
}

@article{botincan_corestar:_2011,
	title = {{coreStar}: the core of {jStar}},
	volume = {2011},
	shorttitle = {{coreStar}},
	journal = {Boogie},
	author = {Botincan, Matko and Distefano, Dino and Dodds, Mike and Grigore, Radu and Naudziuniene, Daiva and Parkinson, Matthew J.},
	year = {2011},
	pages = {65--77},
}

@inproceedings{brotherston_parametric_2014,
	title = {Parametric completeness for separation theories},
	volume = {49},
	booktitle = {{ACM} {SIGPLAN} {Notices}},
	publisher = {ACM},
	author = {Brotherston, James and Villard, Jules},
	year = {2014},
	pages = {453--464},
}

@article{butt_australian_2014,
	title = {Australian women desert technology courses, as tertiary {IT} enrolments fall},
	url = {http://www.smh.com.au/it-pro/expertise/australian-women-desert-technology-courses-as-tertiary-it-enrolments-fall-20140916-10hs5c.html},
	language = {en\_US},
	urldate = {2017-10-30},
	journal = {The Sydney Morning Herald},
	author = {Butt, Craig},
	month = sep,
	year = {2014},
}

@article{james_tertiary_2016,
	title = {Tertiary student attitudes to invigilated, online summative examinations},
	volume = {13},
	issn = {2365-9440},
	url = {https://doi.org/10.1186/s41239-016-0015-0},
	doi = {10.1186/s41239-016-0015-0},
	abstract = {The outcomes of a trial implementation of an invigilated, online examination at a regional university in Australia and their implications for online education providers are discussed. Students in a first year online psychology course were offered the opportunity to complete their final examination task online with invigilation conducted via webcam. About a quarter of the students (125) initially elected to complete the online examination; however, after they had undertaken a practice online examination, only 29 (6.3 \%) students elected to continue in the trial and proceed to take the final exam online. The study concluded that many students have substantial challenges with the idea of major stakes examinations being online. While lower associated costs and time requirements were motivations, many were challenged by the process due to technical difficulties and insufficient support. ICT infrastructure and reliable connectivity remain significant barriers to successful completion of online examinations under secure, proctored conditions.},
	urldate = {2017-10-30},
	journal = {International Journal of Educational Technology in Higher Education},
	author = {James, Rosalind},
	month = mar,
	year = {2016},
	keywords = {E-assessment, MOOC, Online assessment, Student voice},
	pages = {19},
}

@article{mcmanus_resitting_2012,
	title = {Resitting a high-stakes postgraduate medical examination on multiple occasions: nonlinear multilevel modelling of performance in the {MRCP}({UK}) examinations},
	volume = {10},
	issn = {1741-7015},
	shorttitle = {Resitting a high-stakes postgraduate medical examination on multiple occasions},
	url = {https://doi.org/10.1186/1741-7015-10-60},
	doi = {10.1186/1741-7015-10-60},
	abstract = {Failure rates in postgraduate examinations are often high and many candidates therefore retake examinations on several or even many times. Little, however, is known about how candidates perform across those multiple attempts. A key theoretical question to be resolved is whether candidates pass at a resit because they have got better, having acquired more knowledge or skills, or whether they have got lucky, chance helping them to get over the pass mark. In the UK, the issue of resits has become of particular interest since the General Medical Council issued a consultation and is considering limiting the number of attempts candidates may make at examinations.},
	urldate = {2017-10-30},
	journal = {BMC Medicine},
	author = {McManus, IC and Ludka, Katarzyna},
	month = jun,
	year = {2012},
	pages = {60},
}

@article{cruz_type_nodate,
	title = {Type {Abstraction} for {Relaxed} {Noninterference}},
	url = {https://www-sop.inria.fr/teams/lemme/Tamara.Rezk/publication/ecoop17.pdf},
	urldate = {2017-06-01},
	author = {Cruz, Raimil and Rezk, Tamara and Serpette, Bernard and Tanter, Éric},
}

@inproceedings{lortz_cassandra:_2014,
	title = {Cassandra: {Towards} a certifying app store for android},
	shorttitle = {Cassandra},
	url = {http://dl.acm.org/citation.cfm?id=2666631},
	urldate = {2017-05-24},
	booktitle = {Proceedings of the 4th {ACM} {Workshop} on {Security} and {Privacy} in {Smartphones} \& {Mobile} {Devices}},
	publisher = {ACM},
	author = {Lortz, Steffen and Mantel, Heiko and Starostin, Artem and Bähr, Timo and Schneider, David and Weber, Alexandra},
	year = {2014},
	pages = {93--104},
}

@article{gunadi_formal_2015,
	title = {Formal certification of android bytecode},
	url = {https://arxiv.org/abs/1504.01842},
	urldate = {2017-05-24},
	journal = {arXiv preprint arXiv:1504.01842},
	author = {Gunadi, Hendra and Tiu, Alwen and Gore, Rajeev},
	year = {2015},
}

@inproceedings{schoepe_lets_2016,
	title = {Let’s {Face} {It}: {Faceted} {Values} for {Taint} {Tracking}},
	shorttitle = {Let’s {Face} {It}},
	url = {http://link.springer.com/chapter/10.1007/978-3-319-45744-4_28},
	urldate = {2017-05-24},
	booktitle = {European {Symposium} on {Research} in {Computer} {Security}},
	publisher = {Springer},
	author = {Schoepe, Daniel and Balliu, Musard and Piessens, Frank and Sabelfeld, Andrei},
	year = {2016},
	pages = {561--580},
}

@phdthesis{arzt_static_2017,
	title = {Static {Data} {Flow} {Analysis} for {Android} {Applications}},
	url = {http://tuprints.ulb.tu-darmstadt.de/5937},
	urldate = {2017-05-24},
	school = {Technische Universität},
	author = {Arzt, Steven},
	year = {2017},
}

@inproceedings{rodrigues_sparse_2016,
	title = {Sparse representation of implicit flows with applications to side-channel detection},
	url = {http://dl.acm.org/citation.cfm?id=2892230},
	urldate = {2017-05-24},
	booktitle = {Proceedings of the 25th {International} {Conference} on {Compiler} {Construction}},
	publisher = {ACM},
	author = {Rodrigues, Bruno and Quintão Pereira, Fernando Magno and Aranha, Diego F.},
	year = {2016},
	pages = {110--120},
}

@article{li_static_2017,
	title = {Static analysis of android apps: {A} systematic literature review},
	shorttitle = {Static analysis of android apps},
	url = {http://www.sciencedirect.com/science/article/pii/S0950584917302987},
	urldate = {2017-05-24},
	journal = {Information and Software Technology},
	author = {Li, Li and Bissyandé, Tegawendé F. and Papadakis, Mike and Rasthofer, Siegfried and Bartel, Alexandre and Octeau, Damien and Klein, Jacques and Le Traon, Yves},
	year = {2017},
}

@inproceedings{gunadi_formal_2015-1,
	title = {Formal certification of non-interferent {Android} bytecode ({DEX} bytecode)},
	url = {http://ieeexplore.ieee.org/abstract/document/7384249/},
	urldate = {2017-05-24},
	booktitle = {Engineering of {Complex} {Computer} {Systems} ({ICECCS}), 2015 20th {International} {Conference} on},
	publisher = {IEEE},
	author = {Gunadi, Hendra},
	year = {2015},
	pages = {202--205},
}

@inproceedings{huang_scalable_2015,
	title = {Scalable and precise taint analysis for {Android}},
	url = {http://dl.acm.org/citation.cfm?id=2771803},
	urldate = {2017-05-24},
	booktitle = {Proceedings of the 2015 {International} {Symposium} on {Software} {Testing} and {Analysis}},
	publisher = {ACM},
	author = {Huang, Wei and Dong, Yao and Milanova, Ana and Dolby, Julian},
	year = {2015},
	pages = {106--117},
}

@inproceedings{wadler_views:_1987-1,
	title = {Views: {A} way for pattern matching to cohabit with data abstraction},
	shorttitle = {Views},
	url = {http://dl.acm.org/citation.cfm?id=41653},
	urldate = {2017-01-07},
	booktitle = {Proceedings of the 14th {ACM} {SIGACT}-{SIGPLAN} symposium on {Principles} of programming languages},
	publisher = {ACM},
	author = {Wadler, Philip},
	year = {1987},
	pages = {307--313},
}

@article{parr_towards_nodate,
	title = {Towards a {Universal} {Code} {Formatter} through {Machine} {Learning}},
	url = {http://homepages.cwi.nl/~jurgenv/papers/SLE16.pdf},
	urldate = {2016-10-07},
	author = {Parr, Terence and Vinju, Jurgen},
}

@inproceedings{christiansen_all_2016,
	title = {All sorts of permutations (functional pearl)},
	url = {http://www-ps.informatik.uni-kiel.de/~sad/icfp2016-preprint.pdf},
	urldate = {2016-10-04},
	booktitle = {Proceedings of the 21st {ACM} {SIGPLAN} {International} {Conference} on {Functional} {Programming}},
	publisher = {ACM},
	author = {Christiansen, Jan and Danilenko, Nikita and Dylus, Sandra},
	year = {2016},
	pages = {168--179},
}

@incollection{augustsson_compiling_1985-1,
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Compiling pattern matching},
	copyright = {©1985 Springer-Verlag},
	isbn = {978-3-540-15975-9 978-3-540-39677-2},
	url = {http://link.springer.com/chapter/10.1007/3-540-15975-4_48},
	language = {en},
	number = {201},
	urldate = {2016-09-30},
	booktitle = {Functional {Programming} {Languages} and {Computer} {Architecture}},
	publisher = {Springer Berlin Heidelberg},
	author = {Augustsson, Lennart},
	editor = {Jouannaud, Jean-Pierre},
	month = sep,
	year = {1985},
	doi = {10.1007/3-540-15975-4_48},
	keywords = {early implementation},
	pages = {368--381},
}

@book{pickering_pattern_2016,
	title = {Pattern synonyms (extended version)},
	url = {http://cs.brynmawr.edu/~rae/papers/2016/patsyns/pattern-synonyms-extended.pdf},
	urldate = {2016-09-29},
	author = {Pickering, Matthew and Érdi, Gergo and Jones, S. Peyton and Eisenberg, Richard A.},
	year = {2016},
}

@inproceedings{pickering_pattern_2016-1,
	title = {Pattern synonyms},
	url = {http://mpickering.github.io/pattern-synonyms-final.pdf},
	urldate = {2016-09-29},
	booktitle = {Proceedings of the 9th {International} {Symposium} on {Haskell}},
	publisher = {ACM},
	author = {Pickering, Matthew and Érdi, Gergo and Jones, Simon Peyton and Eisenberg, Richard A.},
	year = {2016},
	pages = {80--91},
}

@article{pickering_pattern_2016-2,
	title = {Pattern synonyms},
	doi = {10.1145/2976002.2976013},
	author = {Pickering, Matthew and Érdi, Gergő and Peyton Jones, Simon and Eisenberg, Richard A.},
	year = {2016},
	pages = {80--91},
}

@article{seidel_dynamic_2016,
	title = {Dynamic {Witnesses} for {Static} {Type} {Errors}},
	url = {http://arxiv.org/abs/1606.07557},
	abstract = {Static type errors are a common stumbling block for newcomers to typed functional languages. We present a dynamic approach to explaining type errors by generating counterexample witness inputs that illustrate how an ill-typed program goes wrong. First, given an ill-typed function, we symbolically execute the body to dynamically synthesize witness values that can make the program go wrong. We prove that our procedure synthesizes general witnesses in that if a witness is found, then for all inhabited input types, there exist values that can make the function go wrong. Second, we show how to extend the above procedure to produce a reduction graph that can be used to interactively visualize and debug witness executions. Third, we evaluate the coverage of our approach on two data sets comprising over 4,500 ill-typed student programs. Our technique is able to generate witnesses for 88\% of the programs, and our reduction graph yields small counterexamples for 81\% of the witnesses. Finally, we evaluate the utility of our witnesses in helping students understand and fix type errors, and find that students presented with our witnesses consistently show a greater understanding of type errors than those presented with a standard error message.},
	urldate = {2016-07-08},
	journal = {arXiv:1606.07557 [cs]},
	author = {Seidel, Eric L. and Jhala, Ranjit and Weimer, Westley},
	month = jun,
	year = {2016},
	note = {arXiv: 1606.07557},
	keywords = {Computer Science - Programming Languages, D.3.2, D.3.4, F.3.3},
}

@inproceedings{fowler_dependent_2013,
	title = {Dependent types for safe and secure web programming},
	url = {http://dl.acm.org/citation.cfm?id=2620683},
	urldate = {2016-05-27},
	booktitle = {Proceedings of the 25th symposium on {Implementation} and {Application} of {Functional} {Languages}},
	publisher = {ACM},
	author = {Fowler, Simon and Brady, Edwin},
	year = {2013},
	pages = {49},
}

@article{pizani_flor_pi-ware:_2014,
	title = {Pi-{Ware}: {An} {Embedded} {Hardware} {Description} {Language} using {Dependent} {Types}},
	shorttitle = {Pi-{Ware}},
	url = {http://dspace.library.uu.nl/handle/1874/298576},
	urldate = {2016-05-26},
	author = {Pizani Flor, J. P.},
	year = {2014},
}

@inproceedings{brady_embedded_nodate,
	title = {Embedded {Domain} {Specific} {Language} {Implementation} using {Dependent} {Types}},
	author = {Brady, Edwin},
}

@incollection{brady_resource-safe_2012,
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Resource-{Safe} {Systems} {Programming} with {Embedded} {Domain} {Specific} {Languages}},
	copyright = {©2012 Springer-Verlag Berlin Heidelberg},
	isbn = {978-3-642-27693-4, 978-3-642-27694-1},
	url = {http://link.springer.com/chapter/10.1007/978-3-642-27694-1_18},
	abstract = {We introduce a new overloading notation that facilitates programming, modularity and reuse in Embedded Domain Specific Languages (EDSLs), and use it to reason about safe resource usage and state management. We separate the structural language constructs from our primitive operations, and show how precisely-typed functions can be lifted into the EDSL. In this way, we implement a generic framework for constructing state-aware EDSLs for systems programming.},
	language = {en},
	number = {7149},
	urldate = {2016-05-25},
	booktitle = {Practical {Aspects} of {Declarative} {Languages}},
	publisher = {Springer Berlin Heidelberg},
	author = {Brady, Edwin and Hammond, Kevin},
	editor = {Russo, Claudio and Zhou, Neng-Fa},
	month = jan,
	year = {2012},
	doi = {10.1007/978-3-642-27694-1_18},
	keywords = {(Embedded) Domain-Specific Languages, Artificial Intelligence (incl. Robotics), Dependent Types, Logics and Meanings of Programs, Mathematical Logic and Formal Languages, Program Verification, Programming Languages, Compilers, Interpreters, Programming Techniques, Resource Usage, Software Engineering},
	pages = {242--257},
}

@inproceedings{sheard_language-based_2010,
	title = {Language-based verification will change the world},
	url = {http://dl.acm.org/citation.cfm?id=1882432},
	urldate = {2016-05-25},
	booktitle = {Proceedings of the {FSE}/{SDP} workshop on {Future} of software engineering research},
	publisher = {ACM},
	author = {Sheard, Tim and Stump, Aaron and Weirich, Stephanie},
	year = {2010},
	pages = {343--348},
}

@article{fowler_verified_2014,
	title = {Verified {Networking} using {Dependent} {Types}},
	url = {http://simonjf.com/writing/bsc-dissertation.pdf},
	urldate = {2016-05-25},
	author = {Fowler, Simon},
	year = {2014},
}

@article{brady_embedded_2015,
	title = {Embedded {Domain} {Specific} {Languages} in {Idris}},
	url = {http://www.cs.ox.ac.uk/projects/utgp/school/idris-tutorial.pdf},
	urldate = {2016-05-25},
	author = {Brady, Edwin},
	year = {2015},
}

@inproceedings{weirich_why_nodate,
	title = {Why {You} {Should} {Care} {About} {Dependent} {Types}},
	author = {Weirich, Stephanie},
}

@article{beyer_witness_2015,
	title = {Witness {Validation} and {Stepwise} {Testification} across {Software} {Verifiers}},
	url = {http://dl.acm.org/citation.cfm?id=2786867},
	urldate = {2016-05-20},
	author = {Beyer, Dirk and Dangl, Matthias and Dietsch, Daniel and Heizmann, Matthias and Stahlbauer, Andreas},
	year = {2015},
}

@incollection{inostroza_tracing_2014,
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Tracing {Program} {Transformations} with {String} {Origins}},
	copyright = {©2014 Springer International Publishing Switzerland},
	isbn = {978-3-319-08788-7, 978-3-319-08789-4},
	url = {http://link.springer.com/chapter/10.1007/978-3-319-08789-4_12},
	abstract = {Program transformations play an important role in domain-specific languages and model-driven development. Tracing the execution of such transformations has well-known benefits for debugging, visualization and error reporting. In this paper, we introduce string origins, a lightweight, generic and portable technique to establish a tracing relation between the textual fragments in the input and output of a program transformation. We discuss the semantics and the implementation of string origins using the Rascal meta programming language as an example. We illustrate the utility of string origins by presenting data structures and operations for tracing generated code, implementing protected regions, performing name resolution and fixing inadvertent name capture in generated code.},
	language = {en},
	number = {8568},
	urldate = {2016-05-20},
	booktitle = {Theory and {Practice} of {Model} {Transformations}},
	publisher = {Springer International Publishing},
	author = {Inostroza, Pablo and Storm, Tijs van der and Erdweg, Sebastian},
	editor = {Ruscio, Davide Di and Varró, Dániel},
	month = jul,
	year = {2014},
	doi = {10.1007/978-3-319-08789-4_12},
	keywords = {Logics and Meanings of Programs, Management of Computing and Information Systems, Programming Languages, Compilers, Interpreters, Software Engineering},
	pages = {154--169},
}

@techreport{zenger_independently_2004,
	title = {Independently extensible solutions to the expression problem},
	url = {http://infoscience.epfl.ch/record/52625},
	urldate = {2016-05-10},
	author = {Zenger, Matthias and Odersky, Martin},
	year = {2004},
}

@article{swierstra_data_2008,
	title = {Data types à la carte},
	volume = {18},
	url = {http://journals.cambridge.org/abstract_S0956796808006758},
	number = {04},
	urldate = {2016-05-10},
	journal = {Journal of functional programming},
	author = {Swierstra, Wouter},
	year = {2008},
	pages = {423--436},
}

@article{reynolds_user-defined_1994,
	title = {User-defined types and procedural data structures as complementary approaches to data abstraction},
	url = {https://books.google.com.au/books?hl=en&lr=&id=N_tBTbYO1WAC&oi=fnd&pg=PA13&dq=user+defined+types+and+procedural+data+structures&ots=YU6WiDYaoT&sig=bzrPwJLHkCR_c0Hunk0oZ92J7NY},
	urldate = {2016-05-10},
	journal = {Theoretical aspects of object-oriented programming: types, semantics, and language design},
	author = {Reynolds, John C.},
	year = {1994},
	pages = {13--23},
}

@incollection{oliveira_modular_2009,
	title = {Modular visitor components},
	url = {http://link.springer.com/chapter/10.1007/978-3-642-03013-0_13},
	urldate = {2016-05-10},
	booktitle = {{ECOOP} 2009–{Object}-{Oriented} {Programming}},
	publisher = {Springer},
	author = {Oliveira, Bruno C. d S.},
	year = {2009},
	pages = {269--293},
}

@incollection{krishnamurthi_synthesizing_1998,
	title = {Synthesizing object-oriented and functional design to promote re-use},
	url = {http://link.springer.com/chapter/10.1007/BFb0054088},
	urldate = {2016-05-10},
	booktitle = {{ECOOP}’98—{Object}-{Oriented} {Programming}},
	publisher = {Springer},
	author = {Krishnamurthi, Shriram and Felleisen, Matthias and Friedman, Daniel P.},
	year = {1998},
	pages = {91--113},
}

@article{ernst_expression_2004,
	title = {The expression problem, {Scandinavian} style},
	url = {https://hal.archives-ouvertes.fr/file/index/docid/109148/filename/D306.PDF#page=38},
	urldate = {2016-05-10},
	journal = {ON MECHANISMS FOR SPECIALIZATION},
	author = {Ernst, Erik},
	year = {2004},
	pages = {27},
}

@inproceedings{clifton_multijava:_2000,
	title = {{MultiJava}: {Modular} open classes and symmetric multiple dispatch for {Java}},
	volume = {35},
	shorttitle = {{MultiJava}},
	url = {http://dl.acm.org/citation.cfm?id=353181},
	urldate = {2016-05-10},
	booktitle = {{ACM} {Sigplan} {Notices}},
	publisher = {ACM},
	author = {Clifton, Curtis and Leavens, Gary T. and Chambers, Craig and Millstein, Todd},
	year = {2000},
	pages = {130--145},
}

@incollection{cook_object-oriented_1990,
	title = {Object-oriented programming versus abstract data types},
	url = {http://link.springer.com/chapter/10.1007/BFb0019443},
	urldate = {2016-05-10},
	booktitle = {Foundations of {Object}-{Oriented} {Languages}},
	publisher = {Springer},
	author = {Cook, William R.},
	year = {1990},
	pages = {151--178},
}

@article{chambers_typechecking_1995,
	title = {Typechecking and modules for multimethods},
	volume = {17},
	url = {http://dl.acm.org/citation.cfm?id=218571},
	number = {6},
	urldate = {2016-05-10},
	journal = {ACM Transactions on Programming Languages and Systems (TOPLAS)},
	author = {Chambers, Craig and Leavens, Gary T.},
	year = {1995},
	pages = {805--843},
}

@book{ernst_virtual_2006,
	title = {A virtual class calculus},
	volume = {41},
	url = {http://dl.acm.org/citation.cfm?id=1111062},
	number = {1},
	urldate = {2016-05-10},
	publisher = {ACM},
	author = {Ernst, Erik and Ostermann, Klaus and Cook, William R.},
	year = {2006},
}

@incollection{oliveira_extensibility_2012,
	title = {Extensibility for the {Masses}},
	url = {http://link.springer.com/chapter/10.1007/978-3-642-31057-7_2},
	urldate = {2016-05-10},
	booktitle = {{ECOOP} 2012–{Object}-{Oriented} {Programming}},
	publisher = {Springer},
	author = {Oliveira, Bruno C. d S. and Cook, William R.},
	year = {2012},
	pages = {2--27},
}

@incollection{torgersen_expression_2004,
	title = {The expression problem revisited},
	url = {http://link.springer.com/chapter/10.1007/978-3-540-24851-4_6},
	urldate = {2016-05-10},
	booktitle = {{ECOOP} 2004–{Object}-{Oriented} {Programming}},
	publisher = {Springer},
	author = {Torgersen, Mads},
	year = {2004},
	pages = {123--146},
}

@inproceedings{wang_expression_2016,
	title = {The expression problem, trivially!},
	url = {http://dl.acm.org/citation.cfm?id=2889448},
	urldate = {2016-05-10},
	booktitle = {Proceedings of the 15th {International} {Conference} on {Modularity}},
	publisher = {ACM},
	author = {Wang, Yanlin and Oliveira, Bruno C. d S.},
	year = {2016},
	pages = {37--41},
}

@book{goldschmidt_view-based_2011,
	title = {View-based textual modelling},
	volume = {6},
	url = {https://books.google.com.au/books?hl=en&lr=&id=wTXW1AGYr90C&oi=fnd&pg=PR13&dq=view+based+textual+modelling&ots=Y8CezDVV1F&sig=nQ7hMTTPm8vW7l4FBUgPTYlMFxo},
	urldate = {2016-03-23},
	publisher = {KIT Scientific Publishing},
	author = {Goldschmidt, Thomas},
	year = {2011},
}

@inproceedings{goldschmidt_towards_2012,
	title = {Towards a {Tool}-{Oriented} {Taxonomy} of {View}-{Based} {Modelling}},
	url = {http://subs.emis.de/LNI/Proceedings/Proceedings201/article6680.html},
	booktitle = {Modellierung 2012, 14.-16. {März} 2012, {Bamberg}, {Deutschland}},
	author = {Goldschmidt, Thomas and Becker, Steffen and Burger, Erik},
	year = {2012},
	pages = {59--74},
}

@inproceedings{goldschmidt_textual_2009,
	title = {Textual {Views} in {Model} {Driven} {Engineering}},
	doi = {10.1109/SEAA.2009.41},
	abstract = {Building views on abstract models is one of the key concepts of model-driven engineering. Different views help to present concepts behind a model in a way that they can be understood and edited by different stakeholders or developers in different roles. Within graphical modelling several approaches exist allowing the definition of explicit holistic, partial or combined graphical views for models.On the other hand several frameworks that provide textual editing support for models have been presented over recent years. However, the combination of both principals, meaning textual, editable and decorating views is lacking in all of these approaches. In this paper, we introduce a textual decorator approach that allows to separately store and manage the textual concrete syntax from the actual abstract model elements. Thereby we allow to define textual views on models that may be partial and/or overlapping concerning other(graphical and/or textual) views.},
	booktitle = {35th {Euromicro} {Conference} on {Software} {Engineering} and {Advanced} {Applications}, 2009. {SEAA} '09},
	author = {Goldschmidt, T. and Becker, S. and Uhl, A.},
	month = aug,
	year = {2009},
	keywords = {Application software, Computer integrated manufacturing, Concrete, Layout, Software Engineering, Unified modeling language, computer graphics, graphical modelling, information technology, model driven engineering, textual concrete syntax, textual decorator, textual editing support},
	pages = {133--140},
}

@incollection{olsen_scenarios_2007,
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Scenarios of {Traceability} in {Model} to {Text} {Transformations}},
	copyright = {©2007 Springer Berlin Heidelberg},
	isbn = {978-3-540-72900-6, 978-3-540-72901-3},
	url = {http://link.springer.com/chapter/10.1007/978-3-540-72901-3_11},
	abstract = {The challenges of managing change in model-driven development are addressed by traceability mechanisms for model to text transformations. A traceability model, tailored for representing trace information between models and generated code, provides the basis for visualisation and analysis of the relationships between models and code. Usage scenarios for traceability are discussed and illustrated by our traceability implementation.},
	language = {en},
	number = {4530},
	urldate = {2016-03-09},
	booktitle = {Model {Driven} {Architecture}- {Foundations} and {Applications}},
	publisher = {Springer Berlin Heidelberg},
	author = {Olsen, Gøran K. and Oldevik, Jon},
	editor = {Akehurst, David H. and Vogel, Régis and Paige, Richard F.},
	month = jun,
	year = {2007},
	doi = {10.1007/978-3-540-72901-3_11},
	keywords = {Computer System Implementation, Computer Systems Organization and Communication Networks, Logics and Meanings of Programs, Management of Computing and Information Systems, Software Engineering},
	pages = {144--156},
}

@incollection{andres_domain_2007,
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Domain {Specific} {Languages} with {Graphical} and {Textual} {Views}},
	copyright = {©2008 Springer-Verlag Berlin Heidelberg},
	isbn = {978-3-540-89019-5, 978-3-540-89020-1},
	url = {http://link.springer.com/chapter/10.1007/978-3-540-89020-1_7},
	abstract = {We show our approach for the definition of Domain Specific Languages integrating both graphical and textual views. The approach is based on the meta-modelling concepts provided by the AToM3 tool. In this way, the language designer starts building the meta-model of the complete language. Then, he can select (possibly overlapping) submodels of the meta-model to define the different diagram types (i.e. language viewpoints). By default, the viewpoint is assigned a graphical concrete syntax, although a textual one can also be given. This is performed by selecting (or creating) triple graph grammar rules to translate from the viewpoint meta-model to a DSL called Textual that contains the most common elements of textual languages (such as expressions or operators). From a Textual model, a parser is automatically generated, where the semantic actions of the EBNF grammar are graph grammar rules, derived from the viewpoint meta-model. In this way, the parsing results in a model conformant to the viewpoint meta-model, which can be seamlessly integrated with other graphical and textual views.},
	language = {en},
	number = {5088},
	urldate = {2016-03-09},
	booktitle = {Applications of {Graph} {Transformations} with {Industrial} {Relevance}},
	publisher = {Springer Berlin Heidelberg},
	author = {Andrés, Francisco Pérez and Lara, Juan de and Guerra, Esther},
	editor = {Schürr, Andy and Nagl, Manfred and Zündorf, Albert},
	month = oct,
	year = {2007},
	doi = {10.1007/978-3-540-89020-1_7},
	keywords = {Algorithm Analysis and Problem Complexity, Data Structures, Logics and Meanings of Programs, Mathematical Logic and Formal Languages, Software Engineering, Software Engineering/Programming and Operating Systems},
	pages = {82--97},
}

@incollection{rest_robust_2013,
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Robust {Real}-{Time} {Synchronization} between {Textual} and {Graphical} {Editors}},
	copyright = {©2013 Springer-Verlag Berlin Heidelberg},
	isbn = {978-3-642-38882-8, 978-3-642-38883-5},
	url = {http://link.springer.com/chapter/10.1007/978-3-642-38883-5_11},
	abstract = {In modern Integrated Development Environments (IDEs), textual editors are interactive and can handle intermediate, incomplete, or otherwise erroneous texts while still providing editor services such as syntax highlighting, error marking, outline views, and hover help. In this paper, we present an approach for the robust synchronization of interactive textual and graphical editors. The approach recovers from errors during parsing and text-to-model synchronization, preserves textual and graphical layout in the presence of erroneous texts and models, and provides synchronized editor services such as selection sharing and navigation between editors. It was implemented for synchronizing textual editors generated by the Spoofax language workbench and graphical editors generated by the Graphical Modeling Framework.},
	language = {en},
	number = {7909},
	urldate = {2016-03-09},
	booktitle = {Theory and {Practice} of {Model} {Transformations}},
	publisher = {Springer Berlin Heidelberg},
	author = {Rest, Oskar van and Wachsmuth, Guido and Steel, Jim R. H. and Süß, Jörn Guy and Visser, Eelco},
	editor = {Duddy, Keith and Kappel, Gerti},
	month = jun,
	year = {2013},
	doi = {10.1007/978-3-642-38883-5_11},
	keywords = {Logics and Meanings of Programs, Management of Computing and Information Systems, Programming Languages, Compilers, Interpreters, Software Engineering},
	pages = {92--107},
}

@article{niklas_implementing_nodate,
	title = {Implementing semantic feedback in a diagram editor},
	author = {Niklas, Fors and Görel, Hedin},
}

@article{scott_when_2000,
	title = {When do match-compilation heuristics matter},
	url = {http://www.cs.tufts.edu/~nr/cs257/archive/norman-ramsey/match.pdf},
	urldate = {2015-10-13},
	journal = {University of Virginia, Charlottesville, VA},
	author = {Scott, Kevin and Ramsey, Norman},
	year = {2000},
}

@incollection{emir_matching_2007,
	title = {Matching objects with patterns},
	url = {http://link.springer.com/chapter/10.1007/978-3-540-73589-2_14},
	urldate = {2015-10-13},
	booktitle = {{ECOOP} 2007–{Object}-{Oriented} {Programming}},
	publisher = {Springer},
	author = {Emir, Burak and Odersky, Martin and Williams, John},
	year = {2007},
	pages = {273--298},
}

@inproceedings{odersky_pizza_1997,
	title = {Pizza into {Java}: {Translating} theory into practice},
	shorttitle = {Pizza into {Java}},
	url = {http://dl.acm.org/citation.cfm?id=263715},
	urldate = {2015-10-13},
	booktitle = {Proceedings of the 24th {ACM} {SIGPLAN}-{SIGACT} symposium on {Principles} of programming languages},
	publisher = {ACM},
	author = {Odersky, Martin and Wadler, Philip},
	year = {1997},
	pages = {146--159},
}

@article{dunfield_complete_2013,
	title = {Complete and easy bidirectional typechecking for higher-rank polymorphism},
	volume = {48},
	url = {http://dl.acm.org/citation.cfm?id=2500582},
	number = {9},
	urldate = {2015-08-26},
	journal = {ACM SIGPLAN Notices},
	author = {Dunfield, Joshua and Krishnaswami, Neelakantan R.},
	year = {2013},
	keywords = {Type systems, type inference},
	pages = {429--442},
}

@inproceedings{hinze_towards_2011,
	address = {New York, NY, USA},
	series = {{WGP} '11},
	title = {Towards a {Categorical} {Foundation} for {Generic} {Programming}},
	isbn = {978-1-4503-0861-8},
	url = {http://doi.acm.org/10.1145/2036918.2036926},
	doi = {10.1145/2036918.2036926},
	abstract = {Generic Haskell is an extension of Haskell that supports datatype generic programming. The central idea of Generic Haskell is to interpret a type by a function, the so-called instance of a generic function at that type. Since types in Haskell include parametric types such as 'list of', Generic Haskell represents types by terms of the simply-typed lambda calculus. This paper puts the idea of interpreting types as functions on a firm theoretical footing, exploiting the fact that the simply-typed lambda calculus can be interpreted in a cartesian closed category. We identify a suitable target category, a subcategory of Cat, and argue that slice, coslice and comma categories are a good fit for interpreting generic functions at base types.},
	urldate = {2015-05-13},
	booktitle = {Proceedings of the {Seventh} {ACM} {SIGPLAN} {Workshop} on {Generic} {Programming}},
	publisher = {ACM},
	author = {Hinze, Ralf and Wu, Nicolas},
	year = {2011},
	keywords = {Generic programming, category theory, comma category, slice category},
	pages = {47--58},
}

@book{noauthor_wgp_2011,
	address = {New York, NY, USA},
	title = {{WGP} '11: {Proceedings} of the {Seventh} {ACM} {SIGPLAN} {Workshop} on {Generic} {Programming}},
	isbn = {978-1-4503-0861-8},
	shorttitle = {{WGP} '11},
	abstract = {It is our great pleasure to welcome you to the 7th ACM SIGPLAN Workshop on Generic Programming (WGP 2011), held in Tokyo, Japan, on 18th September 2011. The workshop is sponsored by ACM SIGPLAN and is affiliated with the 16th ACM SIGPLAN International Conference on Functional Programming (ICFP 2011). Previous Workshops on Generic Programming have been held in Baltimore (affiliated with ICFP), Marstrand (affiliated with MPC), Ponte de Lima (affiliated with MPC), Nottingham (informal workshop), Dagstuhl (IFIP TC2/IFIP WG2.1 Working Conference), Oxford (informal workshop), Utrecht (informal workshop), Portland (affiliated with ICFP), Victoria (affiliated with ICFP), and Edinburgh (affiliated with ICFP). The call for papers generated 10 submissions. Each paper was evaluated by at least three members of the programme committee with the help of additional reviewers. The quality of the submissions was very high: during a five-day virtual meeting, the programme committee selected 9 papers for presentation at the workshop. The papers cover a variety of generic programming topics, including dependently typed programming, datatype-generic programming, universe construction, generalized algebraic datatypes, category theory, and C++ concepts. We hope that the proceedings will serve as a valuable reference for both researchers and students. We note that one of the papers presented in the workshop is not included in the proceedings. This paper, "Functor is to Lens as Applicative is to Biplate: Introducing Multiplate" by Russell O'Connor, is accessible as arXiv:1103.2841v2 [cs.PL].},
	publisher = {ACM},
	year = {2011},
	note = {565119},
}

@article{hinze_generics_2006,
	title = {Generics for the {Masses}},
	volume = {16},
	issn = {0956-7968},
	url = {http://dx.doi.org/10.1017/S0956796806006022},
	doi = {10.1017/S0956796806006022},
	abstract = {A generic function is a function that can be instantiated on many data types to obtain data type specific functionality. Examples of generic functions are the functions that can be derived in Haskell, such as show, read, and ‘==’. The recent years have seen a number of proposals that support the definition of generic functions. Some of the proposals define new languages, some define extensions to existing languages. As a common characteristic none of the proposals can be made to work within Haskell 98: they all require something extra, either a more sophisticated type system or an additional language construct. The purpose of this paper is to show that one can, in fact, program generically within Haskell 98 obviating to some extent the need for fancy type systems or separate tools. Haskell's type classes are at the heart of this approach: they ensure that generic functions can be defined succinctly and, in particular, that they can be used painlessly. We detail three different implementations of generics both from a practical and from a theoretical perspective.},
	number = {4-5},
	urldate = {2015-05-13},
	journal = {J. Funct. Program.},
	author = {Hinze, Ralf},
	month = jul,
	year = {2006},
	pages = {451--483},
}

@book{peyton_jones_implementation_1987,
	address = {Upper Saddle River, NJ, USA},
	title = {The {Implementation} of {Functional} {Programming} {Languages} ({Prentice}-{Hall} {International} {Series} in {Computer} {Science})},
	isbn = {013453333X},
	publisher = {Prentice-Hall, Inc.},
	author = {Peyton Jones, Simon L.},
	year = {1987},
}

@inproceedings{guillemette_type-preserving_2008,
	title = {A type-preserving compiler in {Haskell}},
	volume = {43},
	url = {http://dl.acm.org/citation.cfm?id=1411218},
	urldate = {2015-05-07},
	booktitle = {{ACM} {Sigplan} {Notices}},
	publisher = {ACM},
	author = {Guillemette, Louis-Julien and Monnier, Stefan},
	year = {2008},
	pages = {75--86},
}

@article{weirich_type-safe_2006,
	title = {Type-safe run-time polytypic programming},
	volume = {16},
	url = {http://journals.cambridge.org/abstract_S0956796806005879},
	number = {06},
	urldate = {2015-05-07},
	journal = {Journal of Functional Programming},
	author = {Weirich, Stephanie},
	year = {2006},
	pages = {681--710},
}

@inproceedings{washburn_boxes_2003,
	title = {Boxes go bananas: {Encoding} higher-order abstract syntax with parametric polymorphism},
	volume = {38},
	shorttitle = {Boxes go bananas},
	url = {http://dl.acm.org/citation.cfm?id=944728},
	urldate = {2015-05-07},
	booktitle = {{ACM} {SIGPLAN} {Notices}},
	publisher = {ACM},
	author = {Washburn, Geoffrey and Weirich, Stephanie},
	year = {2003},
	pages = {249--262},
}

@inproceedings{crary_intensional_1998,
	title = {Intensional polymorphism in type-erasure semantics},
	volume = {34},
	url = {http://dl.acm.org/citation.cfm?id=289459},
	urldate = {2015-05-06},
	booktitle = {{ACM} {SIGPLAN} {Notices}},
	publisher = {ACM},
	author = {Crary, Karl and Weirich, Stephanie and Morrisett, Greg},
	year = {1998},
	pages = {301--312},
}

@inproceedings{hinze_type-indexed_2002,
	title = {Type-indexed data types},
	url = {http://link.springer.com/chapter/10.1007/3-540-45442-X_10},
	urldate = {2015-05-04},
	booktitle = {Mathematics of {Program} {Construction}},
	publisher = {Springer},
	author = {Hinze, Ralf and Jeuring, Johan and Löh, Andres},
	year = {2002},
	pages = {148--174},
}

@inproceedings{weirich_higher-order_2003,
	title = {Higher-order intensional type analysis in type-erasure semantics},
	url = {http://www.cis.upenn.edu/~sweirich/papers/erasure/erasure-paper-july03.pdf},
	urldate = {2015-05-04},
	booktitle = {In {Proc}. 11th {ESOP}, {LNCS} 2305},
	author = {Weirich, Stephanie},
	year = {2003},
}

@article{jeuring_testing_2012,
	title = {Testing {Type} {Class} {Laws}},
	volume = {47},
	issn = {0362-1340},
	url = {http://doi.acm.org/10.1145/2430532.2364514},
	doi = {10.1145/2430532.2364514},
	number = {12},
	journal = {SIGPLAN Not.},
	author = {Jeuring, Johan and Jansson, Patrik and Amaral, Cláudio},
	month = sep,
	year = {2012},
	keywords = {classes, laws, state monad, testing},
	pages = {49--60},
}

@article{oflaherty_use_2015,
	title = {The use of flipped classrooms in higher education: {A} scoping review},
	volume = {25},
	issn = {1096-7516},
	shorttitle = {The use of flipped classrooms in higher education},
	url = {http://www.sciencedirect.com/science/article/pii/S1096751615000056},
	doi = {10.1016/j.iheduc.2015.02.002},
	abstract = {There is increasing pressure for Higher Education institutions to undergo transformation, with education being seen as needing to adapt in ways that meet the conceptual needs of our time. Reflecting this is the rise of the flipped or inverted classroom. The purpose of this scoping review was to provide a comprehensive overview of relevant research regarding the emergence of the flipped classroom and the links to pedagogy and educational outcomes, identifying any gaps in the literature which could inform future design and evaluation. The scoping review is underpinned by the five-stage framework Arksey and O'Malley. The results indicate that there is much indirect evidence emerging of improved academic performance and student and staff satisfaction with the flipped approach but a paucity of conclusive evidence that it contributes to building lifelong learning and other 21st Century skills in under-graduate education and post-graduate education.},
	urldate = {2015-03-20},
	journal = {The Internet and Higher Education},
	author = {O'Flaherty, Jacqueline and Phillips, Craig},
	month = apr,
	year = {2015},
	keywords = {Educational outcomes, Engagement, Face to face teaching, Flipped classroom, Higher education, Scoping review},
	pages = {85--95},
}

@article{gibbons_essence_2009,
	title = {The essence of the iterator pattern},
	volume = {19},
	url = {http://journals.cambridge.org/abstract_S0956796809007291},
	number = {3-4},
	urldate = {2015-03-04},
	journal = {Journal of Functional Programming},
	author = {Gibbons, Jeremy and Oliveira, Bruno C. d S.},
	year = {2009},
	keywords = {paperclub},
	pages = {377--402},
}

@article{cepeda_distributed_2006,
	title = {Distributed practice in verbal recall tasks: {A} review and quantitative synthesis},
	volume = {132},
	issn = {0033-2909},
	shorttitle = {Distributed practice in verbal recall tasks},
	doi = {10.1037/0033-2909.132.3.354},
	abstract = {The authors performed a meta-analysis of the distributed practice effect to illuminate the effects of temporal variables that have been neglected in previous reviews. This review found 839 assessments of distributed practice in 317 experiments located in 184 articles. Effects of spacing (consecutive massed presentations vs. spaced learning episodes) and lag (less spaced vs. more spaced learning episodes) were examined, as were expanding interstudy interval (ISI) effects. Analyses suggest that ISI and retention interval operate jointly to affect final-test retention; specifically, the ISI producing maximal retention increased as retention interval increased. Areas needing future research and theoretical implications are discussed.},
	language = {eng},
	number = {3},
	journal = {Psychological Bulletin},
	author = {Cepeda, Nicholas J. and Pashler, Harold and Vul, Edward and Wixted, John T. and Rohrer, Doug},
	month = may,
	year = {2006},
	pmid = {16719566},
	keywords = {Humans, Mental Recall, Practice (Psychology), Verbal Behavior},
	pages = {354--380},
}

@article{wheeler_disparate_1992,
	title = {Disparate {Effects} of {Repeated} {Testing}: {Reconciling} {Ballard}'s (1913) and {Bartlett}'s (1932) {Results}},
	volume = {3},
	issn = {0956-7976, 1467-9280},
	shorttitle = {Disparate {Effects} of {Repeated} {Testing}},
	url = {http://pss.sagepub.com/content/3/4/240},
	doi = {10.1111/j.1467-9280.1992.tb00036.x},
	abstract = {Bartlett (1932) gave subjects a prose passage and showed how recall dropped when they were tested repeatedly. Ballard (1913), using poetry, and Erdelyi and Becker (1974), using pictures, reported improvements in performance (or hypermnesia) over repeated testing. We investigated two likely factors leading to the discrepant results: the type of material and the interval between tests. The primary cause of the differing outcomes is the interval between tests. In general, when the intervals between successive tests are short improvement occurs between tests. When these intervals are long, forgetting occurs. The type of material used plays little role: Hypermnesia in recall of prose (even “The War of the Ghosts”) occurred with short intervals between tests. We also report a striking confirmation of the power of tests to enhance memory: Repeated tests shortly after study greatly improved recall a week later.},
	language = {en},
	number = {4},
	urldate = {2015-02-25},
	journal = {Psychological Science},
	author = {Wheeler, Mark A. and Roediger, Henry L.},
	month = jul,
	year = {1992},
	pages = {240--245},
}

@article{roediger_test-enhanced_2006,
	title = {Test-enhanced learning: taking memory tests improves long-term retention},
	volume = {17},
	issn = {0956-7976},
	shorttitle = {Test-enhanced learning},
	doi = {10.1111/j.1467-9280.2006.01693.x},
	abstract = {Taking a memory test not only assesses what one knows, but also enhances later retention, a phenomenon known as the testing effect. We studied this effect with educationally relevant materials and investigated whether testing facilitates learning only because tests offer an opportunity to restudy material. In two experiments, students studied prose passages and took one or three immediate free-recall tests, without feedback, or restudied the material the same number of times as the students who received tests. Students then took a final retention test 5 min, 2 days, or 1 week later. When the final test was given after 5 min, repeated studying improved recall relative to repeated testing. However, on the delayed tests, prior testing produced substantially greater retention than studying, even though repeated studying increased students' confidence in their ability to remember the material. Testing is a powerful means of improving learning, not just assessing it.},
	language = {eng},
	number = {3},
	journal = {Psychological Science},
	author = {Roediger, Henry L. and Karpicke, Jeffrey D.},
	month = mar,
	year = {2006},
	pmid = {16507066},
	keywords = {Educational Measurement, Humans, Learning, Memory, Mental Recall, Neuropsychological Tests, Practice (Psychology), Retention (Psychology), Students, Time Factors},
	pages = {249--255},
}

@inproceedings{lammel_scrap_2007,
	title = {Scrap your boilerplate with {XPath}-like combinators},
	volume = {42},
	isbn = {1595935754},
	url = {http://portal.acm.org/citation.cfm?doid=1190216.1190240},
	doi = {10.1145/1190216.1190240},
	abstract = {XML programming involves idioms for expressing 'structure shyness' such as the descendant axis of XPath or the default templates of XSLT. We initiate a discussion of the relationships between such XML idioms and generic functional programming, while},
	publisher = {ACM  Request Permissions},
	author = {Lämmel, Ralf},
	month = jan,
	year = {2007},
	pages = {137--142},
}

@incollection{sloane_monto:_2014,
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Monto: {A} {Disintegrated} {Development} {Environment}},
	copyright = {©2014 Springer International Publishing Switzerland},
	isbn = {978-3-319-11244-2, 978-3-319-11245-9},
	shorttitle = {Monto},
	url = {http://link.springer.com/chapter/10.1007/978-3-319-11245-9_12},
	abstract = {Integrated development environments play a central role in the life of many software developers. Integrating new functionality into these environments is non-trivial and forms a significant barrier to entry. We describe our Monto architecture which aims to address this problem. Monto components communicate via text messages across an off-the-shelf messaging layer. The architecture imposes limited constraints which enables easy combination of components to form an environment. A prototype implementation shows that this approach is practical and shows promise for full-featured development environments.},
	language = {en},
	number = {8706},
	urldate = {2015-02-20},
	booktitle = {Software {Language} {Engineering}},
	publisher = {Springer International Publishing},
	author = {Sloane, Anthony M. and Roberts, Matthew and Buckley, Scott and Muscat, Shaun},
	editor = {Combemale, Benoît and Pearce, David J. and Barais, Olivier and Vinju, Jurgen J.},
	month = sep,
	year = {2014},
	keywords = {Artificial Intelligence (incl. Robotics), Management of Computing and Information Systems, Mathematical Logic and Formal Languages, Programming Languages, Compilers, Interpreters, Simulation and Modeling, Software Engineering},
	pages = {211--220},
}

@incollection{sloane_respect_2014,
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Respect {Your} {Parents}: {How} {Attribution} and {Rewriting} {Can} {Get} {Along}},
	copyright = {©2014 Springer International Publishing Switzerland},
	isbn = {978-3-319-11244-2, 978-3-319-11245-9},
	shorttitle = {Respect {Your} {Parents}},
	url = {http://link.springer.com/chapter/10.1007/978-3-319-11245-9_11},
	abstract = {Attribute grammars describe how to decorate static trees. Rewriting systems describe how to transform trees into new trees. Attribution is undermined by rewriting because a node may appear in both the source and product of a transformation. If an attribute of that node depends on the node’s context, then a previously computed value may not be valid. We explore this problem and formalise it as a question of ancestry: the context of a node is given by the tree’s parent relationships and we must use the appropriate parents to calculate attributes that depend on the context. We show how respecting parents naturally leads to a view of context-dependent attributes as tree-indexed attribute families. Viewed in this way, attribution co-exists easily with rewriting transformations. We demonstrate the practicality of our approach by describing our implementation in the Kiama language processing library.},
	language = {en},
	number = {8706},
	urldate = {2015-02-20},
	booktitle = {Software {Language} {Engineering}},
	publisher = {Springer International Publishing},
	author = {Sloane, Anthony M. and Roberts, Matthew and Hamey, Leonard G. C.},
	editor = {Combemale, Benoît and Pearce, David J. and Barais, Olivier and Vinju, Jurgen J.},
	month = sep,
	year = {2014},
	keywords = {Artificial Intelligence (incl. Robotics), Management of Computing and Information Systems, Mathematical Logic and Formal Languages, Programming Languages, Compilers, Interpreters, Simulation and Modeling, Software Engineering},
	pages = {191--210},
}

@inproceedings{roberts_type_2014,
	address = {New York, NY, USA},
	series = {{WGP} '14},
	title = {Type {Inference} for the {Spine} {View} of {Data}},
	isbn = {978-1-4503-3042-8},
	url = {http://doi.acm.org/10.1145/2633628.2633629},
	doi = {10.1145/2633628.2633629},
	abstract = {In this work we describe both a type checking and a type inference algorithm for generic programming using the spine view of data. The spine view of data is an approach to decomposing data in functional programming languages that supports generic programming in the style of Scrap Your Boilerplate and Stratego. The spine view of data has previously been described as a library in a statically typed language (as in Haskell), as a language feature in a dynamically typed language (as in Stratego), and as a calculus of patterns (as in the Pattern Calculus). The contribution of this paper is a type inference algorithm for the spine view and a type relation that underlies this inference algorithm. In contrast to all other typed implementations of the spine view, the type inference algorithm does not require any type annotations to be added in support of the spine view. This type inference algorithm is an extension of Hindley-Milner type inference, thus showing how to introduce the spine view of data as a language feature in any functional programming language based on Hindley-Milner.},
	urldate = {2015-02-20},
	booktitle = {Proceedings of the 10th {ACM} {SIGPLAN} {Workshop} on {Generic} {Programming}},
	publisher = {ACM},
	author = {Roberts, Matthew and Sloane, Anthony},
	year = {2014},
	keywords = {Generic programming, fcp, pattern matching, spine view, type inference},
	pages = {25--34},
}

@inproceedings{bower_wiki_2006,
	title = {Wiki {Pedagogy} – {A} {Tale} of {Two} {Wikis}},
	doi = {10.1109/ITHET.2006.339764},
	abstract = {This paper reports on a research project investigating the deployment of two different wikis in two Masters of IT subjects. As well, two different learning task designs were used (weekly whole class extension question tasks versus semester long group projects) providing further basis for comparison and contrast within the project. Data collection mechanisms included a 22 item student survey, interviews with academics and observations on student contributions to the wikis. Key results regarding students' patterns of behaviour, the impact of learning task design upon contributions, the effect of training, and the quality of the wiki applications themselves are discussed. Based on these results, a set of 12 principles for implementing wiki based learning tasks are recommended},
	booktitle = {7th {International} {Conference} on {Information} {Technology} {Based} {Higher} {Education} and {Training}, 2006. {ITHET} '06},
	author = {Bower, M. and Woo, K. and Roberts, M. and Watters, P.},
	month = jul,
	year = {2006},
	keywords = {Collaborative tools, Electronic learning, Libraries, Object oriented modeling, Online Communities/Technical Collaboration, Performance analysis, Programming profession, Technological innovation, collaborative learning, computer aided instruction, computer science education, continuing education, groupware, information technology, online learning, pedagogy, student behaviour pattern, wiki pedagogy, wikis},
	pages = {191--202},
}

@phdthesis{roberts_compiled_2011,
	title = {Compiled {Generics} for {Functional} {Programming}},
	school = {Macquarie University},
	author = {Roberts, Matthew},
	month = jan,
	year = {2011},
	keywords = {compiling functional languages, epic, generics, hindley-milner, spine view, syb, type indexed functions, type inference},
}

@article{wright_syntactic_1994,
	title = {A syntactic approach to type soundness},
	volume = {115},
	url = {http://portal.acm.org/citation.cfm?id=191905.191909&coll=DL&dl=GUIDE&CFID=283246294&CFTOKEN=80420452},
	doi = {10.1006/inco.1994.1093},
	number = {1},
	journal = {Information and Computation},
	author = {Wright, Andrew K and Felleisen, Matthias},
	month = nov,
	year = {1994},
}

@article{sloane_domain-specific_2014,
	series = {Selected {Papers} from the {Fifth} {International} {Conference} on {Software} {Language} {Engineering} ({SLE} 2012)},
	title = {Domain-specific program profiling and its application to attribute grammars and term rewriting},
	volume = {96, Part 4},
	issn = {0167-6423},
	url = {http://www.sciencedirect.com/science/article/pii/S0167642314000628},
	doi = {10.1016/j.scico.2014.02.011},
	abstract = {We present a method for profiling programs that are written using domain-specific languages. Instead of reporting execution in terms of implementation details as in most existing profilers, our method operates at the level of the problem domain. Program execution generates a stream of events that summarises the execution in terms of domain concepts and operations. The events enable us to construct a hierarchical model of the execution. A flexible reporting system summarises the execution along developer-chosen model dimensions. The result is a flexible way for a developer to explore the execution of their program without requiring any knowledge of the domain-specific language implementation.

These ideas are embodied in a new profiling library called dsprofile that is independent of the problem domain so it has no specific knowledge of the data and operations that are being profiled. We illustrate the utility of dsprofile by using it to profile programs that are written using our Kiama language processing library. Specifically, we instrument Kiama's attribute grammar and term rewriting domain-specific languages to use dsprofile to generate events that report on attribute evaluation and rewrite rule application. Examples of typical language processing tasks show how domain-specific profiling can help to diagnose problems in Kiama-based programs without the developer needing to know anything about how Kiama is implemented.},
	urldate = {2015-01-19},
	journal = {Science of Computer Programming},
	author = {Sloane, Anthony and Roberts, Matthew},
	month = dec,
	year = {2014},
	keywords = {Attribute grammars, Kiama, Program profiling, Scala, Term rewriting},
	pages = {488--510},
}

@inproceedings{winter_using_2014,
	title = {Using {Program} {Transformation}, {Annotation}, and {Reflection} to {Certify} a {Java} {Type} {Resolution} {Function}},
	doi = {10.1109/HASE.2014.27},
	booktitle = {High-{Assurance} {Systems} {Engineering} ({HASE}), 2014 {IEEE} 15th {International} {Symposium} on},
	author = {Winter, V.L. and Reinke, C. and Guerrero, J.},
	month = jan,
	year = {2014},
	keywords = {Access control, Bismuth, Complexity theory, Context, Instruments, Java, Java compiler, Java source code base, Java type resolution function, Program processors, annotation, program annotation, program compilers, program reflection, program transformation, reflection, semantic based analysis, source code analysis, subject code, type resolution},
	pages = {137--145},
}

@article{kirchner_rewriting_2013,
	title = {A rewriting point of view on strategies},
	url = {http://arxiv.org/abs/1303.0796},
	urldate = {2015-01-19},
	journal = {arXiv preprint arXiv:1303.0796},
	author = {Kirchner, Hélene},
	year = {2013},
}

@article{balland_effective_2014,
	title = {Effective strategic programming for {Java} developers},
	volume = {44},
	url = {http://onlinelibrary.wiley.com/doi/10.1002/spe.2159/full},
	number = {2},
	urldate = {2015-01-19},
	journal = {Software: Practice and Experience},
	author = {Balland, Emilie and Moreau, Pierre-Etienne and Reilles, Antoine},
	year = {2014},
	pages = {129--162},
}

@inproceedings{farmer_hermit_2012,
	title = {The {HERMIT} in the machine: {A} plugin for the interactive transformation of {GHC} core language programs},
	volume = {47},
	shorttitle = {The {HERMIT} in the machine},
	url = {http://dl.acm.org/citation.cfm?id=2364508},
	urldate = {2015-01-19},
	booktitle = {{ACM} {SIGPLAN} {Notices}},
	publisher = {ACM},
	author = {Farmer, Andrew and Gill, Andy and Komp, Ed and Sculthorpe, Neil},
	year = {2012},
	pages = {1--12},
}

@techreport{mametjanov_type-checking_2009,
	title = {Type-checking {Term} {Rewriting} {Strategies}},
	url = {http://cs.unomaha.edu/trpt/2009/cst-2009-3.pdf},
	urldate = {2015-01-19},
	institution = {Technical Report cst-2009-3, University of Nebraska at Omaha},
	author = {Mametjanov, Azamat and Winter, Victor},
	year = {2009},
}

@inproceedings{kaiser_isabelle/hol-based_2009,
	title = {An {Isabelle}/{HOL}-based model of stratego-like traversal strategies},
	url = {http://dl.acm.org/citation.cfm?id=1599423},
	urldate = {2015-01-19},
	booktitle = {Proceedings of the 11th {ACM} {SIGPLAN} conference on {Principles} and practice of declarative programming},
	publisher = {ACM},
	author = {Kaiser, Markus and Lämmel, Ralf},
	year = {2009},
	pages = {93--104},
}

@incollection{bagge_walk_2013,
	title = {Walk {Your} {Tree} {Any} {Way} {You} {Want}},
	url = {http://link.springer.com/chapter/10.1007/978-3-642-38883-5_3},
	urldate = {2015-01-19},
	booktitle = {Theory and {Practice} of {Model} {Transformations}},
	publisher = {Springer},
	author = {Bagge, Anya Helene and Lämmel, Ralf},
	year = {2013},
	pages = {33--49},
}

@phdthesis{brown_tool_2008,
	title = {Tool support for refactoring haskell programs},
	url = {http://www.cs.kent.ac.uk/projects/refactor-fp/publications/ChrisThesis.pdf},
	urldate = {2015-01-19},
	school = {University of Kent},
	author = {Brown, Christopher Mark},
	year = {2008},
}

@article{lammel_programming_2009,
	title = {Programming {Errors} in {Traversal} {Programs} {Over} {Structured} {Data}},
	volume = {238},
	issn = {1571-0661},
	url = {http://dx.doi.org/10.1016/j.entcs.2009.09.045},
	doi = {10.1016/j.entcs.2009.09.045},
	abstract = {Traversal strategies provide an established means of describing automated queries, analyses, transformations, and other non-trivial computations on deeply structured data (including, most notably, data representations of software artifacts such as programs). The resulting traversal programs are prone to programming errors. We are specifically concerned with errors that go beyond classic type errors, in particular: (i) divergence of traversal, (ii) unintentional extent of traversal into data, (iii) trivial traversal results, (iv) inapplicability of the constituents of a traversal program along traversal. We deliver a taxonomy of programming errors, and start attacking some of them by refinements of traversal programming.},
	number = {5},
	urldate = {2015-01-19},
	journal = {Electron. Notes Theor. Comput. Sci.},
	author = {Lämmel, Ralf and Thompson, Simon and Kaiser, Markus},
	month = oct,
	year = {2009},
	keywords = {Generic programming, Scrap Your Boilerplate, Static program analysis, Strafunski, Stratego, Term rewriting, Traversal programming, Traversal strategies, type systems},
	pages = {135--153},
}

@inproceedings{mametjanov_more_2011,
	title = {More precise typing of rewrite strategies},
	url = {http://dl.acm.org/citation.cfm?id=1988786},
	urldate = {2015-01-19},
	booktitle = {Proceedings of the {Eleventh} {Workshop} on {Language} {Descriptions}, {Tools} and {Applications}},
	publisher = {ACM},
	author = {Mametjanov, Azamat and Winter, Victor and Lämmel, Ralf},
	year = {2011},
	pages = {3},
}

@article{lister_multi-national_2004,
	title = {A multi-national study of reading and tracing skills in novice programmers},
	volume = {36},
	url = {http://portal.acm.org/citation.cfm?doid=1044550.1041673},
	doi = {10.1145/1044550.1041673},
	abstract = {... as a consequence of poor teaching at that institution , it is difficult to dismiss a  multinational  study . ... 3.4 Relative Performance Across Institutions At the heart of any multi - institutional  study is the assumption ... Students at the base institution are routinely given a pool of practice MCQs ...},
	number = {4},
	journal = {ACM SIGCSE Bulletin},
	author = {Lister, Raymond and Adams, Elizabeth S and Fitzgerald, Sue and Fone, William and Hamer, John and Lindholm, Morten and McCartney, Robert and Moström, Jan Erik and Sanders, Kate and Seppälä, Otto and Simon, Beth and Thomas, Lynda},
	month = jun,
	year = {2004},
	keywords = {4star},
	pages = {119--150},
}

@article{wilson_attention_2007,
	title = {Attention {During} {Lectures}: {Beyond} {Ten} {Minutes}},
	abstract = {Many authors claim that students' attention declines approximately 10 to 15 min into lectures. To evaluate this claim, we reviewed several types of studies including studies of student note taking, observations of students during lectures, and self-reports of student attention, as well as studies using physiological measures of attention. We found that the research on which this estimate is based provides little support for the belief that students' attention declines after 10 to 15 min. Most studies failed to account for individual differences in attention. Our findings indicate that instructors should take into account individual dif},
	author = {Wilson, Karen and Korn, James H},
	month = dec,
	year = {2007},
}

@book{peyton_jones_implementing_1992,
	title = {Implementing {Functional} {Languages}: {A} {Tutorial}},
	publisher = {Prentice Hall},
	author = {Peyton Jones, Simon and Lester, David},
	month = jan,
	year = {1992},
}

@article{pirolli_learning_2009,
	title = {Learning {Strategies} and {Transfer} in the {Domain} of {Programming}},
	volume = {12},
	url = {http://www.tandfonline.com/doi/abs/10.1207/s1532690xci1203_2},
	doi = {10.1207/s1532690xci1203_2},
	abstract = {We report two studies involving an intelligent tutoring system for Lisp (the Camegie Mellon University Lisp Tutor). In Experiment 1, we developed a model, based on production system theories of transfer and analogical problem solving, that accounts for effects of instructional examples, the transfer of cognitive skills across programming problems, and practice effects. In Experiment 2, we analyzed protocols collected from subjects as they processed instructional texts and examples before working with the Lisp Tutor and protocols collected after subjects solved each programming problem. The results suggest that the acquisition of cognitive skills is facilitated by high degrees of metacognition, which includes higher degrees of monitoring states of knowledge, more self-generated explanation goals and strategies, and greater attention to the instructional structure. Improvement in skill acquisition is also strongly related to the generation of explanations connecting the example material to the abstract term...},
	number = {3},
	journal = {dx.doi.org},
	author = {Pirolli, Peter and Recker, Margaret},
	month = dec,
	year = {2009},
	pages = {235--275},
}

@article{garrigue_ambivalent_2013,
	title = {Ambivalent types for principal type inference with {GADTs}},
	url = {http://link.springer.com/chapter/10.1007/978-3-319-03542-0_19},
	abstract = {Abstract GADTs , short for Generalized Algebraic DataTypes, which allow constructors of algebraic datatypes to be non-surjective, have many useful applications. However, pattern matching on GADTs introduces local type equality assumptions, which are a source of  ...},
	journal = {Programming Languages and Systems},
	author = {Garrigue, J and Rémy, D},
	month = jan,
	year = {2013},
}

@inproceedings{cirstea_matching_2001,
	title = {Matching {Power}},
	abstract = {In this paper we give a simple and uniform presentation of the rewriting calculus, also called rho-calculus. In addition to its simplicity, this formulation computations explicitly allows us to encode complex structures such as lists, sets, and objects. We provide extensive examples of the calculus, and we focus on its ability to represent some object oriented calculi, namely the Lambda Calculus of Objects of Fisher, Honsell, and Mitchell, and the Object Calculus of Abadi and Cardelli. Furthermore, the calculus allows us to get object oriented constructions unreachable in other calculi. In summa, we intend to show that because of its matching ability, the rho-calculus represents a ``lingua franca'' to naturally encode many paradigms of computations. This enlightens the capabilities of the rewriting calculus based language ELAN to be used as a logical as well as powerful semantical framework.},
	publisher = {Springer-Verlag},
	author = {Cirstea, Horatiu and Kirchner, Claude and Liquori, Luigi},
	month = jan,
	year = {2001},
}

@book{reynolds_theories_1998,
	title = {Theories of {Programming} {Languages}},
	publisher = {Cambridge University Press},
	author = {Reynolds, J C},
	month = jan,
	year = {1998},
}

@techreport{stump_rogue_2003,
	title = {Rogue {Decision} {Procedures}},
	url = {citeseer.ist.psu.edu/stump03rogue.html},
	author = {Stump, Aaron and Deivanayagam, A and Kathol, S and Lingelbach, D and Schobel, D},
	month = jan,
	year = {2003},
}

@article{barthe_pure_2003,
	title = {Pure patterns type systems},
	volume = {38},
	url = {http://doi.acm.org/10.1145/640128.604152},
	doi = {10.1145/640128.604152},
	number = {1},
	journal = {SIGPLAN Notices},
	author = {Barthe, Gilles and Cirstea, Horatiu and Kirchner, Claude and Liquori, Luigi},
	month = jan,
	year = {2003},
	pages = {250--261},
}

@inproceedings{jay_type_2006,
	title = {Type variables simplify sub-typing},
	author = {Jay, Barry},
	month = jan,
	year = {2006},
}

@inproceedings{stump_rogue_nodate,
	title = {From {Rogue} to {MicroRogue}},
	author = {Stump, Aaron and Besand, Ryan and Brodman, James and Hseu, Jonathan and Kinnersley, Bill},
}

@techreport{peyton_jones_haskell98_nodate,
	title = {The {Haskell98} {Report}},
	institution = {online},
	author = {Peyton Jones, Simon},
}

@article{kiselyov_haskells_2005,
	title = {Haskell's overlooked object system},
	author = {Kiselyov, Oleg and Lämmel, Ralf},
	month = jan,
	year = {2005},
}

@article{syme_extensible_2007,
	title = {Extensible pattern matching via a lightweight language extension},
	volume = {42},
	number = {9},
	journal = {Proceedings of the ICFP'07 conference},
	author = {Syme, D and Neverov, G and Margetson, J},
	month = jan,
	year = {2007},
	keywords = {pattern compilation, plrg},
	pages = {29--40},
}

@misc{visser_quick_nodate,
	title = {A {Quick} {Introduction} to {SDF}},
	url = {ftp://ftp.stratego-language.org/pub/stratego/docs/sdfintro.pdf},
	journal = {ftp.stratego-language.org},
	author = {Visser, Joost and Scheerder, Joroen},
}

@article{waddell_fixing_2005,
	title = {Fixing {Letrec}: {A} {Faithful} {Yet} {Efficient} {Implementation} of {Scheme}'s {Recursive} {Binding} {Construct}},
	volume = {V18},
	url = {http://dx.doi.org/10.1007/s10990-005-4878-3},
	doi = {10.1007/s10990-005-4878-3},
	number = {3},
	journal = {Higher-Order and Symbolic Computation},
	author = {Waddell, Oscar and Sarkar, Dipanwita and Dybvig, R Kent},
	month = jan,
	year = {2005},
	pages = {299--326},
}

@inproceedings{cirstea_rewriting_2003,
	title = {Rewriting {Calculus} with {Fixpoints}: {Untyped} and {First}-order {Systems}},
	volume = {3085},
	abstract = {The rewriting calculus, also called rho-calculus, is a framework embed ding lambda-calculus and rewriting capabilities, by allowing abstraction not only on variables but also on patterns. The higher-order mechanisms of the lambda-calculus and the pattern matching facilities of the rewriting are then both available at the same level. Many type systems for the lambda-calculus can be generalized to the rho-calculus: in this paper, we study extensively a first-order rho-calculus {\textbackslash}`a la Church, called stk. The type system of stk allows one to type (object oriented flavored) fixpoints, leading to an expressive and safe calculus. In particular, using pattern matching, one can encode and typecheck term rewriting systems in a natural and automatic way. Therefore, we can see our framework as a starting point for the theoretical basis of a powerful typed rewriting-based language.},
	publisher = {Springer},
	author = {Cirstea, Horatiu and Liquori, Luigi and Wack, Benjamin},
	month = jan,
	year = {2003},
}

@inproceedings{jay_methods_2004,
	title = {Methods as pattern-matching functions},
	url = {http://www.doc.ic.ac.uk/~scd/FOOL11/patterns.pdf},
	author = {Jay, Barry},
	month = jan,
	year = {2004},
	pages = {16 pp},
}

@phdthesis{dolstra_notitle_2001,
	address = {Utrecht, The Netherlands},
	school = {Institute of Information and Computing Sciences, Utrecht University},
	author = {Dolstra, Eelco},
	month = aug,
	year = {2001},
}

@techreport{noauthor_programming_nodate,
	title = {Programming in {Scala}},
}

@article{chi_eliciting_1994,
	title = {Eliciting {Self}‐{Explanations} {Improves} {Understanding}},
	volume = {18},
	url = {http://doi.wiley.com/10.1207/s15516709cog1803_3},
	doi = {10.1207/s15516709cog1803_3},
	abstract = {Processes of learning are often considered in terms of either comprehension, skill acquisition, or both. In the case of comprehension, the declarative information that is to be understood (such as a story) maps onto knowledge that is already stored and organized in ...},
	number = {3},
	journal = {Cognitive Science},
	author = {Chi, Michelene T H and Leeuw, Nicholas and Chiu, Mei Hung and Lavancher, Christian},
	month = jul,
	year = {1994},
	pages = {439--477},
}

@book{pierce_types_2002,
	address = {Cambridge, Massachusetts London, England},
	title = {Types and {Programming} {Languages}},
	publisher = {The MIT Press},
	author = {Pierce, Benjamin C},
	month = jan,
	year = {2002},
}

@book{bligh_whats_1998,
	title = {What's the {Use} of {Lectures}?},
	url = {http://books.google.com.au/books/about/What_s_the_Use_of_Lectures.html?id=l-xxxqZXUU8C},
	abstract = {... They clearly believe in the need to practice the skills and that the practice takes a long time. ... are not as effective as discussion methods to promote thought; * changing student attitudes should not normally be the major objective of a lecture ; and * lectures are ineffective to ...},
	author = {Bligh, Donald A},
	month = jan,
	year = {1998},
}

@article{noauthor_notitle_nodate,
}

@techreport{noauthor_scala_nodate,
	title = {Scala by {Example}},
}

@article{jones_typing_nodate,
	title = {Typing {Haskell} in {Haskell}},
	author = {Jones, Mark P},
}

@inproceedings{le_botlan_mlf:_2003,
	title = {\{{MLF}\}: raising \{{ML}\} to the power of system \{{F}\}},
	volume = {38},
	isbn = {1581137567},
	url = {http://portal.acm.org/citation.cfm?doid=944705.944709},
	doi = {10.1145/944705.944709},
	abstract = {We propose a type system MLF that generalizes ML with first-class polymorphism as in System F. Expressions may contain second-order type annotations. Every typable expression admits a principal type, which however depends on type annotations},
	publisher = {ACM  Request Permissions},
	author = {Le Botlan, Didier and Rémy, Didier},
	month = aug,
	year = {2003},
	keywords = {higher ranked types},
	pages = {27--38},
}

@article{gale_elevator_2006,
	title = {The elevator talk},
	volume = {13},
	url = {http://doi.acm.org/10.1145/1125864.1125905},
	doi = {10.1145/1125864.1125905},
	number = {3},
	journal = {interactions},
	author = {Gale, Carolyn},
	month = jan,
	year = {2006},
	pages = {65--65},
}

@inproceedings{hughes_making_1995,
	title = {Making choices lazily},
	publisher = {ACM Press},
	author = {Hughes, J and Moran, A},
	month = jun,
	year = {1995},
	pages = {108--119},
}

@article{douence_systematic_1998,
	title = {A {Systematic} {Study} of {Functional} {Language} {Implementations}},
	volume = {20},
	url = {citeseer.ist.psu.edu/emi98systematic.html},
	number = {2},
	journal = {ACM Transactions on Programming Languages and Systems (TOPLAS)},
	author = {Douence, Rémi and Fradet, Pascal},
	month = mar,
	year = {1998},
	pages = {344--387},
}

@inproceedings{hinze_new_2000,
	title = {A new approach to generic functional programming},
	url = {http://dl.acm.org/citation.cfm?id=325709},
	abstract = {... A generic functional program is essentially a collection of type - indexed values- typically functions -that are defined by induction on the structure of types. A ... Comparison functions are typical examples of type - indexed values. The ...},
	author = {Hinze, Ralf},
	month = jan,
	year = {2000},
}

@inproceedings{hartel_benchmarking_1993,
	title = {Benchmarking {Implementations} of {Lazy} {Functional} {Languages}},
	url = {citeseer.ist.psu.edu/hartel93benchmarking.html},
	author = {Hartel, Pieter H and Langendoen, Koen},
	month = jan,
	year = {1993},
	pages = {341--349},
}

@article{hartley_observations_1967,
	title = {{SOME} {OBSERVATIONS} {ON} {THE} {EFFICIENCY} {OF} {LECTURING}},
	volume = {20},
	url = {http://dx.doi.org/10.1080/0013191670200103},
	doi = {10.1080/0013191670200103},
	number = {1},
	journal = {Educational Review},
	author = {Hartley, James and Cameron, Alan},
	month = jan,
	year = {1967},
	pages = {30--37},
}

@article{denning_recentering_2005,
	title = {Recentering computer science},
	volume = {48},
	url = {http://portal.acm.org/citation.cfm?doid=1096000.1096018},
	doi = {10.1145/1096000.1096018},
	abstract = {The recent decreases of enrollment in computer science programs signal a chasm between our historical emphasis on programming and the contemporary concerns of those choosing careers},
	number = {11},
	journal = {Communications of the ACM},
	author = {Denning, Peter and McGettrick, Andrew},
	month = nov,
	year = {2005},
	pages = {15--19},
}

@inproceedings{appel_standard_1987,
	title = {A standard {ML} compiler},
	isbn = {0-387-18317-5},
	url = {http://www.worldcat.org/title/functional-programming-languages-and-computer-architecture-portland-oregon-usa-september-14-16-1987-proceedings/oclc/17807287},
	publisher = {Springer-Verlag},
	author = {Appel, Andrew W and MacQueen, David B},
	month = jan,
	year = {1987},
	pages = {301--324},
}

@inproceedings{berglund_students_2008,
	title = {Students learn {CS} in different ways: insights from an empirical study},
	volume = {78 , Volume 78},
	url = {http://portal.acm.org/citation.cfm?id=1379249.1379271&coll=DL&dl=GUIDE&CFID=389450450&CFTOKEN=13331302},
	publisher = {Australian Computer Society, Inc},
	author = {Berglund, Anders and Wiggberg, Mattias},
	month = jan,
	year = {2008},
}

@article{noauthor_oberon-0_2014,
	title = {Oberon-0 in {Kiama}},
	month = apr,
	year = {2014},
	pages = {1--14},
}

@article{peyton_jones_transformation-based_1998,
	title = {A transformation-based optimiser for {Haskell}},
	volume = {32},
	url = {citeseer.ist.psu.edu/peytonjones98transformationbased.html},
	number = {1--3},
	journal = {Science of Computer Programming},
	author = {Peyton Jones, Simon and Santos, A},
	month = jan,
	year = {1998},
	pages = {3--47},
}

@techreport{noauthor_history_nodate,
	title = {A {History} of {Haskell} {DRAFT}},
}

@article{kumar_changing_2013,
	title = {The changing, not evolving pedagogy of {CS1}},
	volume = {4},
	url = {http://dl.acm.org/citation.cfm?doid=2505990.2505994},
	doi = {10.1145/2505990.2505994},
	number = {3},
	journal = {Inroads},
	author = {Kumar, Deepak},
	month = sep,
	year = {2013},
	pages = {36--37},
}

@article{peyton_jones_practical_2007,
	title = {Practical type inference for arbitrary-rank types},
	volume = {17},
	url = {http://www.journals.cambridge.org/abstract_S0956796806006034},
	doi = {10.1017/S0956796806006034},
	abstract = {Haskell's popularity has driven the need for ever more expressive type system features, most of which threaten the decidability and practicality of Damas-Milner type inference. One such feature is the ability to write functions with higher-rank types},
	number = {1},
	journal = {Journal of Functional Programming},
	author = {Peyton Jones, Simon and Vytiniotis, Dimitrios and Weirich, Stephanie and Shields, Mark},
	month = jan,
	year = {2007},
	pages = {1},
}

@article{dunlosky_strengthening_2013,
	title = {Strengthening the {Student} {Toolbox}},
	url = {http://www.aft.org/pdfs/americaneducator/fall2013/dunlosky.pdf},
	abstract = {It's the night before her biology exam, and the high school student has just begun to study. she takes out her highlighter and reads her textbook, marking it up as she goes along. she rereads sentences that seem most important and stays up most of the night, just hoping to ...},
	journal = {AMERICAN EDUCATOR},
	author = {Dunlosky, J},
	month = jan,
	year = {2013},
	keywords = {5star},
}

@article{chi_selfexplanations:_1989,
	title = {Self‐{Explanations}: {How} {Students} {Study} and {Use} {Examples} in {Learning} to {Solve} {Problems}},
	volume = {13},
	url = {http://doi.wiley.com/10.1207/s15516709cog1302_1},
	doi = {10.1207/s15516709cog1302_1},
	abstract = {146 CHI, BASSOK. LEWIS, REIMANN, AND GLASER as solving problems . This process of conversion is essentially a form of constructive self -instruction (Simon, 1979). Although the research on the quality of good teaching (such as that which attempts to identify the ...},
	number = {2},
	journal = {Cognitive Science},
	author = {Chi, Michelene T H and Bassok, Miriam and Lewis, Matthew W and Reimann, Peter and Glaser, Robert},
	month = apr,
	year = {1989},
	pages = {145--182},
}

@techreport{jay_pattern_2007,
	title = {Pattern {Calculus} computing with functions and structures {Part} {I} and most of {Part} {II} ({UNDER} {CONSTRUCTION})},
	institution = {personal correspondance},
	author = {Jay, Barry},
	month = jan,
	year = {2007},
}

@inproceedings{kirchner_anchoring_2006,
	title = {Anchoring {Modularity} in {HTML}},
	volume = {157},
	publisher = {Electronic Notes in Theoretical Computer Science},
	author = {Kirchner, Claude and Kirchner, Hélène and Santana, Anderson},
	month = may,
	year = {2006},
	pages = {133--146},
}

@incollection{hinze_type-indexed_2002,
	address = {Berlin, Heidelberg},
	title = {Type-{Indexed} {Data} {Types}},
	volume = {2386},
	isbn = {978-3-540-43857-1},
	url = {http://link.springer.com/10.1007/3-540-45442-X_10},
	abstract = {... Generally, we believe that type - indexed data types are just as impor- tant as type - indexed functions . Page 4. Type - Indexed Data Types 151 ... There is little related work on type - indexed data types. Type - indexed  functions [25,2,28,8,17] were introduced more than a decade ago. ...},
	booktitle = {Mathematics of {Program} {Construction}},
	publisher = {Springer Berlin Heidelberg},
	author = {Hinze, Ralf and Jeuring, Johan and Löh, Andres},
	month = jun,
	year = {2002},
	pages = {148--174},
}

@article{atkinson_transitioning_2003,
	title = {Transitioning {From} {Studying} {Examples} to {Solving} {Problems}: {Effects} of {Self}-{Explanation} {Prompts} and {Fading} {Worked}-{Out} {Steps}.},
	volume = {95},
	url = {http://psycnet.apa.org/journals/edu/95/4/774.html},
	doi = {10.1037/0022-0663.95.4.774},
	abstract = {Abstract 1. Although research has demonstrated that successively fading or successively removing more and more worked-out solution steps as learners transition from relying on examples to independent problem solving reliably fosters performance on near-transfer ...},
	number = {4},
	journal = {Journal of Educational Psychology},
	author = {Atkinson, Robert K and Renkl, Alexander and Merrill, Mary Margaret},
	month = dec,
	year = {2003},
	pages = {774--783},
}

@phdthesis{bravenboer_notitle_2008,
	school = {Institute for Programming research and Algorithmics},
	author = {Bravenboer, Martin},
	month = jan,
	year = {2008},
}

@article{shivers_multi-return_2006,
	title = {Multi-return function call},
	volume = {16},
	number = {4-5},
	journal = {Journal of Functional Programming},
	author = {SHIVERS, OLIN and FISHER, DAVID},
	month = jan,
	year = {2006},
	pages = {547--582},
}

@article{jay_pattern_2004,
	title = {The {Pattern} {Calculus}},
	volume = {26},
	number = {6},
	journal = {ACM Transactions on Programming Languages and Systems (TOPLAS)},
	author = {Jay, Barry},
	month = nov,
	year = {2004},
	pages = {911--937},
}

@inproceedings{magalhaes_generic_2014,
	title = {Generic {Generic} {Programming}},
	volume = {8342},
	doi = {10.1007/978-3-319-04132-2_15},
	booktitle = {Practical {Aspects} of {Declarative} {Programming}},
	author = {Magalhães, José Pedro and Löh, Andres},
	month = jan,
	year = {2014},
	keywords = {advanced type classes, generics, ghc, multirec, syb},
}

@article{harper_type_1993,
	title = {On the type structure of standard {ML}},
	volume = {15},
	url = {http://doi.acm.org/10.1145/169701.169696},
	doi = {10.1145/169701.169696},
	number = {2},
	journal = {ACM Transactions on Programming Languages and Systems (TOPLAS)},
	author = {Harper, Robert and Mitchell, John C},
	month = jan,
	year = {1993},
	pages = {211--252},
}

@inproceedings{balland_optimizing_2006,
	title = {Optimizing {Pattern} {Matching} {Compilation} by {Program} {Transformation}},
	publisher = {Electronic Communications of EASST},
	author = {Balland, Emilie and Moreau, Pierre-Etienne},
	editor = {Favre, Jean-Marie and Heckel, Reiko and Mens, Tom},
	month = jan,
	year = {2006},
}

@techreport{jeuring_comparing_2006,
	title = {Comparing approaches to generic programming in \{{H}\}askell},
	url = {http://www.cs.uu.nl/research/techreps/repo/CS-2006/2006-022.pdf},
	author = {Jeuring, Johan and Löh, Andres and Hinze, Ralf},
	month = jan,
	year = {2006},
}

@inproceedings{peyton_jones_scrap_2003,
	title = {Scrap your boilerplate: a practical design pattern for generic programming},
	booktitle = {{TLDI}},
	publisher = {ACM Press},
	author = {Peyton Jones, Simon and Lämmel, Ralf},
	month = jan,
	year = {2003},
}

@book{meyerovich_fast_2010,
	address = {New York, New York, USA},
	series = {the 19th international conference},
	title = {Fast and parallel webpage layout},
	isbn = {978-1-60558-799-8},
	url = {http://portal.acm.org/citation.cfm?doid=1772690.1772763},
	abstract = {Abstract The web browser is a CPU-intensive program. Especially on mobile devices, webpages load too slowly, expending significant time in processing a document's appearance. Due to power constraints, most hardware-driven speedups will come in the ...},
	publisher = {ACM},
	author = {Meyerovich, Leo A and Bodik, Rastislav},
	month = apr,
	year = {2010},
	keywords = {attribute grammars},
}

@techreport{plotkin_structural_1981,
	address = {University of Aarhus},
	title = {A {Structural} {Approach} to {Operational} {Semantics}},
	url = {citeseer.ist.psu.edu/article/plotkin81structural.html},
	author = {Plotkin, G D},
	month = jan,
	year = {1981},
}

@techreport{jay_pattern_nodate,
	title = {Pattern {Matching} against functions},
	author = {Jay, Barry},
}

@techreport{noauthor_epigram_nodate,
	title = {The {Epigram} {Prototype}: a nod and two winks},
}

@article{tullsen_first_2000,
	title = {First {Class} {Patterns}},
	volume = {1753},
	journal = {Lecture Notes in Computer Science},
	author = {Tullsen, M},
	month = jan,
	year = {2000},
	pages = {1},
}

@inproceedings{launchbury_natural_1993,
	title = {A {Natural} {Semantics} for {Lazy} {Evaluation}},
	url = {citeseer.ist.psu.edu/launchbury93natural.html},
	author = {Launchbury, John},
	month = jan,
	year = {1993},
	pages = {144--154},
}

@incollection{hammond_implementing_1990,
	address = {London},
	title = {Implementing {Haskell} {Type} {Classes}},
	isbn = {978-3-540-19609-9},
	url = {http://link.springer.com/10.1007/978-1-4471-3166-3_18},
	abstract = {Abstract This paper describes the implementation of the type class mechanism for the functional language Haskell. A simple introduction to type classes discusses the methods used to select operators and dictionaries in the Glasgow Haskell compiler. A solution to ...},
	booktitle = {Functional {Programming}},
	publisher = {Springer London},
	author = {Hammond, Kevin and Blott, S},
	month = jan,
	year = {1990},
	pages = {265--286},
}

@article{cirstea_rho-calculus_2005,
	title = {A {Rho}-{Calculus} of explicit constraint application},
	url = {http://hal.inria.fr/view_by_stamp.php?label=LORIA&langue=fr&action_todo=view&id=inria-00000628&version=1#},
	abstract = {Theoretical presentations of the rho-calculus often treat the matching constraint computations as an atomic operation although matching constraints are explicitly expressed. Actual implementations have to take a much more realistic view: computations needed in order to find the solutions of a matching equation can have an important impact on the (efficiency of the) calculus for some matching theories and the substitution application usually involves a term traversal. Following the works on explicit substitutions in the -calculus, we present two versions of the rho-calculus, one with explicit matching and one with explicit substitutions, together with a version that combines the two and considers efficiency issues and more precisely the composition of substitutions. The approach is general, allowing the extension to various matching theories. We establish the confluence of the calculus and the termination of the explicit constraint handling and application sub-calculus.},
	journal = {To appear in the journal of Higher-Order and Symbolic Computation},
	author = {Cirstea, Horatiu and Faure, Germain and Kirchner, Claude},
	month = jan,
	year = {2005},
}

@inproceedings{borovansky_overview_1998,
	title = {An {Overview} of {ELAN}},
	author = {Borovansky, P and Kirchner, Claude and Kirchner, H and Moreau, Pierre-Etienne and Ringeissen, C},
	editor = {Kirchner, Claude and Kirchner, H},
	month = sep,
	year = {1998},
}

@inproceedings{huang_programming_2006,
	title = {Programming with {Hetrogenous} {Structures}: {Manipulating} {XML} data using bondi [{Extended} {Abstract}]},
	publisher = {Australian Computer Society, Inc.},
	author = {Huang, F U and Jay, Barry and Skillicorn, D B},
	month = jan,
	year = {2006},
}

@article{henglein_type_1993,
	title = {Type inference with polymorphic recursion},
	volume = {15},
	url = {http://www.diku.dk/hjemmesider/ansatte/henglein/papers/henglein1993a.pdf},
	doi = {10.1145/169701.169692},
	abstract = {We present some reasons why type inference with polymorphic recursion appears to be practical despite its undecidability. This also sheds some light on the observed practicality of ML in the face of recent theoretical intractability results. Finally, we exhibit a ...},
	number = {2},
	journal = {Advanced Functional Programming: First International Spring School on Advanced Functional Programming Techniques, Båstad, Sweden, May 24-30, 1995: Tutorial Text},
	author = {Henglein, Fritz},
	month = apr,
	year = {1993},
	pages = {253--289},
}

@techreport{noauthor_good_nodate,
	title = {Good {Ideas}, {Through} the {Looking} {Glass}},
}

@article{boustedt_threshold_2007,
	title = {Threshold concepts in computer science: do they exist and are they useful?},
	volume = {39},
	issn = {1-59593-361-1},
	url = {http://portal.acm.org/citation.cfm?doid=1227310.1227482},
	doi = {10.1145/1227310.1227482},
	abstract = {... We have identified two Threshold  Concepts , or perhaps broad areas within which thresholds exist : pointers and object ... These were the terms our subjects used for concepts  they identified, but these concepts – object-oriented programming in particular – are very broad. ...},
	number = {1},
	journal = {ACM SIGCSE Bulletin},
	author = {Boustedt, Jonas and Eckerdal, Anna and McCartney, Robert and Moström, Jan Erik and Ratcliffe, Mark and Sanders, Kate and Zander, Carol},
	month = mar,
	year = {2007},
	keywords = {threshold learning outcomes},
	pages = {504--508},
}

@techreport{scott_when_2000,
	address = {Charlottesville, VA, USA},
	title = {When {Do} {Match}-compilation {Heuristics} {Matter}?},
	institution = {University of Virginia},
	author = {Scott, Kevin and Ramsey, Norman},
	month = jan,
	year = {2000},
}

@misc{osfameron_monad_nodate,
	title = {Monad {Wars}},
	url = {http://osfameron.vox.com/},
	journal = {osfameron.vox.com},
	author = {{osfameron}},
}

@book{chakravarty_associated_2005,
	series = {{ACM} {SIGPLAN} {Notices}},
	title = {Associated types with class},
	volume = {40},
	isbn = {1-58113-830-X},
	url = {http://portal.acm.org/citation.cfm?doid=1047659.1040306},
	abstract = {... Just as a top-level function that calls overloaded functions itself becomes overloaded, so a data type that mentions type - indexed types itself becomes type  indexed . We call such type - indexed data types associated top-level types. ...},
	publisher = {ACM},
	author = {Chakravarty, Manuel M T and Keller, Gabriele and Peyton Jones, Simon and Marlow, Simon and Keller, Gabriele},
	month = jan,
	year = {2005},
}

@article{beaubouef_why_2005,
	title = {Why the high attrition rate for computer science students: some thoughts and observations},
	url = {http://dl.acm.org/citation.cfm?id=1083474},
	abstract = {... While we address some important issues for computer science retention in this paper, we do 
not discuss solutions to these problems here. It is hoped that by identifying some of the major
reasons for high attrition rates among students , these areas can be further studied, and ...},
	journal = {ACM SIGCSE Bulletin},
	author = {Beaubouef, T and Mason, J},
	month = jan,
	year = {2005},
}

@article{noauthor_vol136.pdf_2014,
	title = {Vol136.pdf},
	month = aug,
	year = {2014},
}

@phdthesis{visser_notitle_1997,
	address = {Amsterdam},
	url = {citeseer.ist.psu.edu/visser97syntax.html},
	author = {Visser, Eelco},
	month = jan,
	year = {1997},
}

@techreport{noauthor_lambda_nodate,
	title = {Lambda {Calculus}},
}

@inproceedings{peyton_jones_scrap_2005,
	title = {Scrap your boilerplate with class: extensible generic functions},
	url = {http://doi.acm.org/10.1145/1090189.1086391},
	doi = {10.1145/1090189.1086391},
	booktitle = {th {ACM} {SIGPLAN} {International} {Conference} on {Functional} {Programming}},
	publisher = {ACM},
	author = {Peyton Jones, Simon and Lämmel, Ralf},
	month = sep,
	year = {2005},
	pages = {204--215},
}

@article{given-wilson_concurrent_2014,
	title = {A {Concurrent} {Pattern} {Calculus}},
	volume = {cs.LO},
	url = {http://arxiv.org/abs/1405.1546v3},
	doi = {10.2168/LMCS-10(3:10)2014},
	abstract = {Concurrent pattern calculus (CPC) drives interaction between processes by comparing data structures, just as sequential pattern calculus drives computation. By generalising from pattern matching to pattern unification, interaction becomes symmetrical, with information flowing in both directions. CPC provides a natural language to express trade where information exchange is pivotal to interaction. The unification allows some patterns to be more discriminating than others; hence, the behavioural theory must take this aspect into account, so that bisimulation becomes subject to compatibility of patterns. Many popular process calculi can be encoded in CPC; this allows for a gain in expressiveness, formalised through encodings.

Published in: LMCS 10 (3:10) 2014},
	journal = {arXiv.org},
	author = {Given-Wilson, Thomas and Gorla, Daniele and Jay, Barry},
	month = may,
	year = {2014},
	keywords = {pattern calculus},
}

@book{noauthor_acm_nodate,
	title = {{ACM} {SIGPLAN} {Notices}},
	isbn = {0362-1340},
	publisher = {ACM},
}

@article{peyton_jones_how_1993,
	title = {How to give a good research talk},
	volume = {28},
	number = {11},
	journal = {SIGPLAN Notices},
	author = {Peyton Jones, Simon and Hughes, John and Launchbury, John},
	month = jan,
	year = {1993},
	pages = {9--12},
}

@inproceedings{hartel_benchmarking_1995,
	title = {Benchmarking {Implementations} of {Lazy} {Functional} {Languages} {II} -- {Two} years later},
	url = {citeseer.ist.psu.edu/article/hartel93benchmarking.html},
	author = {Hartel, Pieter H},
	month = jan,
	year = {1995},
	pages = {63--68},
}

@incollection{visser_program_2004,
	title = {Program {Transformation} with {Stratego}/{XT}: {Rules}, {Strategies}, {Tools}, and {Systems} in {StrategoXT}-0.9},
	volume = {3016},
	url = {http://www.cs.uu.nl/research/techreps/UU-CS-2004-011.html},
	booktitle = {Domain-{Specific} {Program} {Generation}},
	publisher = {Spinger-Verlag},
	author = {Visser, Eelco},
	editor = {Lengauer, C and {others}},
	month = jun,
	year = {2004},
	pages = {216--238},
}

@inproceedings{balland_tom:_2007,
	title = {Tom: {Piggybacking} {Rewriting} on {Java}},
	publisher = {Springer-Verlag},
	author = {Balland, Emilie and Brauner, Paul and Kopetz, Radu and Moreau, Pierre-Etienne and Reilles, Antoine},
	month = jan,
	year = {2007},
}

@misc{peyton_jones_ghc_nodate,
	title = {{GHC} {Hackathon}},
	url = {http://hackage.haskell.org/trac/ghc/wiki/Hackathon},
	journal = {hackage.haskell.org},
	author = {Peyton Jones, Simon and Wallace, Malcolm and al, et},
}

@book{noauthor_functional_1990,
	title = {Functional {Programming}},
	isbn = {978-3-540-19609-9},
	publisher = {Springer London},
	month = jan,
	year = {1990},
}

@phdthesis{given-wilson_notitle_2007,
	school = {University of Technology, Sydney},
	author = {Given-Wilson, Thomas},
	month = jan,
	year = {2007},
}

@article{roediger_iii_critical_2011,
	title = {The critical role of retrieval practice in long-term retention},
	volume = {15},
	url = {http://linkinghub.elsevier.com/retrieve/pii/S1364661310002081},
	doi = {10.1016/j.tics.2010.09.003},
	abstract = {... and the repeated testing condition was that students attempted to retrieve the information ... learning and understanding so that knowledge can be flexibly retrieved and transferred ... Integration of retrieval  practice into educational practices has the potential to boost performance in ...},
	number = {1},
	journal = {Trends in cognitive sciences},
	author = {Roediger III, Henry L and Butler, Andrew C},
	month = jan,
	year = {2011},
	keywords = {5star},
	pages = {20--27},
}

@book{harper_compiling_1995,
	title = {Compiling polymorphism using intensional type analysis},
	publisher = {ACM Press New York, NY, USA},
	author = {Harper, R and Morrisett, G},
	month = jan,
	year = {1995},
}

@article{kesner_typed_1996,
	title = {A {Typed} {Pattern} {Calculus}},
	volume = {124},
	url = {citeseer.ist.psu.edu/kesner96typed.html},
	number = {1},
	journal = {Information and Computation},
	author = {Kesner, Delia and Puel, Laurence and Tannen, Val},
	month = jan,
	year = {1996},
	pages = {32--61},
}

@article{given-wilson_multi-polymorphic_2008,
	title = {Multi-polymorphic programming in bondi},
	author = {Given-Wilson, Thomas and Huang, Freeman and Jay, Barry},
	month = feb,
	year = {2008},
}

@inproceedings{jay_pure_2006,
	title = {Pure {Pattern} {Calculus}},
	volume = {3924/2006},
	url = {http://www-staff.it.uts.edu.au/~cbj/Publications/purepattern.pdf},
	publisher = {Springer},
	author = {Jay, Barry and Kesner, Delia},
	editor = {Sestoft, Peter},
	month = jan,
	year = {2006},
	pages = {100--114},
}

@article{mcdaniel_test-enhanced_2011,
	title = {Test-enhanced learning in a middle school science classroom: {The} effects of quiz frequency and placement.},
	volume = {103},
	url = {http://psycnet.apa.org/journals/edu/103/2/399.html},
	doi = {10.1037/a0021782},
	abstract = {Abstract 1. Typically, teachers use tests to evaluate students' knowledge acquisition. In a novel experimental study, we examined whether low-stakes testing (quizzing) can be used to foster students' learning of course content in 8th grade science classes. Students ...},
	number = {2},
	journal = {Journal of Educational Psychology},
	author = {McDaniel, Mark A and Agarwal, Pooja K and Huelser, Barbie J and McDermott, Kathleen B and Roediger III, Henry L},
	month = may,
	year = {2011},
	pages = {399--414},
}

@inproceedings{chinn_study_2010,
	title = {Study habits of {CS1} students: what do they do outside the classroom?},
	volume = {103 , Volume 103},
	url = {http://portal.acm.org/citation.cfm?id=1862219.1862229&coll=DL&dl=GUIDE&CFID=389450450&CFTOKEN=13331302},
	publisher = {Australian Computer Society, Inc},
	author = {Chinn, Donald and Sheard, Judy and Carbone, Angela and Laakso, Mikko-Jussi},
	month = jan,
	year = {2010},
}

@article{liquori_polymorphic_2005,
	title = {The polymorphic rewriting-calculus:[type checking vs. type inference]},
	url = {http://www.sciencedirect.com/science/article/pii/S157106610405296X},
	abstract = {The Rewriting - calculus (Rho- calculus ), is a minimal framework embedding Lambda- calculus and Term Rewriting Systems, by allowing abstraction on variables and patterns. The Rho- calculus fea-tures higher-order functions (from Lambda- calculus ) and pattern- ...},
	journal = {Electronic Notes in Theoretical Computer Science},
	author = {Liquori, L and Wack, B},
	month = jan,
	year = {2005},
	keywords = {rho-calculus},
}

@article{mccracken_multi-national_2001,
	title = {A multi-national, multi-institutional study of assessment of programming skills of first-year {CS} students},
	volume = {33},
	url = {http://portal.acm.org/citation.cfm?doid=572139.572181},
	doi = {10.1145/572139.572181},
	abstract = {Page 1. A  multi - national , multi - institutional  study of assessment of programming  ... One approach to scoring would be a raw assessment of whether the program works (although this is not ... In this study , the form of assessment used was the charette, a short, lab-based assignment. ...},
	number = {4},
	journal = {ACM SIGCSE Bulletin},
	author = {McCracken, Michael and Almstrum, Vicki and Diaz, Danny and Guzdial, Mark and Hagan, Dianne and Kolikant, Yifat Ben-David and Laxer, Cary and Thomas, Lynda and Utting, Ian and Wilusz, Tadeusz},
	month = dec,
	year = {2001},
	pages = {125--180},
}

@article{oliveira_type_2010,
	title = {Type classes as objects and implicits.},
	volume = {45},
	issn = {9781450302036},
	url = {http://doi.acm.org/10.1145/1869459.1869489},
	doi = {10.1145/1869459.1869489},
	number = {10},
	journal = {OOPSLA},
	author = {Oliveira, Bruno C d S and Moors, Adriaan and Odersky, Martin},
	month = jan,
	year = {2010},
	pages = {341--360},
}

@inproceedings{yu_turning_2010,
	title = {Turning exams into a learning experience},
	url = {http://dl.acm.org/citation.cfm?id=1734380},
	abstract = {Abstract Most students see exams as a stressful experience , having crammed as much as they possibly can and hoping that the material they have studied would indeed be on the exams , and the material that they did not have the time to study for, nor understand, would  ...},
	author = {Yu, B and Tsiknis, G and Allen, M},
	month = jan,
	year = {2010},
	keywords = {formative assessment},
}

@article{freeman_prescribed_2007,
	title = {Prescribed {Active} {Learning} {Increases} {Performance} in {Introductory} {Biology}},
	volume = {6},
	url = {http://www.lifescied.org/content/6/2/132.full},
	doi = {10.1187/cbe.06-09-0194},
	abstract = {Abstract We tested five course designs that varied in the structure of daily and weekly active - learning exercises in an attempt to lower the traditionally high failure rate in a gateway course for biology majors. Students were given daily multiple-choice questions and ...},
	number = {2},
	journal = {CBE-Life Sciences Education},
	author = {Freeman, Scott and O'Connor, Eileen and Parks, John W and Cunningham, Matthew and Hurley, David and Haak, David and Dirks, Clarissa and Wenderoth, Mary Pat},
	month = jun,
	year = {2007},
	pages = {132--139},
}

@book{steele_jr_rabbit:_1978,
	title = {{RABBIT}: {A} {Compiler} for {SCHEME} ({A} {Dialect} of {LISP}). {A} {Study} in {Compiler} {Optimization} {Based} on {Viewing} {LAMBDA} as {RENAME} and {Procedure} {Call} as {GOTO} {Using} the {Techniques} of {Macro} {Definition} of {Control} and {Environment} {Structures}. {Source}-to-{Source} {Transformation} {Procedure} {Integration} and {Tail}-{Recursion}},
	isbn = {227517401},
	url = {http://books.google.com.au/books?id=Y3KMPQAACAAJ&dq=intitle:Rabbit+A+Compiler+for+Scheme&hl=&cd=3&source=gbs_api},
	abstract = {We have developed a compiler for the lexically-scoped dialect of LISP known as SCHEME. The compiler knows relatively little about specific data manipulation primitives such as arithmetic operators, but concentrates on general issues of environment and control. Rather than having specialized knowledge about a large variety of control and environment constructs, the compiler handles only a small basis set which reflects the semantics of lambda-calculus. All of the traditional imperative constructs, such as sequencing, assignment, looping, GOTO, as well as many standard LISP constructs such as AND, OR, and COND, are expressed as macros in terms of the applicative basis set. A small number of optimization techniques, coupled with the treatment of function calls as GOTO statements, serve to produce code as good as that produced by more traditional compilers. The macro approach enables speedy implementation of new constructs as desired without sacrificing efficiency in the generated code.},
	author = {Steele Jr, Guy Lewis and LAB, MASSACHUSETTS INST OF TECH CAMBRIDGE ARTIFICIAL INTELLIGENCE},
	month = jan,
	year = {1978},
}

@article{findler_slideshow:_2006,
	title = {Slideshow: functional presentations},
	volume = {16},
	number = {4-5},
	journal = {Journal of Functional Programming},
	author = {FINDLER, ROBERT BRUCE and FLATT, MATTHEW},
	month = jan,
	year = {2006},
	pages = {583--619},
}

@article{hague_detecting_2014,
	title = {Detecting {Redundant} {CSS} {Rules} in {HTML5} {Applications}: {A} {Tree}-{Rewriting} {Approach}.},
	volume = {cs.LO},
	url = {http://arxiv.org/abs/1412.5143},
	abstract = {HTML5 applications normally have a large set of CSS (Cascading Style Sheets) rules for data display. Each CSS rule consists of a node selector (given in an XPath-like query language) and a declaration block (assigning values to selected nodes' display attributes). As web applications evolve, maintaining CSS files can easily become problematic. Some CSS rules will be replaced by new ones, but these obsolete (hence redundant) CSS rules often remain in the applications. Not only does this "bloat" the applications, but it also significantly increases web browsers' processing time. Most works on detecting redundant CSS rules in HTML5 applications do not consider the dynamic behaviors of HTML5 (specified in JavaScript); in fact, the only proposed method that takes these into account is dynamic analysis (a.k.a. testing), which cannot soundly prove redundancy of CSS rules. In this paper, we introduce an abstraction of HTML5 applications based on monotonic tree-rewriting and study its "redundancy problem". We establish the precise complexity of the problem and various subproblems of practical importance (ranging from P to EXP). In particular, our algorithm relies on an efficient reduction to an analysis of symbolic pushdown systems (for which highly optimised solvers are available), which yields a fast method for checking redundancy in practice. We implemented our algorithm and demonstrated its efficacy in detecting redundant CSS rules in HTML5 applications.},
	journal = {CoRR abs/1412.5143},
	author = {Hague, Matthew and Lin, Anthony Widjaja and Ong, Luke},
	month = jan,
	year = {2014},
}

@article{thompson_blooms_2008,
	title = {Bloom's taxonomy for {CS} assessment},
	url = {http://dl.acm.org/citation.cfm?id=1379265},
	abstract = {Abstract Bloom's Taxonomy is difficult to apply consistently to assessment tasks in introductory programming courses. The Bloom taxonomy is a valuable tool that could enable analysis and discussion of programming assessment if it could be interpreted consistently.  ...},
	journal = {… Australasian computing …},
	author = {Thompson, E and Luxton-Reilly, A and Whalley, J L},
	month = jan,
	year = {2008},
}

@inproceedings{alimarine_generic_2002,
	title = {A {Generic} {Programming} {Extension} for \{{Clean}\}},
	isbn = {3-540-43537-9},
	url = {http://dl.acm.org/citation.cfm?id=647980.743392},
	publisher = {Springer-Verlag},
	author = {Alimarine, Artem and Plasmeijer, M J},
	month = jan,
	year = {2002},
	pages = {168--185},
}

@inproceedings{peyton_jones_glasgow_nodate,
	title = {The {Glasgow} {Haskell} compiler: a technical overview},
	url = {citeseer.ist.psu.edu/jones92glasgow.html},
	author = {Peyton Jones, Simon and Hall, Cordelia V and Hammond, Kevin and Partain, Will and Wadler, Philip},
	month = jan,
}

@article{kaczmarczyk_percolations_2011,
	title = {{PERCOLATIONS} {Why} {I} don't want to teach {CS1} anymore},
	volume = {2},
	url = {http://dl.acm.org/citation.cfm?doid=1963533.1963542},
	doi = {10.1145/1963533.1963542},
	number = {2},
	journal = {Inroads},
	author = {Kaczmarczyk, Lisa C},
	month = jun,
	year = {2011},
	pages = {26},
}

@techreport{noauthor_epigram:_nodate,
	title = {Epigram: {Practical} {Programming} with {Dependent} {Types}},
}

@techreport{dijkstra_how_1975,
	title = {How do we tell truths that might hurt?},
	author = {Dijkstra, Edsger W},
	month = jan,
	year = {1975},
}

@inproceedings{shao_overview_1997,
	title = {An {Overview} of the {FLINT}/{ML} {Compiler}},
	url = {citeseer.ist.psu.edu/shao97overview.html},
	author = {Shao, Zhong},
	month = jan,
	year = {1997},
}

@article{wadler_theorems_1989,
	title = {Theorems for {Free}!},
	issn = {0897913280},
	url = {http://doi.acm.org/10.1145/99370.99404},
	doi = {10.1145/99370.99404},
	journal = {Functional Programming Languages and Computer Architecture},
	author = {Wadler, Philip},
	month = jan,
	year = {1989},
	pages = {347--359},
}

@techreport{chakravarty_instant_2009,
	title = {Instant {Generics}: {Fast} and {Easy}},
	author = {Chakravarty, Manuel M T and Ditu, Gabriel C and Leshchinskiy, Roman},
	month = jan,
	year = {2009},
}

@techreport{noauthor_typing_nodate,
	title = {Typing five styles of polymorphism},
}

@article{perkins_many_1999,
	title = {The {Many} {Faces} of {Constructivism}.},
	volume = {57},
	url = {http://eric.ed.gov/?id=EJ597073},
	abstract = {Although most constructivist classrooms feature active, social, and creative learning, different kinds of knowledge (inert, ritual, conceptually difficult, and foreign) invite varied constructivist responses, not one standard approach. Constructivism is pragmatic and ...},
	number = {3},
	journal = {Educational leadership},
	author = {Perkins, David},
	month = jan,
	year = {1999},
	keywords = {threshold learning outcomes},
	pages = {6--11},
}

@techreport{jay_polymorphic_2000,
	address = {P.O. Box 123, Broadway NSW 2007, Australia},
	title = {The {Polymorphic} {Imperative}},
	url = {http://citeseer.ist.psu.edu/rd/31439032%2C732348%2C1%2C0.25%2CDownload/http://citeseer.ist.psu.edu/cache/papers/cs2/82/http:zSzzSzwww-staff.it.uts.edu.auzSz%7EcbjzSzPublicationszSzimperatives.pdf/the-polymorphic-imperative.pdf},
	institution = {Univeristy of Technology, Sydney},
	author = {Jay, Barry and Lu, H Y and Nguyen, Q T},
	month = jan,
	year = {2000},
}

@article{kinnunen_why_2006,
	title = {Why students drop out {CS1} course?},
	url = {http://dl.acm.org/citation.cfm?id=1151604},
	abstract = {... a part of a larger research project at Helsinki University of Technology that concerns with studying ... 
In addition to questions concern - ing the CS1 course itself, we included some social ... actual
drop-out decision because there were numer- ous difficulties that students connected to ...},
	journal = {…  of the second international workshop on  …},
	author = {Kinnunen, P and Malmi, L},
	month = jan,
	year = {2006},
}

@misc{graham_beating_nodate,
	title = {Beating the {Averages}},
	url = {http://www.paulgraham.com/avg.html},
	journal = {paulgraham.com},
	author = {Graham, Paul},
}

@book{finkel_advanced_1995,
	title = {Advanced {Programming} {Language} {Design}},
	publisher = {Addison-Wesley},
	author = {Finkel, Raphael A},
	month = dec,
	year = {1995},
}

@techreport{jay_pattern_2005,
	title = {The {Pattern} {Calculus} a draft chapter on the untyped calculus {NOT} {FOR} {CIRCULATION}},
	institution = {not published},
	author = {Jay, Barry},
	month = may,
	year = {2005},
}

@inproceedings{bransen_generic_2013,
	title = {Generic representations of tree transformations},
	isbn = {978-1-4503-2389-5},
	url = {http://dl.acm.org/citation.cfm?doid=2502488.2502490},
	doi = {10.1145/2502488.2502490},
	abstract = {Abstract Applications which deal with editing of structured data over multiple iterations, such as structure editors, exercise assistants, or applications which support incremental computation, need to represent transformations between different versions of data. A ...},
	booktitle = {{WGP} '13},
	publisher = {SIGPLAN, ACM Special Interest Group on Programming Languages},
	author = {Bransen, Jeroen and Magalhães, José Pedro},
	month = sep,
	year = {2013},
	pages = {73--84},
}

@article{garcia_extended_2006,
	title = {An extended comparative study of language support for generic programming},
	volume = {17},
	number = {02},
	journal = {Journal of Functional Programming},
	author = {Garcia, Ronald and jaakko, Jarvi and Lumsdaine, Andrew and Siek, Jeremy and Willcock, Jeremiah},
	month = jan,
	year = {2006},
	pages = {145--205},
}

@article{roberts_artificial_2002,
	title = {Artificial {Actors} for {Real} {World} {Environments}},
	url = {http://www.aaai.org/Papers/Symposia/Spring/2002/SS-02-01/SS02-01-017.pdf},
	abstract = {Abstract We have developed a simulation environment called CreatureSpace that allows us to test our agent theories on intelligent agents in a complex realistic environment . We present the CreatureSpace architecture and our experiences in combining multiple ...},
	author = {Roberts, Matthew},
	month = jan,
	year = {2002},
}

@article{marlow_making_2006,
	title = {Making a fast curry: push/enter vs. eval/apply for higher-order languages},
	volume = {16},
	number = {4-5},
	journal = {Journal of Functional Programming},
	author = {Marlow, Simon and Peyton Jones, Simon},
	month = jan,
	year = {2006},
	pages = {415--449},
}

@misc{tolmach_external_nodate,
	title = {An {External} {Representation} for the {GHC} {Core} {Language} ({DRAFT} for {GHC5}.02)},
	author = {Tolmach, Andrew P},
}

@book{jay_pattern_2009,
	series = {Computing with {Functions} and {Structures}},
	title = {Pattern {Calculus}},
	isbn = {9783540891857},
	url = {http://books.google.com.au/books?id=Q_J4Lnmfjx4C&printsec=frontcover&dq=intitle:Pattern+Calculus+Computing+with+Functions+and+Structures&hl=&cd=1&source=gbs_api},
	abstract = {Introduces static and dynamic pattern calculus. This book shows how Lisp is more than just lambda-calculus. It is suitable for researchers with an interest in the foundations of computing, programming language design, the integration of existing programming styles, or the development of new programming styles.},
	publisher = {Springer},
	author = {Jay, Barry},
	month = jul,
	year = {2009},
}

@inproceedings{visser_core_1998,
	title = {A {Core} {Language} for {Rewriting}},
	volume = {15},
	url = {http://www.cs.uu.nl/people/visser/ftp/VB98.ps.gz},
	publisher = {Elsevier Science Publishers},
	author = {Visser, Eelco and Benaissa, Zine-el-Abidine},
	editor = {Kirchner, Claude and Kirchner, H},
	month = sep,
	year = {1998},
}

@article{johann_impact_2006,
	title = {The {Impact} of seq on {Free} {Theorems}-{Based} {Program} {Transformations}.},
	url = {http://iospress.metapress.com/content/7grd03nqmrwvtxv6/},
	journal = {Fundamenta Informaticae},
	author = {Johann, Patricia and Voigtländer, Janis},
	month = jan,
	year = {2006},
	pages = {63--102},
}

@inproceedings{oliveira_typecase:_2005,
	title = {{TypeCase}: a design pattern for type-indexed functions},
	isbn = {159593071X},
	url = {http://portal.acm.org/citation.cfm?doid=1088348.1088358},
	doi = {10.1145/1088348.1088358},
	abstract = {A type-indexed function is a function that is defined for each member of some family of types. Haskell's type class mechanism provides collections of open type-indexed functions, in which the indexing family can be extended by defining},
	publisher = {ACM  Request Permissions},
	author = {Oliveira, Bruno C d S and Gibbons, Jeremy},
	month = sep,
	year = {2005},
	pages = {98--109},
}

@article{mathieson_high_nodate,
	title = {High {Frequency} {Formative} {Assessment} in {Small} {Computer} {Science} {Honours} {Classes}},
	author = {Mathieson, Luke},
}

@article{kumar_data_2012,
	title = {Data science overtakes computer science?},
	volume = {3},
	url = {http://dl.acm.org/citation.cfm?doid=2339055.2339060},
	doi = {10.1145/2339055.2339060},
	number = {3},
	journal = {Inroads},
	author = {Kumar, Deepak},
	month = sep,
	year = {2012},
	pages = {18--19},
}

@misc{noauthor_yhc/api/core_2007,
	title = {{YHC}/{API}/{Core}},
	url = {http://haskell.org/haskellwiki/Yhc/API/Core#Some_little_samples},
	journal = {haskell.org},
	month = jul,
	year = {2007},
}

@article{wack_simply-typed_2004,
	title = {The {Simply}-{Typed} {Pure} {Pattern} {Type} {System} {Ensures} {Strong} {Normalization}},
	volume = {155},
	issn = {1-4020-8140-5},
	url = {http://link.springer.com/10.1007/1-4020-8141-3_48},
	doi = {10.1007/1-4020-8141-3_48},
	abstract = {Abstract Pure Pattern Type Systems (P 2 TS) combine in a unified setting the capabilities of rewriting and λ-calculus. Their type systems , adapted from Barendregt's λ-cube are especially interesting from a logical point of view. Strong normalization , an essential ...},
	number = {Chapter 48},
	journal = {Exploring New Frontiers of Theoretical Informatics},
	author = {Wack, Benjamin},
	month = jan,
	year = {2004},
	keywords = {rho-calculus},
	pages = {633--646},
}

@phdthesis{santos_notitle_1995,
	url = {citeseer.ist.psu.edu/santos95compilation.html},
	author = {Santos, A},
	month = jan,
	year = {1995},
}

@article{lafer_polymorphic_1994,
	title = {Polymorphic type inference and abstract data types},
	volume = {16},
	number = {5},
	journal = {ACM Transactions on Programming Languages and Systems (TOPLAS)},
	author = {Läfer, K and Odersky, Martin},
	month = jan,
	year = {1994},
	pages = {1411--1430},
}

@techreport{tarditi_til:_1996,
	title = {{TIL}: {A} {Type}-{Directed} {Optimizing} {Compiler} for {ML}},
	author = {Tarditi, David and Morrisett, G and Cheng, Perry and Stone, Christopher and Harper, Robert and Lee, Peter},
	month = jan,
	year = {1996},
}

@article{le_fessant_optimizing_2001,
	title = {Optimizing pattern matching},
	journal = {Proceedings of the sixth ACM SIGPLAN international conference on Functional programming},
	author = {Le Fessant, F and Maranget, L},
	month = jan,
	year = {2001},
	pages = {26--37},
}

@techreport{jones_implementation_1994,
	title = {The implementation of the {Gopher} functional programming system},
	institution = {Yale University},
	author = {Jones, Mark P},
	month = may,
	year = {1994},
}

@book{noauthor_machine_nodate,
	title = {Machine {Obstructed} {Proofs} ({How} many months can it take to verify 30 assembly instructions?)},
}

@inproceedings{hinze_``scrap_2006,
	title = {``{Scrap} your boilerplate'' {Revolutions}},
	publisher = {Springer-Verlag},
	author = {Hinze, Ralf and Löh, Andres},
	month = jan,
	year = {2006},
	pages = {180--208},
}

@techreport{peyton_jones_how_2004,
	title = {How to write a good research paper},
	url = {http://research.microsoft.com/~simonpj/papers/giving-a-talk/giving-a-talk.htm},
	institution = {online},
	author = {Peyton Jones, Simon},
	month = oct,
	year = {2004},
}

@article{aleven_effective_2002,
	title = {An effective metacognitive strategy: learning by doing and explaining with a computer-based {Cognitive} {Tutor}},
	volume = {26},
	url = {http://doi.wiley.com/10.1016/S0364-0213(02)00061-7},
	doi = {10.1016/S0364-0213(02)00061-7},
	abstract = {Recent studies have shown that self-explanation is an effective metacognitive strategy , but how can it be leveraged to improve students' learning in actual classrooms? How do instructional treatments that emphasizes self-explanation affect students' learning, as ...},
	number = {2},
	journal = {Cognitive Science},
	author = {Aleven, V},
	month = apr,
	year = {2002},
	pages = {147--179},
}

@inproceedings{ma_investigating_2007,
	title = {Investigating the viability of mental models held by novice programmers},
	volume = {39},
	isbn = {1595933611},
	url = {http://portal.acm.org/citation.cfm?doid=1227310.1227481},
	doi = {10.1145/1227310.1227481},
	abstract = {This paper describes an investigation into the viability of mental models used by novice programmers at the end of a first year Java programming course. The qualitative findings identify the range of mental models of value and reference assignment held},
	publisher = {ACM  Request Permissions},
	author = {Ma, Linxiao and Ferguson, John and Roper, Marc and Wood, Murray},
	month = mar,
	year = {2007},
	pages = {499--503},
}

@techreport{dolstra_building_2002,
	title = {Building {Interpreters} with {Rewriting} {Strategies}},
	institution = {Institute of Information and Computing Sciences, Utrecht University},
	author = {Dolstra, Eelco and Visser, Eelco},
	month = may,
	year = {2002},
}

@article{cirstea_rewriting_2004,
	title = {Rewriting {Calculus} with {Fixpoints}: {Untyped} and {First}-{Order} {Systems}},
	volume = {3085},
	issn = {978-3-540-24849-1},
	url = {http://link.springer.com/10.1007/978-3-540-24849-1_10},
	doi = {10.1007/978-3-540-24849-1_10},
	abstract = {Abstract The rewriting calculus , also called ρ- calculus , is a framework embedding λ- calculus and rewriting capabilities, by allowing abstraction not only on variables but also on patterns. The higher- order mechanisms of the λ- calculus and the pattern matching facilities of the ...},
	number = {Chapter 10},
	journal = {Lecture Notes in Computer Science},
	author = {Cirstea, Horatiu and Liquori, Luigi and Wack, Benjamin},
	month = jan,
	year = {2004},
	keywords = {rho-calculus},
	pages = {147--161},
}

@book{boiten_mathematics_2002,
	address = {Berlin, Heidelberg},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Mathematics of {Program} {Construction}},
	volume = {2386},
	isbn = {0302-9743},
	url = {http://link.springer.com/10.1007/3-540-45442-X},
	publisher = {Springer Berlin Heidelberg},
	editor = {Boiten, Eerke A and Möller, Bernhard},
	month = jun,
	year = {2002},
}

@inproceedings{given-wilson_multi-polymorphic_2013,
	title = {Multi-polymorphic programming in bondi},
	url = {http://dl.acm.org/citation.cfm?id=2502493},
	abstract = {Abstract The bondi programming language is multi - polymorphic , in that it supports four polymorphic programming styles within a small core of computation, namely a typed pattern calculus. bondi's expressive power is illustrated by considering the problem of assigning ...},
	booktitle = {{WGP} '13},
	publisher = {SIGPLAN, ACM Special Interest Group on Programming Languages},
	author = {Given-Wilson, T and Huang, F and Jay, B},
	month = jan,
	year = {2013},
	keywords = {bondi, pattern calculus},
}

@book{peterson_implementing_1993,
	series = {{ACM} {SIGPLAN} {Notices}},
	title = {Implementing type classes},
	volume = {28},
	isbn = {0-89791-598-4},
	url = {http://portal.acm.org/citation.cfm?doid=173262.155112},
	abstract = {Abstract We describe the implementation of a type checker for the functional programming language Haskell that supports the use of type classes . This extends the type system of ML to support overloading (ad-hoc polymorphism) and can be used to implement features ...},
	publisher = {ACM},
	author = {Peterson, John and Jones, Mark and Peterson, John and Jones, Mark},
	month = jun,
	year = {1993},
}

@article{hinze_generic_2009,
	title = {Generic programming in {3D}},
	url = {http://www.sciencedirect.com/science/article/pii/S0167642309000252},
	abstract = {Support for generic programming consists of three essential ingredients: support for overloaded functions, a run-time type representation, and a generic view on data. Different approaches to datatype- generic programming occupy different points in this design space. ...},
	journal = {Science of Computer Programming},
	author = {Hinze, Ralf and Löh, Andres},
	month = jan,
	year = {2009},
}

@article{henglein_sorting_nodate,
	title = {Sorting and {Searching} by {Distribution}: {From} {Generic} {Discrimination} to {Generic} {Tries}},
	url = {http://www.cs.ox.ac.uk/ralf.hinze/WG2.8/31/slides/aplas2013.pdf},
	abstract = {...  Sorting and Searching by Distribution 11 ... For lexicographic string sorting this specializes to the property of MSD radix sort, which only traverses the minimum distinguishing ... Finally, characters are sorted using bucket sort—this time we simply return the list of non-empty buckets. ...},
	journal = {cs.ox.ac.uk},
	author = {Henglein, Fritz and Hinze, Ralf},
	keywords = {generics},
}

@inproceedings{gibbons_datatype-generic_2006,
	title = {Datatype-{Generic} {Programming}},
	author = {Gibbons, Jeremy},
	month = jan,
	year = {2006},
}

@article{glover_testing_1989,
	title = {The "{Testing}" {Phenomenon}: {Not} {Gone} but {Nearly} {Forgotten}},
	abstract = {Abstract 1. The" testing " phenomenon refers to the finding that students who take a test on material between the time they first study and the time they take a final test remember more of the material than students who do not take an intervening test . 4 experiments examined  ...},
	journal = {Journal of Educational Psychology},
	author = {Glover, John},
	month = jan,
	year = {1989},
	pages = {1--8},
}

@article{middendorf_table_1996,
	title = {Table of {Contents}},
	volume = {5},
	url = {http://doi.wiley.com/10.1002/ntlf.10026},
	doi = {10.1002/ntlf.10026},
	abstract = {Instructors and students often have the same mental image of how a college class works: The professor talks ( lectures ); the students usually listen and occasionally write something in their notes. But as teaching consultants visiting a great many classes, we've found the real ...},
	number = {2},
	journal = {The National Teaching \& Learning Forum},
	author = {Middendorf, Joan and Kalish, Alan},
	month = feb,
	year = {1996},
	pages = {1--12},
}

@article{yadin_reducing_2011,
	title = {Reducing the dropout rate in an introductory programming course},
	volume = {2},
	url = {http://dl.acm.org/citation.cfm?doid=2038876.2038894},
	doi = {10.1145/2038876.2038894},
	abstract = {This article describes an action research for reducing the high students' dropout rate after an introductory programming course. As part of the action research, that was performed during four semesters several course structures and learning tactics were},
	number = {4},
	journal = {Inroads},
	author = {Yadin, Aharon},
	month = dec,
	year = {2011},
	pages = {71},
}

@inproceedings{jay_scrap_2008,
	title = {Scrap your type applications},
	author = {Jay, Barry and Peyton Jones, Simon},
	month = jan,
	year = {2008},
}

@inproceedings{jay_typing_2006,
	title = {Typing first-class patterns.},
	url = {http://hor.pps.jussieu.fr/06/proc/jay1.pdf},
	author = {Jay, Barry},
	month = jan,
	year = {2006},
}

@inproceedings{peyton_jones_compiling_1996,
	title = {Compiling {Haskell} by {Program} {Transformation}: {A} {Report} from the {Trenches}},
	url = {citeseer.ist.psu.edu/peytonjones96compiling.html},
	author = {Peyton Jones, Simon},
	month = jan,
	year = {1996},
	pages = {18--44},
}

@techreport{tarditi_retrospective:_nodate,
	title = {Retrospective: {TIL}: {A} {Type}-{Directed}, {Optimizing} {Compiler} for {ML}},
	url = {citeseer.ist.psu.edu/751942.html},
	author = {{Tarditi}},
}

@techreport{noauthor_essence_nodate,
	title = {The {Essence} of {Strategic} {Programming} - {DRAFT}},
}

@incollection{hinze_``scrap_2006,
	title = {``{Scrap} {Your} {Boilerplate}'' {Reloaded}},
	volume = {3945},
	isbn = {978-3-540-33438-5},
	url = {http://dx.doi.org/10.1007/11737414_3},
	booktitle = {Functional and {Logic} {Programming}},
	publisher = {Springer Berlin Heidelberg},
	author = {Hinze, Ralf and Löh, Andres and Oliveira, Bruno C. d. S.},
	editor = {Hagiya, Masami and Wadler, Philip},
	month = jan,
	year = {2006},
	keywords = {generics, ghc, spine view, syb},
	pages = {13--29},
}

@inproceedings{damas_principal_1982,
	title = {Principal type-schemes for functional programs},
	url = {http://dl.acm.org/citation.cfm?id=582176},
	abstract = {This paper is concerned with the polymorphic type discipline of NL, which is a general purpose functional programming language, although it was first introduced as a metalanguage(whence its name) for conducting proofs in the LCF proof system [GMW]. ...},
	author = {Damas, L and Milner, R},
	month = jan,
	year = {1982},
}

@article{hartel_compilation_1994,
	title = {Compilation of {Functional} {Languages} using {Flow} {Graph} {Analysis}},
	volume = {24},
	url = {citeseer.ist.psu.edu/hartel94compilation.html},
	number = {2},
	journal = {Software - Practice and Experience},
	author = {Hartel, Pieter H and Glaser, Hugh and Wild, John M},
	month = jan,
	year = {1994},
	pages = {127--173},
}

@inproceedings{brus_clean:_1987,
	title = {{CLEAN}: {A} language for functional graph rewriting},
	isbn = {0-387-18317-5},
	url = {http://dl.acm.org/citation.cfm?id=36583.36603},
	publisher = {Springer-Verlag},
	author = {Brus, T H and van Eekelen, C J D and van Leer, M O and Plasmeijer, M J},
	month = jan,
	year = {1987},
	pages = {364--384},
}

@article{peyton_jones_secrets_2002,
	title = {Secrets of the {Glasgow} {Haskell} {Compiler} inliner},
	volume = {12},
	url = {http://dx.doi.org/10.1017/S0956796802004331},
	doi = {10.1017/S0956796802004331},
	number = {5},
	journal = {Journal of Functional Programming},
	author = {Peyton Jones, Simon and Marlow, Simon},
	month = jan,
	year = {2002},
	pages = {393--434},
}

@inproceedings{moreau_pattern-matching_2001,
	title = {A {Pattern}-{Matching} {Compiler}},
	volume = {44},
	publisher = {Electronic Notes in Theoretical Computer Science},
	author = {Moreau, Pierre-Etienne and Ringeissen, Christophe and Vittek, Marian},
	editor = {Parigot, Didier and van den Brand, Mark G J},
	month = jan,
	year = {2001},
}

@article{lee_proofs_1998,
	title = {Proofs about a folklore let-polymorphic type inference algorithm},
	volume = {20},
	url = {http://portal.acm.org/citation.cfm?doid=291891.291892},
	doi = {10.1145/291891.291892},
	abstract = {Abstract The Hindley/Milner let - polymorphic type inference system has two different algorithms : one is the de facto standard Algorithm W that is bottom-up (or context- insensitive), and the other is a “ folklore ” algorithm that is top-down (or context-sensitive). ...},
	number = {4},
	journal = {Advanced Functional Programming: First International Spring School on Advanced Functional Programming Techniques, Båstad, Sweden, May 24-30, 1995: Tutorial Text},
	author = {Lee, Oukseh and Yi, Kwangkeun},
	month = jul,
	year = {1998},
	pages = {707--723},
}

@techreport{noauthor_ivor_nodate,
	title = {Ivor, a {Proof} {Engine} [{DRAFT}]},
}

@misc{noauthor_hunit_nodate,
	title = {hunit},
	url = {http://hunit.sourceforge.net/HUnit-1.0/Guide.html},
	journal = {hunit.sourceforge.net},
}

@article{wakeling_spreadsheet_2007,
	title = {Spreadsheet functional programming},
	volume = {17},
	url = {http://dx.doi.org/10.1017/S0956796806006186},
	doi = {10.1017/S0956796806006186},
	number = {1},
	journal = {Journal of Functional Programming},
	author = {Wakeling, David},
	month = jan,
	year = {2007},
	pages = {131--143},
}

@misc{anon_elan_nodate,
	title = {{ELAN} - {Related} {Systems}},
	url = {http://elan.loria.fr/overview/elan-related.html},
	journal = {elan.loria.fr},
	author = {{Anon}},
}

@techreport{jay_bondi_2004,
	title = {bondi},
	url = {www-staff.it.uts.edu.au/~cbj/bondi},
	author = {Jay, Barry},
	month = jan,
	year = {2004},
}
